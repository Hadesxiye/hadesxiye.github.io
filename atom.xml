<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fun&amp;Enjoy</title>
  
  <subtitle>this is Hades&#39;s blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hadesxiye.github.io/"/>
  <updated>2018-08-20T09:39:46.451Z</updated>
  <id>https://hadesxiye.github.io/</id>
  
  <author>
    <name>Hades</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell脚本的入门（一）</title>
    <link href="https://hadesxiye.github.io/2018/08/15/Shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hadesxiye.github.io/2018/08/15/Shell脚本的入门（一）/</id>
    <published>2018-08-15T10:48:08.000Z</published>
    <updated>2018-08-20T09:39:46.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Simple-BB"><a href="#Simple-BB" class="headerlink" title="Simple BB"></a><strong>Simple BB</strong></h2><blockquote><p>脚本能极大简化那些简答而重复的工作，因此学会写脚本去处理这些问题我觉得必不可缺。<br>为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路<br>首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。<br>获取目标资源的路径，根据A中的行数进行循环<code>find</code>查找，找到就用<code>cp</code>命令替换，未找到的重定向输出到临时文件B<br>最后打印B的内容，<code>remove</code>临时文件。<br>其中对文本的处理使用了<code>awk</code>命令</p></blockquote><p>脚本下载地址在我的github上 <a href="https://github.com/Hadesxiye/Shell_ReplaceSameNameFile" target="_blank" rel="noopener">资源替换脚本</a></p><hr><h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a><strong>Shell介绍</strong></h2><blockquote><p>Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。<br>而我使用shell只是因为<br>我用的mac - -</p></blockquote><hr><h2 id="Shell的工作原理"><a href="#Shell的工作原理" class="headerlink" title="Shell的工作原理"></a><strong>Shell的工作原理</strong></h2><blockquote><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p></blockquote><hr><h2 id="Shell的创建"><a href="#Shell的创建" class="headerlink" title="Shell的创建"></a><strong>Shell的创建</strong></h2><blockquote><p>1.打开文本编辑工具，输入一下内容<br><code>#!/bin/bashecho &quot;Hello World&quot;</code><br>2.保存为 <code>hello world.sh</code>在目录 A<br>3.在终端<code>cd</code>到目录 A<br>4.终端输入<code>chmod +x ./hello world.sh</code> （这一步是给脚本添加权限）<br>5.执行脚本   <code>./hello world.sh</code> 或者 直接把 <code>hello world.sh</code>拖入终端</p></blockquote><p>这很简单，无图。</p><hr><h2 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a><strong>Shell中的变量</strong></h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=&quot;a1&quot;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=a1</span><br></pre></td></tr></table></figure><p>但是<br><code>example=a 1</code>  并不等同于 <code>example=&quot;a 1&quot;</code><br>因为<code>&quot; &quot;</code>（空格）在shell中用作指令的间隔<br><code>example=a 1</code> 其实只是将a负责给example 然后在输入了个1</p><blockquote><p>这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！</p></blockquote><h3 id="变量的访问"><a href="#变量的访问" class="headerlink" title="变量的访问"></a>变量的访问</h3><p>在变量前加上<code>$</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $example</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a><strong>Shell中的四则运算</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a + $b</span><br><span class="line">$a - $b</span><br><span class="line">$a \* $b</span><br><span class="line">$a / $b</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>乘法的时候需要进行转义<br><code>=</code> 赋值时，前后无空格<br>而运算符号前后必须有空格</p></blockquote><hr><h2 id="Shell中的其他运算符"><a href="#Shell中的其他运算符" class="headerlink" title="Shell中的其他运算符"></a><strong>Shell中的其他运算符</strong></h2><blockquote><p>=、==、!=、！、-o、-a</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-o 或</span><br><span class="line">-a 与</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><blockquote><p>-eq        两个数相等返回true<br>-ne          两个数不相等返回true<br>-gt            左侧数大于右侧数返回true<br>-It          左侧数小于右侧数返回true<br>-ge        左侧数大于等于右侧数返回true<br>-le            左侧数小于等于右侧数返回true</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><blockquote><p>=    两个字符串相等返回true<br>!=    两个字符串不相等返回true<br>-z    字符串长度为0返回true<br>-n    字符串长度不为0返回true<br>-d file    检测文件是否是目录，如果是，则返回 true<br>-r file    检测文件是否可读，如果是，则返回 true<br>-w file    检测文件是否可写，如果是，则返回 true<br>-x file    检测文件是否可执行，如果是，则返回 true<br>-s file    检测文件是否为空（文件大小是否大于0，不为空返回 true<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true</p></blockquote><hr><h2 id="Shell字符串操作"><a href="#Shell字符串操作" class="headerlink" title="Shell字符串操作"></a><strong>Shell字符串操作</strong></h2><pre><code>  mtext="hello"  #定义字符串  mtext2="world"  mtext3=$mtext" "$mtext2  #字符串的拼接  echo $mtext3  #输出字符串  echo ${#mtext3}  #输出字符串长度  echo ${mtext3:1:4}  #截取字符串</code></pre><hr><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a><strong>Shell数组</strong></h2><pre><code>  array=(1 2 3 4 5)  #定义数组  array2=(aa bb cc dd ee)  #定义数组  value=${array[3]}  #找到某一个下标的数，然后赋值  echo $value  #打印  value2=${array2[3]}  #找到某一个下标的数，然后赋值  echo $value2  #打印  length=${#array[* ]}  #获取数组长度  echo $length</code></pre><hr><h2 id="Shell输出"><a href="#Shell输出" class="headerlink" title="Shell输出"></a><strong>Shell输出</strong></h2><pre><code>  echo</code></pre><hr><h2 id="Shell的判断"><a href="#Shell的判断" class="headerlink" title="Shell的判断"></a><strong>Shell的判断</strong></h2><pre><code>  a=10  b=20  if [ $a == $b ]  then  echo "true"  fi  if [ $a == $b ]  then  echo "true"  else  echo "false"  fi  if [ $a == $b ]  then  echo "a is equal to b"  elif [ $a -gt $b ]  then  echo "a is greater than b"  elif [ $a -lt $b ]  then  echo "a is less than b"  else  echo "None of the condition met"  fi</code></pre><hr><h2 id="Shell中的test命令"><a href="#Shell中的test命令" class="headerlink" title="Shell中的test命令"></a><strong>Shell中的test命令</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  test $[num1] -eq $[num2]  #判断两个变量是否相等</span><br><span class="line">  test num1=num2  #判断两个数字是否相等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-e file    文件存在则返回真</span><br><span class="line">-r file    文件存在并且可读则返回真</span><br><span class="line">-w file    文件存在并且可写则返回真</span><br><span class="line">-x file    文件存在并且可执行则返回真</span><br><span class="line">-s file    文件存在并且内容不为空则返回真</span><br><span class="line">-d file    文件目录存在则返回真</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的循环"><a href="#Shell中的循环" class="headerlink" title="Shell中的循环"></a><strong>Shell中的循环</strong></h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code>  for ((i=1;i<=10;i++)) 5="" 6="" 7="" 8="" 9="" do="" echo="" $i="" done="" for="" i="" in="" {1..5}="" file="" $home="" .bash*="" $file="" <="" code=""></=10;i++))></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>  while [ $COUNTER -lt 5 ]  do  COUNTER=`expr $COUNTER + 1`  echo $COUNTER  done  echo '请输入。。。'  echo 'ctrl + d 即可停止该程序'  while read FILM  do  echo "Yeah! great film the $FILM"  done</code></pre><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><pre><code>  break  #跳出所有循环  break n  #跳出第n层f循环  continue  #跳出当前循环</code></pre><hr><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a><strong>Shell中的函数</strong></h2><blockquote><p>无参数无返回值</p></blockquote><pre><code>  sysout(){  echo "hello world"  }  sysout    </code></pre>> 无参数有返回值<pre><code>  test(){  aNum=3  anotherNum=5  return $(($aNum+$anotherNum))  }  test  result=$?  echo $result</code></pre>> 有参数有返回值<pre><code>  test(){  echo $1  #接收第一个参数  echo $2  #接收第二个参数  echo $3  #接收第三个参数  echo $#  #接收到参数的个数  echo $*  #接收到的所有参数  }  test aa bb cc    </code></pre><h2 id="Shell中的重定向"><a href="#Shell中的重定向" class="headerlink" title="Shell中的重定向"></a><strong>Shell中的重定向</strong></h2><pre><code>  $echo result > file  #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写  $echo result >> file  #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写  echo input < file  #获取输入流</code></pre><h2 id="Shell中的变量操作"><a href="#Shell中的变量操作" class="headerlink" title="Shell中的变量操作"></a><strong>Shell中的变量操作</strong></h2><blockquote><p>awk 指令<br>获取指定行数的资源名字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceNameTemp=$(awk &apos;NR==&quot;&apos;$i&apos;&quot; &#123;print;exit&#125;&apos; $OutputFile)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取对应文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp=$&#123;temp##*/&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>清空文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: &gt; &quot;$OutputFile&quot;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a><strong>常用的Linux命令</strong></h2><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><blockquote><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p></blockquote><blockquote><p>基本结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&apos; file</span><br></pre></td></tr></table></figure></p></blockquote><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中</p><p> <strong>工作原理</strong></p><blockquote><p>第一步：执行BEGIN{ commands }语句块中的语句；<br>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。<br>第三步：当读至输入流末尾时，执行END{ commands }语句块。</p></blockquote><p><strong>BEGIN</strong>语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p><p><strong>END</strong>语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p><p><strong>pattern</strong>语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p><blockquote><p>获取指定行数的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR==&quot;&apos;$i&apos;&quot; &#123;print;exit&#125;&apos; file</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取文件的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print NR&#125;&apos; &quot;file&quot;|tail -n1</span><br></pre></td></tr></table></figure></p></blockquote><p>关于awk的详细用法请参考 <a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">awk命令</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Simple-BB&quot;&gt;&lt;a href=&quot;#Simple-BB&quot; class=&quot;headerlink&quot; title=&quot;Simple BB&quot;&gt;&lt;/a&gt;&lt;strong&gt;Simple BB&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;脚本能极大简化那些简答而
      
    
    </summary>
    
      <category term="Shell" scheme="https://hadesxiye.github.io/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://hadesxiye.github.io/tags/Shell/"/>
    
      <category term="Linux" scheme="https://hadesxiye.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
