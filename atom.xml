<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fun&amp;Enjoy</title>
  
  <subtitle>this is Hades&#39;s blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hadesxiye.github.io/"/>
  <updated>2018-11-26T09:44:55.029Z</updated>
  <id>https://hadesxiye.github.io/</id>
  
  <author>
    <name>Hades</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift4.2光速入门٩(๑&gt;◡&lt;๑)۶</title>
    <link href="https://hadesxiye.github.io/2018/11/26/Swift/"/>
    <id>https://hadesxiye.github.io/2018/11/26/Swift/</id>
    <published>2018-11-26T06:08:44.000Z</published>
    <updated>2018-11-26T09:44:55.029Z</updated>
    
    <content type="html"><![CDATA[<p><center>Xcode10发布了，支持swift3和swift4，使用swift开发的项目也越来越多。<br>是时候学swift了，一起来光速入门吧~</center><br><a id="more"></a></p><h2 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h2><p>swift采用了现代编程模式，以避免大量常见的低级编程错误：</p><ul><li>变量永远会在被使用前完成初始化</li><li>对数组的索引操作会自动检查是否出现越界错误</li><li>整型数值会自动检查是否溢出</li><li>可选值确保<code>nil</code>值被正确处理</li><li>内存被自动管理</li><li>错误处理允许从异常故障控制恢复</li></ul><p>当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享：</p><ul><li>子字符串的操作返回的实例是<code>Substring</code>类型而不是<code>String</code></li><li>在较少的地方会隐性增加<code>@objc</code>属性</li><li>同一文件中类型的拓展可以访问该类型中的私有成员</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，从hello world开始<br>用swift实现可太tm简单了<br>用xcode创建一个swift blank项目，在playground中输入一句话<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world!"</span>)</span><br></pre></td></tr></table></figure></p><p>全局作用域中的代码会自动作为程序的入口，因此；不需要<code>main()</code>函数，同样的，你也不需要写<code>;</code>了。</p><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><blockquote><p><code>lei</code>声明常量<br><code>var</code>声明变量</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">num =  <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> number  = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，<code>num</code>是个整数，因为它的初始值是一个整数。</p><blockquote><p>如果没有初始值，你又想声明类型，你只要在变量后声明类型，用<code>:</code>分割。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num3:<span class="type">Double</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>swift有一种更简单的方式让值转为字符串：把值写在<code>()</code>内，在括号之前再加一个<code>\</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"girlfriend"</span></span><br><span class="line"><span class="keyword">let</span> sum1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> sum2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I used to have <span class="subst">\(sum1)</span> <span class="subst">\(str)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"and now I have <span class="subst">\(sum1*sum2)</span> <span class="subst">\(str)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"pretty girl check your wechat number and send it to me pls:)"</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>对于占用多行的字符串可以使用三个引号<code>&quot;&quot;&quot;</code>每行的来头缩进要和右引号的缩进相同<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">hello~</span></span><br><span class="line"><span class="string">this my wechat number</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用<code>[]</code>来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"my"</span>,<span class="string">"name"</span>,<span class="string">"is"</span>,<span class="string">"hades"</span>]</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"whz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dic = [</span><br><span class="line">    <span class="string">"key1"</span>:<span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span>:<span class="string">"valeu2"</span></span><br><span class="line">]</span><br><span class="line">dic[<span class="string">"key2"</span>] = <span class="string">"value change"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用初始化语法来创建一个空数组或者字典<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArr = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDic = [<span class="type">String</span>:<span class="type">String</span>]()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果类型能<strong>被推断</strong>，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line">dic = [:]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><blockquote><p>使用<code>if</code>和<code>switch</code>来创建条件语句，使用<code>for</code>-<code>in</code>,<code>while</code>，以及<code>repeat</code>-<code>while</code>来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr = [<span class="number">123</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">43</span>,<span class="number">65</span>]</span><br><span class="line"><span class="keyword">var</span> totalNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> tempNum <span class="keyword">in</span> numArr &#123;</span><br><span class="line">    <span class="keyword">if</span> tempNum &lt; <span class="number">50</span> &#123;</span><br><span class="line">        totalNum -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        totalNum += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(totalNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"end of totalnum = <span class="subst">\(totalNum)</span>"</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在<code>if</code>语句中，条件语句必须是布尔表达式，可以使用<code>if</code>和<code>let</code>来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为<code>nil</code>表示值缺失。在值得类型后面跟随一个<code>?</code>则表示这个值是可选的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exampleStr:<span class="type">String</span>? = <span class="string">"hello"</span></span><br><span class="line"><span class="built_in">print</span>(exampleStr == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name:<span class="type">String</span>? = <span class="string">"hades"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"hello~"</span></span><br><span class="line"><span class="comment">//name = "xiye"</span></span><br><span class="line"><span class="comment">//name = nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> nameTemp = name &#123;  <span class="comment">//如果类型转换成功，则将值赋值给nameTemp直接使用</span></span><br><span class="line">    greeting = <span class="string">"hello~ <span class="subst">\(nameTemp)</span>"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"nameTemp = <span class="subst">\(nameTemp)</span> name = <span class="subst">\(name!)</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"( let nameTemp = name ) = true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name = nil "</span>) <span class="comment">//强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"( let nameTemp = name ) = false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>如果可选值为<code>nil</code>，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给<code>let</code>后的常量，这样代码中就可以使用这个值。</p><p>处理可选值得另一种方法是使用<code>??</code>操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nickName: <span class="type">String</span>? = <span class="literal">nil</span> <span class="comment">//"whz"</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> = <span class="string">"hades"</span></span><br><span class="line"><span class="comment">//nickName = "whz"</span></span><br><span class="line"><span class="comment">//nickName = nil</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting = <span class="string">"hi~ <span class="subst">\(nickName ?? fullName)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(informalGreeting)</span><br></pre></td></tr></table></figure><blockquote><p><strong>oc中的nil和swift中的nil</strong><br>Objective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)<br>Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil)</p></blockquote><blockquote><p>‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = <span class="string">"ex"</span></span><br><span class="line"><span class="keyword">switch</span> people &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"girl"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hey~ could you give me your wechat number?"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"man"</span>,<span class="string">"boy"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"oh...next pls"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"x"</span>):<span class="comment">//hasSuffix以指定后缀结束，hasPrefix以指定前缀开始</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"if time can come back..."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello stranger."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。<br>你可以为字典中的键值对起一组名字，并用<code>for</code> <code>in</code>语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumbers = [</span><br><span class="line">    <span class="string">"key1"</span>:[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">31</span>],</span><br><span class="line">    <span class="string">"key2"</span>:[<span class="number">2</span>,<span class="number">43</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">53</span>],</span><br><span class="line">    <span class="string">"key3"</span>:[<span class="number">2345</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">65</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> maxName:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (keyInSomeNumbers,valueInSomeNumbers) <span class="keyword">in</span> someNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> values <span class="keyword">in</span> valueInSomeNumbers &#123;</span><br><span class="line">        <span class="keyword">if</span> values &gt; maxNum &#123;</span><br><span class="line">            maxNum = values</span><br><span class="line">            maxName = <span class="string">"<span class="subst">\(keyInSomeNumbers)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(maxName)</span> <span class="subst">\(maxNum)</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>使用<code>while</code>来循环执行代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n*n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    m = m + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"m = <span class="subst">\(m)</span>"</span>)</span><br><span class="line">&#125;<span class="keyword">while</span> m &lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure></p><p>可以使用<code>..&lt;</code>来限定索引范围，并在循环中遍历该索引范围<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    total += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure></p><h3 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h3><p>使用<code>func</code>来声明一个函数。使用函数名和参数名来调用函数。使用<code>-&gt;</code>来指定函数返回值类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span> <span class="params">(person:String,day:String)</span></span>-&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>,today is <span class="subst">\(day)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"whz"</span>, day: <span class="string">"thuesday"</span>))</span><br></pre></td></tr></table></figure></p><p>默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用<code>_</code>来表示来不使用参数标签。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> preson:String,on day:String)</span></span>-&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello <span class="subst">\(preson)</span>,today is <span class="subst">\(day)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(<span class="string">"hades"</span>, on: <span class="string">"friday"</span>))</span><br></pre></td></tr></table></figure></p><p>使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(scores:[Int])</span></span> -&gt; (<span class="built_in">min</span>:<span class="type">Int</span>,<span class="built_in">max</span>:<span class="type">Int</span>,sum:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>,<span class="built_in">max</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = function(scores: [<span class="number">1</span>,<span class="number">31</span>,<span class="number">413</span>,<span class="number">356</span>,<span class="number">1</span>,<span class="number">376</span>,<span class="number">463</span>])</span><br><span class="line"><span class="built_in">print</span>(result.<span class="built_in">max</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span>-&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(returnFifteen())</span><br></pre></td></tr></table></figure></p><p>函数是一个类型。意味着函数可以作为其他函数的返回值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnOneFunction</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">returnOneInt</span><span class="params">(number:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOneInt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFunction = returnOneFunction()</span><br><span class="line"><span class="built_in">print</span>(anotherFunction(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>一个函数也可以作为参数传入另一个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list:[Int],condition:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">7</span>,<span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure></p><p>函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行<br>你可以使用<code>{}</code>来创建一个匿名闭包。使用<code>in</code>将参数和返回值类型与闭包函数体分离。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">7</span>,<span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br><span class="line"></span><br><span class="line">numbers.<span class="built_in">map</span>(&#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = [<span class="number">3</span>,<span class="number">41</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">51</span>]</span><br><span class="line"><span class="keyword">let</span> temp1 = temp.<span class="built_in">map</span>&#123;</span><br><span class="line">    num <span class="keyword">in</span></span><br><span class="line">    num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>swift自动为闭包提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(temp1)</span><br><span class="line"><span class="keyword">let</span> temp2 = temp.<span class="built_in">map</span>&#123;</span><br><span class="line">    $<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>通过在类名前加<code>class</code>关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在类名称后面插入括号来创建类的实例。使用<code>.</code>语法的方式来访问实例中的属性和方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span>  shapeDescription = shape.simpleDescription()</span><br><span class="line"><span class="built_in">print</span>(shapeDescription)</span><br></pre></td></tr></table></figure></p><p>当一个类的属性没有初始值，你就需要使用<code>init</code>来创建一个构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>self</code>被用来区分<code>name</code>属性和构造器的<code>name</code>参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。<br>如果你需要在对象被释放前执行一些清理的行为，可以使用<code>deinit</code>来创建一个折构器。 </p><p>子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。</p><p>子类如果需要重写父类的方法，则需要使用<code>override</code>来标记—不使用<code>override</code>关键字来标记会导致编译器报错。编译器同样也会检查<code>override</code>标记的方法是否存在父类当中。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>,name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length <span class="subst">\(sideLength)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">4.1</span>, name: <span class="string">"test square"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.area())</span><br><span class="line"><span class="built_in">print</span>(test.description())</span><br></pre></td></tr></table></figure></p><p>除了存储简单的属性，属性还可以拥有getter和setter<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilaterTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>,name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            sideLength = newValue / <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is a triangle with sides of length <span class="subst">\(sideLength)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> triangle = <span class="type">EquilaterTriangle</span>(sideLength: <span class="number">4.3</span>, name: <span class="string">"a triangle"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line">triangle.perimeter = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure></p><p>在<code>perimeter</code>的setter中，新值被隐式的命名为<code>newValue</code>。你可以在<code>set</code>的括号后面，显式的提供一个名字。</p><p>注意<code>EquilateralTriangle</code>类的初始化有三个不同的步骤：</p><ul><li>1 设定子类的声明的属性值</li><li>2 调用父类的构造器</li><li>3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。</li></ul><hr><p>如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用<code>willSet</code>和<code>didSet</code>。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilaterTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square:<span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(size:<span class="type">Double</span>,name:<span class="type">String</span>) &#123;</span><br><span class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle = <span class="type">EquilaterTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"test"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">40</span>, name: <span class="string">"larger square"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure></p><p>在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用<code>?</code>。如果<code>?</code>前的值是<code>nil</code>,则<code>?</code>后面的所有内容都会被忽略，且整个表达式为<code>nil</code>。否则，可选项的值将被展开，然后<code>?</code>后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="string">optionalSquare:</span> Square? = Square(sideLength: <span class="number">2.3</span>, <span class="string">name:</span> <span class="string">"optional square"</span>)</span><br><span class="line">let sideLength = optionalSquare?.sideLength</span><br></pre></td></tr></table></figure></p><hr><h3 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h3><p>使用<code>enum</code>来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ace = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> two,three,four,five,six,seven,eight,nine,ten</span><br><span class="line">    <span class="keyword">case</span> jack,queen,king</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ace:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></span><br><span class="line">        <span class="keyword">case</span> .jack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></span><br><span class="line">        <span class="keyword">case</span> .queen:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></span><br><span class="line">        <span class="keyword">case</span> .king:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"king"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.ace</span><br><span class="line"><span class="keyword">let</span> aceRawValue = ace.rawValue</span><br></pre></td></tr></table></figure></p><p>默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，<code>Ace</code>的原始值被显示赋值为<code>1</code>，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用<code>rawValue</code>属性来访问一个枚举成员的原始值。<br>使用<code>init?(rawValue:)</code>初始化构造器来创建一个拥有原始值得枚举实例。如果在<code>Rank</code>中有与该原始值相匹配的枚举实例则返回该实例，没有则返回<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank = <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> threeDescription = convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spades,hearts,diamonds,clubs</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .spades:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></span><br><span class="line">        <span class="keyword">case</span> .hearts:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></span><br><span class="line">        <span class="keyword">case</span> .diamonds:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></span><br><span class="line">        <span class="keyword">case</span> .clubs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.hearts</span><br><span class="line"><span class="keyword">let</span> haartsDescriotion = hearts.simpleDescription()</span><br></pre></td></tr></table></figure></p><p>注意在上面例子中用了两种方法来调用<code>hearts</code>成员：给<code>hearts</code>指定一个常量时，枚举成员<code>Suit.hearts</code>需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式<code>.hearts</code>被调用，因为<code>self</code>的值已经确定是<code>Suit</code>类型。在值得类型已经被明确的情况下可以使用缩写。</p><hr><p>如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>,<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.result(<span class="string">"6:00 am"</span>,<span class="string">"8:00 pm"</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.failure(<span class="string">"fail"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise,sunset):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" sunrise is at <span class="subst">\(sunrise)</span> and sunset is at<span class="subst">\(sunset)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"fail - <span class="subst">\(message)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意日出日落时间是如何从<code>ServerResponse</code>值中进行提取，并与 switch cases 相匹配的。</p><p>使用<code>struct</code>来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The <span class="subst">\(rank.simpleDescription()</span>) of <span class="subst">\(suit.simpleDescription()</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .three, suit: .spades)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure></p><hr><h3 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h3><p>使用<code>protocol</code>来声明一个协议。<br><code>mutating</code>关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类、枚举和结构都可以遵循协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"a simple class"</span></span><br><span class="line">    <span class="keyword">var</span> anotherPriperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"now 100% adjusted"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"a simple sturcture"</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"(adjusted)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = simpleStructure()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription = b.simpleDescription</span><br></pre></td></tr></table></figure></p><p>注意声明<code>SimpleStructure</code>时使用了关键字<code>mutating</code>来标记一个可以修改结构体的方法。而声明<code>SimpleClass</code>时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。</p><p>使用<code>extension</code>可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"the number <span class="subst">\(<span class="keyword">self</span>)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure></p><p>你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">//下面这句会报错</span></span><br><span class="line"><span class="built_in">print</span>(protocolValue.anotherProperty)</span><br></pre></td></tr></table></figure></p><p>尽管变量<code>protocolValue</code>在运行时类型为<code>SimpleClass</code>，但编译器依旧会把它的类型当做<code>ExampleProtocol</code>。这也就意味着，你不能随意访问在协议外的方法或属性。</p><hr><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>你可以使用任何遵循<code>Error</code>协议的类型来表示错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrintError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>throw</code>跑出异常并且用<code>throws</code>来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName == <span class="string">"Never Has Toner"</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrintError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Job sent"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几种方法可以处理异常。一种是使用<code>do</code>-<code>catch</code>。在<code>do</code>代码块里，你可以是用<code>try</code>在抛出的异常的函数前标记。在<code>catch</code>代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为<code>error</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">"Never Has Toner"</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以提供多个<code>catch</code>代码块来处理特定的错误。你可以在<code>catch</code>后面一个一个模式，就像switch语句里面的<code>case</code>一样。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">"Gutenberg"</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrintError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'll just put this over here, with the rest of the fire."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrintError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Printer error: <span class="subst">\(printerError)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外一种处理错误的方法是用<code>try?</code>去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为<code>nil</code>。否则，结果是一个包含了函数返回值的和选项。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess = <span class="keyword">try</span>? send(job: <span class="number">1883</span>, toPrinter: <span class="string">"Mergenthaler"</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure = <span class="keyword">try</span>? send(job: <span class="number">1885</span>, toPrinter: <span class="string">"Never Has Toner"</span>)</span><br></pre></td></tr></table></figure></p><p>使用<code>defer</code>来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用<code>defer</code>来简化代码。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent = [<span class="string">"milk"</span>,<span class="string">"eggs"</span>,<span class="string">"leftovers"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span><span class="params">(<span class="number">_</span> food: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = fridgeContent.<span class="built_in">contains</span>(food)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fridgeContains(<span class="string">"milk"</span>)</span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br></pre></td></tr></table></figure></p><p><code>defer</code>常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候<br><code>defer</code>会在该当前声明的作用域结束的时候执行<br>优先级： 局部优先、同级自下而上<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstProcesses</span><span class="params">(<span class="number">_</span> isOpen: Bool)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//作用域1 整个函数作用域</span></span><br><span class="line">    <span class="keyword">defer</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"推迟操作🐢"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"😳"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isOpen == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">//作用域2 if的作用域</span></span><br><span class="line">        <span class="keyword">defer</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"推迟操作🐌"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"😁"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">&#125;</span><br><span class="line">firstProcesses(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>把名字写在尖括号里来创建一个泛型方法或者类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;Item&gt;<span class="params">(repeating item: Item,numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">"knock"</span>, numberOfTimes: <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p>你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; = .<span class="keyword">none</span></span><br><span class="line">possibleInteger = .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>在类型名称后紧接<code>where</code>来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence, U: Sequence&gt;<span class="params">(<span class="number">_</span> lhs: T,<span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">U</span>.<span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Xcode10发布了，支持swift3和swift4，使用swift开发的项目也越来越多。&lt;br&gt;是时候学swift了，一起来光速入门吧~&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>LLVM是什么( ´ﾟωﾟ)？</title>
    <link href="https://hadesxiye.github.io/2018/08/23/LLVM/"/>
    <id>https://hadesxiye.github.io/2018/08/23/LLVM/</id>
    <published>2018-08-23T10:54:52.000Z</published>
    <updated>2018-11-26T09:58:08.686Z</updated>
    
    <content type="html"><![CDATA[<p><center>LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙</center><br><a id="more"></a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a><strong><font color="#FF8C00">LLVM</font></strong></h2><blockquote><p>一个开源编译器架构，目前Xcode采用的就是LLVM架构。</p></blockquote><h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a><strong><font color="#FF8C00">Clang</font></strong></h2><blockquote><p>由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。</p></blockquote><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a><strong><font color="#FF8C00">GCC</font></strong></h2><blockquote><p>GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p></blockquote><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a><strong><font color="#FF8C00">GNU</font></strong></h2><blockquote><p>GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。</p></blockquote><h2 id="在Xcode上使用GCC"><a href="#在Xcode上使用GCC" class="headerlink" title="在Xcode上使用GCC"></a><strong><font color="#FF8C00">在Xcode上使用GCC</font></strong></h2><blockquote><p>Xcode在C和C++上是支持使用GCC的，如下：<br><img src="/2018/08/23/LLVM/XcodeGNU.jpg" title="Xcode9.4上的截图"><br>具体参数的使用请参考：<a href="https://stackoverflow.com/questions/35300064/gnu-gcc-on-xcode" target="_blank" rel="noopener">stackoverflow:Xcode上的GNU GCC</a></p></blockquote><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="LLVM-1"><a href="#LLVM-1" class="headerlink" title="LLVM"></a>LLVM</h3><p>全名：<br>Low Level Virtual Machine  直译：底层虚拟机<br>/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/</p><p>  The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.<br>- 来自LLVM官网的介绍 <a href="http://llvm.org/" target="_blank" rel="noopener">LLVM官网</a></p><p>  LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。</p><p>  LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。<br> - 来自维基百科 <a href="https://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM on wiki</a></p><p>  简单来说</p><blockquote><p>LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。<br>编译器是Clang，GCC，ICC，VC++等。</p></blockquote><h4 id="Xcode和LLVM"><a href="#Xcode和LLVM" class="headerlink" title="Xcode和LLVM"></a>Xcode和LLVM</h4><blockquote><p>Xcode3之前，用的是GCC<br>Xcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器<br>Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留<br>Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能<br>Xcode4.6,LLVM升级到4.2版本<br>Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成</p></blockquote><h3 id="Clang-1"><a href="#Clang-1" class="headerlink" title="Clang"></a>Clang</h3><p>Clang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。<br>Clang项目包括Clang前端和Clang静态分析器等。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang on wiki</a></p><h3 id="GCC-1"><a href="#GCC-1" class="headerlink" title="GCC"></a>GCC</h3><p><a href="http://gcc.gnu.org/" target="_blank" rel="noopener">GCC官网</a><br>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。</p><p>原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。</p><p>许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p><p>GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC on wiki</a></p><h3 id="GNU-1"><a href="#GNU-1" class="headerlink" title="GNU"></a>GNU</h3><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">GNU官网</a><br>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。</p><p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/zh-cn/GNU" target="_blank" rel="noopener">GNU on wiki</a></p><h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><p>LLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。<br>尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。<br>LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。</p><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU Debugger 顾名思义<br>支持编程语言有C、C++、Pascal以及FORTRAN<br>在许多的类UNIX操作系统上都可以使用</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>lexical analysis /ˈlɛksɪkəl/<br>词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>syntactic analysis，也叫 parsing<br>/sɪnˈtæktɪk əˈnæləsəs/  /ˈpɑːzɪŋ/<br>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.</p><h3 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h3><p>parser<br>通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。</p><h3 id="源语言-amp-源程序"><a href="#源语言-amp-源程序" class="headerlink" title="源语言&amp;源程序"></a>源语言&amp;源程序</h3><p>Source language&amp;Source program<br>被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。</p><h3 id="目标语言-amp-目标程序"><a href="#目标语言-amp-目标程序" class="headerlink" title="目标语言&amp;目标程序"></a>目标语言&amp;目标程序</h3><p>Object language or Target language &amp; Object program or Target program<br>编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。</p><h3 id="中间语言（中间表示）"><a href="#中间语言（中间表示）" class="headerlink" title="中间语言（中间表示）"></a>中间语言（中间表示）</h3><p>Intermediate language（representation）<br>在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。</p><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>Grammars<br>/ˈgræməz/<br>文法是用于描述语言的语法结构的形式规则。</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。</p><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>abstract syntax tree或者缩写为AST<br>/ˈæbstrækt ˈsɪnˌtæks tri/<br>抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="CMD-B"><a href="#CMD-B" class="headerlink" title="CMD+B"></a>CMD+B</h3><p>Objective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。<br>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。<br>C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。</p><p>在使用Xcode按下cmd+B后，会经过以下流程：<br><img src="/2018/08/23/LLVM/02.png" title="Clang/LLVM 编译过程"><br><strong>预处理（Pre-process）</strong>：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。</p><p><strong>词法分析 （Lexical Analysis）</strong>：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。</p><p><strong>语法分析（Semantic Analysis）</strong>：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。</p><p><strong>静态分析（Static Analysis）</strong>：使用它来表示用于分析源代码以便自动发现错误。</p><p><strong>中间代码生成（Code Generation）</strong>：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</p><p><strong>优化（Optimize）</strong>：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p><p><strong>生成目标文件（Assemble）</strong>：生成Target相关Object(Mach-o) 。</p><p><strong>链接（Link）</strong>：生成 Executable 可执行文件。</p><p>关于此过程的详细测试，参考<a href="https://juejin.im/post/5a30ea0ff265da43094526f9" target="_blank" rel="noopener">掘金</a></p><h3 id="LLVM的具体操作"><a href="#LLVM的具体操作" class="headerlink" title="LLVM的具体操作"></a>LLVM的具体操作</h3><p>请参考<a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="noopener">关于LLVM，这些东西你必须知道！</a></p><blockquote><p>基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等<br>Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 <code>a+b</code> 改为 <code>a-(-b)</code><br>将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了<br>基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。</p></blockquote><p>所以基于LLVM可以完成：</p><ul><li>做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。</li><li>编写ClangPlugin，命名规范，代码规范，扩展功能。</li><li>编写Pass，代码混淆优化。</li></ul><h3 id="使用Clang进行开发"><a href="#使用Clang进行开发" class="headerlink" title="使用Clang进行开发"></a>使用Clang进行开发</h3><p>详细参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p><p>Clang的特性<br>相比于 GCC，Clang 具有如下优点：</p><ul><li>编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。</li><li>占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。</li><li>模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。</li><li>诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。</li><li>设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。</li></ul><p>当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强：</p><ul><li>支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。</li><li>支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。</li></ul><p>以下是目前GCC和Clang对C++支持的情况：<br><img src="/2018/08/23/LLVM/03.png" title="GCC Clang对C++支持对比"></p><p>更多参考<a href="https://zh.cppreference.com/w/cpp/compiler_support" target="_blank" rel="noopener">C++ 编译器支持情况表</a></p><h3 id="使用LLVM创建一个编译器"><a href="#使用LLVM创建一个编译器" class="headerlink" title="使用LLVM创建一个编译器"></a>使用LLVM创建一个编译器</h3><p>首先参考这篇文章来写一个helloworld<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/" target="_blank" rel="noopener">IBM developerWorks</a></p><p>关于LLVM IR的生成与创建<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm2/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编译相关" scheme="https://hadesxiye.github.io/categories/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="LLVM" scheme="https://hadesxiye.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="https://hadesxiye.github.io/tags/Clang/"/>
    
      <category term="GNU" scheme="https://hadesxiye.github.io/tags/GNU/"/>
    
      <category term="GCC" scheme="https://hadesxiye.github.io/tags/GCC/"/>
    
      <category term="Xcode" scheme="https://hadesxiye.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本的入门（一）</title>
    <link href="https://hadesxiye.github.io/2018/08/15/Shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hadesxiye.github.io/2018/08/15/Shell脚本的入门（一）/</id>
    <published>2018-08-15T10:48:08.000Z</published>
    <updated>2018-11-26T08:30:18.814Z</updated>
    
    <content type="html"><![CDATA[<p><center>Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。</center><br><a id="more"></a></p><h2 id="Simple-BB"><a href="#Simple-BB" class="headerlink" title="Simple BB"></a><strong>Simple BB</strong></h2><blockquote><p>为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路<br>首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。<br>获取目标资源的路径，根据A中的行数进行循环<code>find</code>查找，找到就用<code>cp</code>命令替换，未找到的重定向输出到临时文件B<br>最后打印B的内容，<code>remove</code>临时文件。<br>其中对文本的处理使用了<code>awk</code>命令</p></blockquote><p>脚本下载地址在我的github上 <a href="https://github.com/Hadesxiye/Shell_ReplaceSameNameFile" target="_blank" rel="noopener">资源替换脚本</a></p><hr><h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a><strong>Shell介绍</strong></h2><blockquote><p>Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。<br>而我使用shell只是因为<br>我用的mac - -</p></blockquote><hr><h2 id="Shell的工作原理"><a href="#Shell的工作原理" class="headerlink" title="Shell的工作原理"></a><strong>Shell的工作原理</strong></h2><blockquote><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p></blockquote><hr><h2 id="Shell的创建"><a href="#Shell的创建" class="headerlink" title="Shell的创建"></a><strong>Shell的创建</strong></h2><blockquote><p>1.打开文本编辑工具，输入一下内容<br><code>#!/bin/bashecho &quot;Hello World&quot;</code><br>2.保存为 <code>hello world.sh</code>在目录 A<br>3.在终端<code>cd</code>到目录 A<br>4.终端输入<code>chmod +x ./hello world.sh</code> （这一步是给脚本添加权限）<br>5.执行脚本   <code>./hello world.sh</code> 或者 直接把 <code>hello world.sh</code>拖入终端</p></blockquote><p>这很简单，无图。</p><hr><h2 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a><strong>Shell中的变量</strong></h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=<span class="string">"a1"</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=a1</span><br></pre></td></tr></table></figure><p>但是<br><code>example=a 1</code>  并不等同于 <code>example=&quot;a 1&quot;</code><br>因为<code>&quot; &quot;</code>（空格）在shell中用作指令的间隔<br><code>example=a 1</code> 其实只是将a负责给example 然后在输入了个1</p><blockquote><p>这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！</p></blockquote><h3 id="变量的访问"><a href="#变量的访问" class="headerlink" title="变量的访问"></a>变量的访问</h3><p>在变量前加上<code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$example</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a><strong>Shell中的四则运算</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> + <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> - <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> \* <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> / <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>乘法的时候需要进行转义<br><code>=</code> 赋值时，前后无空格<br>而运算符号前后必须有空格</p></blockquote><hr><h2 id="Shell中的其他运算符"><a href="#Shell中的其他运算符" class="headerlink" title="Shell中的其他运算符"></a><strong>Shell中的其他运算符</strong></h2><blockquote><p>=、==、!=、！、-o、-a</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-o 或</span><br><span class="line">-a 与</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><blockquote><p>-eq        两个数相等返回true<br>-ne          两个数不相等返回true<br>-gt            左侧数大于右侧数返回true<br>-It          左侧数小于右侧数返回true<br>-ge        左侧数大于等于右侧数返回true<br>-le            左侧数小于等于右侧数返回true</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><blockquote><p>=    两个字符串相等返回true<br>!=    两个字符串不相等返回true<br>-z    字符串长度为0返回true<br>-n    字符串长度不为0返回true<br>-d file    检测文件是否是目录，如果是，则返回 true<br>-r file    检测文件是否可读，如果是，则返回 true<br>-w file    检测文件是否可写，如果是，则返回 true<br>-x file    检测文件是否可执行，如果是，则返回 true<br>-s file    检测文件是否为空（文件大小是否大于0，不为空返回 true<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true</p></blockquote><hr><h2 id="Shell字符串操作"><a href="#Shell字符串操作" class="headerlink" title="Shell字符串操作"></a><strong>Shell字符串操作</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtext=<span class="string">"hello"</span>  <span class="comment">#定义字符串</span></span><br><span class="line">mtext2=<span class="string">"world"</span></span><br><span class="line">mtext3=<span class="variable">$mtext</span><span class="string">" "</span><span class="variable">$mtext2</span>  <span class="comment">#字符串的拼接</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$mtext3</span>  <span class="comment">#输出字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#mtext3&#125;</span>  <span class="comment">#输出字符串长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;mtext3:1:4&#125;</span>  <span class="comment">#截取字符串</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a><strong>Shell数组</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4 5)  <span class="comment">#定义数组</span></span><br><span class="line">array2=(aa bb cc dd ee)  <span class="comment">#定义数组</span></span><br><span class="line">value=<span class="variable">$&#123;array[3]&#125;</span>  <span class="comment">#找到某一个下标的数，然后赋值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$value</span>  <span class="comment">#打印</span></span><br><span class="line">value2=<span class="variable">$&#123;array2[3]&#125;</span>  <span class="comment">#找到某一个下标的数，然后赋值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$value2</span>  <span class="comment">#打印</span></span><br><span class="line">length=<span class="variable">$&#123;#array[* ]&#125;</span>  <span class="comment">#获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell输出"><a href="#Shell输出" class="headerlink" title="Shell输出"></a><strong>Shell输出</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell的判断"><a href="#Shell的判断" class="headerlink" title="Shell的判断"></a><strong>Shell的判断</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is equal to b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is greater than b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is less than b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"None of the condition met"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的test命令"><a href="#Shell中的test命令" class="headerlink" title="Shell中的test命令"></a><strong>Shell中的test命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">test</span> $[num1] -eq $[num2]  <span class="comment">#判断两个变量是否相等</span></span><br><span class="line">  <span class="built_in">test</span> num1=num2  <span class="comment">#判断两个数字是否相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-e file    文件存在则返回真</span><br><span class="line">-r file    文件存在并且可读则返回真</span><br><span class="line">-w file    文件存在并且可写则返回真</span><br><span class="line">-x file    文件存在并且可执行则返回真</span><br><span class="line">-s file    文件存在并且内容不为空则返回真</span><br><span class="line">-d file    文件目录存在则返回真</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的循环"><a href="#Shell中的循环" class="headerlink" title="Shell中的循环"></a><strong>Shell中的循环</strong></h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=10;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 5 6 7 8 9</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$HOME</span>/.bash*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$FILE</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNTER</span> -lt 5 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">COUNTER=`expr <span class="variable">$COUNTER</span> + 1`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$COUNTER</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'请输入。。。'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'ctrl + d 即可停止该程序'</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Yeah! great film the <span class="variable">$FILM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span>  <span class="comment">#跳出所有循环</span></span><br><span class="line"><span class="built_in">break</span> n  <span class="comment">#跳出第n层f循环</span></span><br><span class="line"><span class="built_in">continue</span>  <span class="comment">#跳出当前循环</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a><strong>Shell中的函数</strong></h2><blockquote><p>无参数无返回值</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">sysout</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sysout    </span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&gt; 无参数有返回值</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">  <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  aNum=3</span><br><span class="line">  anotherNum=5</span><br><span class="line">  <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">test</span></span><br><span class="line">  result=$?</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&gt; 有参数有返回值</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">  <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$1</span>  <span class="comment">#接收第一个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$2</span>  <span class="comment">#接收第二个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$3</span>  <span class="comment">#接收第三个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$#</span>  <span class="comment">#接收到参数的个数</span></span><br><span class="line">  <span class="built_in">echo</span> $*  <span class="comment">#接收到的所有参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span> aa bb cc</span><br></pre></td></tr></table></figure><h2 id="Shell中的重定向"><a href="#Shell中的重定向" class="headerlink" title="Shell中的重定向"></a><strong>Shell中的重定向</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> result &gt; file  <span class="comment">#将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写</span></span><br><span class="line"><span class="variable">$echo</span> result &gt;&gt; file  <span class="comment">#将结果写入文件，结果不会在控制台展示，而是在文件中，追加写</span></span><br><span class="line"><span class="built_in">echo</span> input &lt; file  <span class="comment">#获取输入流</span></span><br></pre></td></tr></table></figure><h2 id="Shell中的变量操作"><a href="#Shell中的变量操作" class="headerlink" title="Shell中的变量操作"></a><strong>Shell中的变量操作</strong></h2><blockquote><p>awk 指令<br>获取指定行数的资源名字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceNameTemp=$(awk <span class="string">'NR=="'</span><span class="variable">$i</span><span class="string">'" &#123;print;exit&#125;'</span> <span class="variable">$OutputFile</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取对应文件名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp=<span class="variable">$&#123;temp##*/&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>清空文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: &gt; <span class="string">"<span class="variable">$OutputFile</span>"</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a><strong>常用的Linux命令</strong></h2><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><blockquote><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p></blockquote><blockquote><p>基本结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span> file</span><br></pre></td></tr></table></figure></p></blockquote><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中</p><p> <strong>工作原理</strong></p><blockquote><p>第一步：执行BEGIN{ commands }语句块中的语句；<br>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。<br>第三步：当读至输入流末尾时，执行END{ commands }语句块。</p></blockquote><p><strong>BEGIN</strong>语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p><p><strong>END</strong>语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p><p><strong>pattern</strong>语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p><blockquote><p>获取指定行数的文本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'NR=="'</span><span class="variable">$i</span><span class="string">'" &#123;print;exit&#125;'</span> file</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取文件的行数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print NR&#125;'</span> <span class="string">"file"</span>|tail -n1</span><br></pre></td></tr></table></figure></p></blockquote><p>关于awk的详细用法请参考 <a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">awk命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="https://hadesxiye.github.io/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://hadesxiye.github.io/tags/Shell/"/>
    
      <category term="Linux" scheme="https://hadesxiye.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
