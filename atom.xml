<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fun&amp;Enjoy</title>
  
  <subtitle>this is Hades&#39;s blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hadesxiye.github.io/"/>
  <updated>2018-11-29T12:05:48.386Z</updated>
  <id>https://hadesxiye.github.io/</id>
  
  <author>
    <name>Hades</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 集合类型</title>
    <link href="https://hadesxiye.github.io/2018/10/08/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>https://hadesxiye.github.io/2018/10/08/Swift集合类型/</id>
    <published>2018-10-08T11:59:57.000Z</published>
    <updated>2018-11-29T12:05:48.386Z</updated>
    
    <content type="html"><![CDATA[<p><center><br>Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。<br>数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</center><br><a id="more"></a></p><div class="note warning"><p>注意<br>Swift 的 Arrays、Sets 和 Dictionaries 类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章节。</p></div><h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>如果创建一个 Arrays、Sets 或 Dictionaries 并且把它分配成一个变量，这个集合将会是可变的。这意味着你可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 Arrays、Sets 或 Dictionaries 分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。</p><div class="note warning"><p>注意<br>在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。</p></div><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p><div class="note warning"><p>注意<br>Swift 的 Array 类型被桥接到 Foundation 中的 NSArray 类。</p></div><h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInts is of type [Int] with <span class="subst">\(someInts.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "someInts is of type [Int] with 0 items."</span></span><br></pre></td></tr></table></figure></p><h3 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h3><p>Swift 中的 <code>Array</code> 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（ <code>count</code>）和适当类型的初始值（ <code>repeating</code>）传入数组构造函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles = <span class="type">Array</span>(repeating: <span class="number">0.0</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure></p><h3 id="通过两个数组相加创建一个数组"><a href="#通过两个数组相加创建一个数组" class="headerlink" title="通过两个数组相加创建一个数组"></a>通过两个数组相加创建一个数组</h3><p>我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles = <span class="type">Array</span>(repeating: <span class="number">2.5</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure></p><h3 id="用数组字面量构造数组"><a href="#用数组字面量构造数组" class="headerlink" title="用数组字面量构造数组"></a>用数组字面量构造数组</h3><p>我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[value <span class="number">1</span>, value <span class="number">2</span>, value <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h3 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h3><p>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。</p><p>可以使用数组的只读属性 <code>count</code> 来获取数组中的数据项数量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The shopping list contains <span class="subst">\(shoppingList.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 输出 "The shopping list contains 2 items."（这个数组有2个项）</span></span><br></pre></td></tr></table></figure></p><p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为   <code>0</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The shopping list is not empty."（shoppinglist 不是空的）</span></span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>append(_:)</code> 方法在数组后面添加新的数据项：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有3个数据项，有人在摊煎饼</span></span><br></pre></td></tr></table></figure></p><p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shoppingList += [<span class="string">"Baking Powder"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有四项了</span></span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有七项了</span></span><br></pre></td></tr></table></figure></p><p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstItem = shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第一项是 "Eggs"</span></span><br></pre></td></tr></table></figure></p><p>您也可以使用下标语法来同时更改一系列值，即使替换值集的长度与所替换的范围不同。下面的例子用 <code>Bananas</code> 和 <code>Apples</code> 取代了<code>Chocolate Spread</code>，<code>Cheese</code> 和 <code>Butter</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span>...<span class="number">6</span>] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有6项</span></span><br></pre></td></tr></table></figure></p><p>调用数组的  <code>insert(_:at:)</code> 方法来在某个具体索引值之前添加数据项：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有7项</span></span><br><span class="line"><span class="comment">// "Maple Syrup" 现在是这个列表中的第一项</span></span><br></pre></td></tr></table></figure></p><p>类似的我们可以使用 <code>remove(at:)</code> 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup = shoppingList.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 索引值为0的数据项被移除</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有6项，而且不包括 Maple Syrup</span></span><br><span class="line"><span class="comment">// mapleSyrup 常量的值等于被移除数据项的值 "Maple Syrup"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的 <code>count</code> 属性进行比较来在使用某个索引之前先检验是否有效。除了当 <code>count</code> 等于 <code>0</code> 时（说明这是个空数组），最大索引值一直是 <code>count -1</code> ，因为数组都是零起索引。</p></div><p>如果我们只想把数组中的最后一项移除，可以使用 <code>removeLast()</code> 方法而不是 <code>remove(at:)</code> 方法来避免我们需要获取数组的 <code>count</code> 属性。就像后者一样，前者也会返回被移除的数据项，类似于<code>remove(at:)</code>方法,<code>removeLast()</code>返回被删除的项。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = shoppingList.removeLast()</span><br><span class="line"><span class="comment">// 数组的最后一项被移除了</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有5项，不包括 Apples</span></span><br><span class="line"><span class="comment">// apples 常量的值现在等于 "Apples" 字符串</span></span><br></pre></td></tr></table></figure></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>我们可以使用 <code>for-in</code> 循环来遍历所有数组中的数据项：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们同时需要每个数据项的值和索引值，可以使用 <code>enumerated()</code> 方法来进行数组遍历。 <code>enumerated()</code> 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item <span class="subst">\(index + <span class="number">1</span>)</span>: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure></p><h2 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h2><p>集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p><div class="note warning"><p>注意<br>Swift 的 Set 类型被桥接到 Foundation’s  中的 NSSet 类。<br>关于使用 Foundation 和 Cocoa 中 Set的知识，参见<a href="https://developer.apple.com/documentation/swift/set#2845530" target="_blank" rel="noopener">Bridging Between Set and NSSet</a>。</p></div><h3 id="集合类型的哈希值"><a href="#集合类型的哈希值" class="headerlink" title="集合类型的哈希值"></a>集合类型的哈希值</h3><p>一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如  <code>a == b</code> ,因此必须 <code>a.hashValue == b.hashValue</code>。</p><p>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code> ）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值（在枚举有讲述）默认也是可哈希化的。(<a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html" target="_blank" rel="noopener">https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html</a>)</p><div class="note warning"><p>注意<br>你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 <code>Hashable</code> 协议。符合 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的可读属性  <code>Hashable</code> 。由类型的 <code>Hashable</code> 属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。<br><br>因为 <code>Hashable</code> 协议符合 <code>Equatable</code> 协议，所以遵循该协议的类型也必须提供一个是否相等运算符（<code>==</code>）的实现。这个 Equatable 协议要求任何符合 <code>==</code> 实现的实例间都是一种相等的关系。也就是说，对于 <code>a</code>, <code>b</code>,  <code>c</code>三个值来说，<code>==</code> 的实现必须满足下面三种情况：<br><br><code>a == a</code> (自反性)<br><code>a == b</code> 意味着 <code>b == a</code> (对称性)<br><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> (传递性)<br></p></div><h3 id="集合类型语法"><a href="#集合类型语法" class="headerlink" title="集合类型语法"></a>集合类型语法</h3><p>Swift 中的 <code>Set</code> 类型被写为  <code>Set&lt;Element&gt;</code> ，这里的 <code>Element</code> 表示 Set 中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</p><h4 id="创建和构造一个空的集合"><a href="#创建和构造一个空的集合" class="headerlink" title="创建和构造一个空的集合"></a>创建和构造一个空的集合</h4><p>你可以通过构造器语法创建一个特定类型的空集合：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "letters is of type Set&lt;Character&gt; with 0 items."</span></span><br></pre></td></tr></table></figure></p><p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的 <code>Set</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">// letters 现在含有1个 Character 类型的值</span></span><br><span class="line">letters = []</span><br><span class="line"><span class="comment">// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</span></span><br></pre></td></tr></table></figure></p><h4 id="用数组字面量创建集合"><a href="#用数组字面量创建集合" class="headerlink" title="用数组字面量创建集合"></a>用数组字面量创建集合</h4><p>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p><p>下面的例子创建一个称之为 <code>FavoriteGenres</code>  的集合来存储  <code>String</code> 类型的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"><span class="comment">// favoriteGenres 被构造成含有三个初始值的集合</span></span><br></pre></td></tr></table></figure></p><p>由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个 <code>Set</code> 并且该数组字面量中的所有元素类型相同，那么你无须写出 <code>Set</code> 的具体类型。 <code>FavoriteGenres</code> 的构造形式可以采用简化的方式代替：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure></p><h4 id="访问和修改一个集合"><a href="#访问和修改一个集合" class="headerlink" title="访问和修改一个集合"></a>访问和修改一个集合</h4><p>你可以通过 <code>Set</code> 的属性和方法来访问和修改一个 <code>Set</code>。</p><ul><li>为了找出一个 <code>Set</code> 中元素的数量，可以使用其只读属性 <code>count</code> </li><li>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为 0</li><li>你可以通过调用 <code>Set</code> 的 <code>insert(_:)</code> 方法来添加一个新元素</li><li>你可以通过调用 <code>Set</code> 的 <code>remove(_:)</code> 方法去删除一个元素，如果该值是该 Set 的一个元素则删除该元素并且返回被删除的元素值，否则如果该 Set 不包含该值，则返回 <code>nil</code> 。另外，<code>Set</code> 中的所有元素可以通过它的  <code>removeAll()</code>  方法删除。</li><li>使用  <code>contains(_:)</code>  方法去检查 Set 中是否包含一个特定的值</li></ul><h4 id="遍历一个集合"><a href="#遍历一个集合" class="headerlink" title="遍历一个集合"></a>遍历一个集合</h4><p>你可以在一个 <code>for-in</code> 循环中遍历一个 Set 中的所有值。</p><p>Swift 的 <code>Set</code> 类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code>  中的值可以使用 <code>sorted()</code> 方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符<code>&lt;</code>对元素进行比较的结果来确定。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>你可以高效地完成 Set 的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p><h4 id="基本集合操作"><a href="#基本集合操作" class="headerlink" title="基本集合操作"></a>基本集合操作</h4><p>下面的插图描述了两个集合<code>a</code>和<code>b</code>以及通过阴影部分的区域显示集合各种操作的结果。</p><img src="/2018/10/08/Swift集合类型/set_01.png"><ul><li>使用 <code>intersection(_:)</code> 方法根据两个集合中都包含的值创建的一个新的集合。</li><li>使用 <code>symmetricDifference(_:)</code>  方法根据在一个集合中但不在两个集合中的值创建一个新的集合。</li><li>使用 <code>union(_:)</code>  方法根据两个集合的值创建一个新的集合。</li><li>使用 <code>subtracting(_:)</code> 方法根据不在该集合中的值创建一个新的集合。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).sorted()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="集合成员关系和相等"><a href="#集合成员关系和相等" class="headerlink" title="集合成员关系和相等"></a>集合成员关系和相等</h4><p>下面的插图描述了三个集合 <code>a</code> 、 <code>b</code> 和 <code>c</code> ,以及通过重叠区域表述集合间共享的元素。集合 <code>a</code> 是集合 <code>b</code> 的父集合，因为 <code>a</code> 包含了 <code>b</code> 中所有的元素，相反的，集合 <code>b</code> 是集合 <code>a</code> 的子集合，因为属于 <code>b</code> 的元素也被 <code>a</code> 包含。集合 <code>b</code> 和集合 <code>c</code> 彼此不关联，因为它们之间没有共同的元素。</p><img src="/2018/10/08/Swift集合类型/set_02.png"><ul><li>使用是否相等运算符（<code>==</code>）来判断两个集合是否包含全部相同的值。</li><li>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的值是否也被包含在另外一个集合中。</li><li>使用 <code>isSuperset(of:)</code> 方法来判断一个集合中包含另一个集合中所有的值。</li><li>使用 <code>isStrictSubset(of:)</code> 或 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li><li>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"🐮"</span>, <span class="string">"🐔"</span>, <span class="string">"🐑"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="string">"🐦"</span>, <span class="string">"🐭"</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubset(of: farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSuperset(of: houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjoint(with: cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p><div class="note warning"><p>注意<br>Swift 的 Dictionary 类型被桥接到 Foundation 的 NSDictionary 类。<br><br>更多关于在 Foundation 和 Cocoa 中使用 Dictionary 类型的信息，请参阅 Bridging Between Dictionary and NSDictionary.</p></div><h3 id="字典类型简化语法"><a href="#字典类型简化语法" class="headerlink" title="字典类型简化语法"></a>字典类型简化语法</h3><p>Swift 的字典使用 <code>Dictionary&lt;Key, Value&gt;</code> 定义，其中 <code>Key</code> 是字典中键的数据类型， <code>Value</code> 是字典中对应于这些键所存储值的数据类型。</p><div class="note warning"><p>注意<br>一个字典的 Key 类型必须遵循 Hashable 协议，就像 Set 的值类型。</p></div><p>我们也可以用 <code>[Key: Value]</code> 这样简化的形式去创建一个字典类型。并且这也是我们的首选方式。</p><h3 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h3><p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span></span><br></pre></td></tr></table></figure></p><p>如果<strong>上下文</strong>已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作  <code>[:]</code> （中括号中放一个冒号）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namesOfIntegers[<span class="number">16</span>] = <span class="string">"sixteen"</span></span><br><span class="line"><span class="comment">// namesOfIntegers 现在包含 1 个键值对</span></span><br><span class="line">namesOfIntegers = [:]</span><br><span class="line"><span class="comment">// namesOfIntegers 又是一个空的 [Int: String] 类型字典</span></span><br></pre></td></tr></table></figure></p><h3 id="用字典字面量创建字典"><a href="#用字典字面量创建字典" class="headerlink" title="用字典字面量创建字典"></a>用字典字面量创建字典</h3><p>一个键值对是一个 <code>key</code> 和一个 <code>value</code> 的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key <span class="number">1</span>: value <span class="number">1</span>, key <span class="number">2</span>: value <span class="number">2</span>, key <span class="number">3</span>: value <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h3 id="访问和修改字典"><a href="#访问和修改字典" class="headerlink" title="访问和修改字典"></a>访问和修改字典</h3><p>我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p><ul><li>和数组一样，我们可以通过字典的只读属性 <code>count</code> 来获取某个字典的数据项数量</li><li>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为  <code>0</code> </li></ul><p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London"</span></span><br><span class="line"><span class="comment">// airports 字典现在包含 3 个元素</span></span><br></pre></td></tr></table></figure></p><p>还可以使用下标语法来更改特定键相关联的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London Heathrow"</span></span><br><span class="line"><span class="comment">// LHR 应的值被改为 "London Heathrow"</span></span><br></pre></td></tr></table></figure></p><p>作为另一种下标方法，字典的 <code>updateValue(_:forKey:)</code> 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例， <code>updateValue(_:forKey:)</code> 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的， <code>updateValue(_:forKey:)</code> 这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p><p> <code>updateValue(_:forKey:)</code> 方法会返回对应值的类型的可选值。举例来说：对于存储 <code>String</code> 值的字典，这个函数会返回一个 <code>String</code> 或者可选 <code>String</code> 类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 <code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = airports.updateValue(<span class="string">"Dublin Airport"</span>, forKey: <span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The old value for DUB was Dublin."</span></span><br></pre></td></tr></table></figure></p><p>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回 <code>nil</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName = airports[<span class="string">"DUB"</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name of the airport is <span class="subst">\(airportName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"That airport is not in the airports dictionary."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The name of the airport is Dublin Airport."</span></span><br></pre></td></tr></table></figure></p><p>我们还可以使用下标语法来通过给某个键的对应值赋值为 <code>nil</code> 来从字典里移除一个键值对：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"APL"</span>] = <span class="string">"Apple International"</span></span><br><span class="line"><span class="comment">//"Apple Internation" 不是真的 APL 机场，删除它</span></span><br><span class="line">airports[<span class="string">"APL"</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL 现在被移除了</span></span><br></pre></td></tr></table></figure></p><p>此外， <code>removeValue(forKey:)</code> 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回 <code>nil</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = airports.removeValue(forKey: <span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The removed airport's name is <span class="subst">\(removedValue)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value for DUB."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The removed airport's name is Dublin Airport."</span></span><br></pre></td></tr></table></figure></p><h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><p>我们可以使用 <code>for-in</code> 循环来遍历某个字典中的键值对。每一个字典中的数据项都以 <code>(key, value)</code> 元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br></pre></td></tr></table></figure></p><p>通过访问 <code>keys</code> 或者 <code>values</code> 属性，我们也可以遍历字典的键或者值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport code: <span class="subst">\(airportCode)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport name: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br></pre></td></tr></table></figure></p><p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受  <code>Array</code> 实例的 API 的参数，可以直接使用 <code>keys</code> 或者 <code>values</code> 属性构造一个新数组：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes = [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes 是 ["YYZ", "LHR"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames = [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames 是 ["Toronto Pearson", "London Heathrow"]</span></span><br></pre></td></tr></table></figure></p><p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 <code>keys</code> 或 <code>values</code> 属性使用 <code>sorted()</code> 方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;br&gt;Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。&lt;br&gt;数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 字符串和字符</title>
    <link href="https://hadesxiye.github.io/2018/10/07/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://hadesxiye.github.io/2018/10/07/Swift字符串/</id>
    <published>2018-10-07T01:31:16.000Z</published>
    <updated>2018-11-29T01:47:48.131Z</updated>
    
    <content type="html"><![CDATA[<p><center>Swift中的字符串都是String类型的，字符是Character类型，看似简单，其中的细节可不少(•́ω•̀ ٥)</center><br><a id="more"></a></p><p> Swift 字符串是由 <code>String</code> 类型来表示。 <code>String</code> 的内容可以用多种方式读取，包括作为一个 <code>Character</code> 值的集合。</p><div class="note warning"><p>注意<br>Swift 的字符串类型与 Foundation 的 <code>NSString</code> 类型进行了无缝桥接。 Foundation 也可以对 <code>String</code> 进行扩展，暴露在 <code>NSString</code> 中定义的方法。 这就意味着，你可以不用进行类型转换，就能在 <code>String</code> 中调用 <code>NSString</code> 的这些方法。<br>更多关于在 Foundation 和 Cocoa 中使用 <code>String</code> 的信息，查看  <a href="https://developer.apple.com/documentation/swift/string#2919514" target="_blank" rel="noopener">Bridging Between String and NSString</a> 。</p></div><h2 id="初始化一个空字符串"><a href="#初始化一个空字符串" class="headerlink" title="初始化一个空字符串"></a>初始化一个空字符串</h2><p>创建一个空 <code>String</code> 有两种方式，给一个变量赋值一个空字符串或者使用下面的语法初始化一个 <code>String</code> 实例对象：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span>               <span class="comment">// 空字符串</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()  <span class="comment">// 初始化语法</span></span><br><span class="line"><span class="comment">//这是两个空字符串，他们等价</span></span><br></pre></td></tr></table></figure></p><p>可以通过检查 <code>String</code> 的布尔类型的属性 <code>isEmpty</code> 来判断该字符串的值是否为空：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Nothing to see here"</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h2><p>Swift 中的 <code>String</code>  类型是一种 <code>值类型</code> 。如果你创建了一个新的 <code>String</code> 值， <code>String</code> 值在传递给方法或者函数时会被 拷贝，在给常量或者变量赋值的时候也是一样。在任何情况下，都会对现存的 <code>String</code> 值创建新拷贝，并对新拷贝进行传递或赋值操作。值类型在 结构体和枚举是值类型 中有详细描述。</p><p>Swift 默认 <code>String</code> 拷贝的行为是为了保证在函数或方法中传递的是 <code>String</code> 值，不管该值是从哪里来，你都绝对拥有这个 String  值。你可以确定你传递的这个字符串不会被修改，除非你自己去修改它。</p><p>另一方面，Swift 编译器优化了字符串的使用，实际拷贝只会在需要的时候才进行。这意味着你把字符串当做值类型的同时也能够得到很棒的性能。</p><h2 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h2><p>你可以使用 <code>for-in</code> 循环来遍历 <code>String</code> 中每个的 <code>Character</code> 的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用 <code>Character</code> 类型声明，并赋值一个单字符值创建一个独立的字符常量或变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure></p><p><code>String</code> 的值可以使用一个 <code>Character</code> 值类型的数组作为变量来进行初始化：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>, <span class="string">"!"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// 输出 "Cat!🐱"</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串和字符的拼接"><a href="#字符串和字符的拼接" class="headerlink" title="字符串和字符的拼接"></a>字符串和字符的拼接</h2><p>可以使用加号（ <code>+</code> ）将 <code>String</code> 的值加（或 拼接 ）在一起创造出一个新的值</p><p>你可以使用加等于赋值符号（ <code>+=</code> ）将一个 <code>String</code> 的值追加到一个已经存在的 <code>String</code> 变量中</p><p>你可以使用 <code>String</code> 的 <code>append()</code> 方法将一个 <code>Character</code> 的值追加到一个 <code>String</code> 变量中</p><div class="note warning"><p>注意<br>你不能将字符串 <code>String</code> 或字符 <code>Character</code> 拼接到 <code>Character</code> 变量中，因为 Character 的值只能包含单个字符。<br></p></div><h2 id="字符计数"><a href="#字符计数" class="headerlink" title="字符计数"></a>字符计数</h2><p>在一个字符串中使用 count 属性去计算 Character 类型值个数</p><p>注意，Swift 对 Character 类型值使用了拓展字母集，意味着字符串的拼接和修改不一定会持续影响字符串字符个数。</p><p>例如，你初始化一个拥有四个字符的字符串 <code>cafe</code>，然后再追加一个 <code>COMBINING ACUTE ACCENT</code> (<code>U+0301</code>) 字符在末尾 ，最终形成的字符串还是拥有四个字符，并且最后一个字符是 <code>é</code>，而不是 <code>e</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "the number of characters in cafe is 4"</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span>    <span class="comment">// 拼接重音符，U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "the number of characters in café is 4"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>拓展字母集可以由多个不同的 Unicode 标量组成，这就意味着相同字符和相同字符的不同表示需要占据不同的内存空间去存储，因此，在字符串的各种表示中 Swift 字符占据的内存并不一样。造成的结果就是，字符串的字符数量并不能通过遍历该字符串去计算，并用于确定该字符串的拓展字符集边界。如果你正在处理特别长的字符串，要意识到为了确定该字符串的字符个数， <code>count</code> 属性必须要遍历完整个字符串中的全部 Unicode 标量。<br><br> <code>count</code> 属性返回的字符个数不会一直都与包含相同字符的 <code>NSString</code> 的 <code>length</code> 属性返回的字符个数相同。 <code>NSString</code> 的长度是基于 UTF-16 表示的字符串所占据的 16 位代码单元的个数决定，而不是字符串中的拓展字母集个数决定。<br></p></div><h2 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h2><p>你可以通过字符串的方法和属性来访问和修改它，或者通过下标语法。</p><h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>每个 <code>String</code> 值都有一个关联的 索引类型， <code>String.Index</code>，对应着字符串中每个 <code>Character</code> 的位置。</p><p>正如上面提到的，不同的字符可能需要不同大小的内存存储，所以为了确定每个 <code>Character</code> 的具体位置，你必须从 <code>String</code> 的开头遍历每个 <code>Unicode</code> 标量到结束。因此，Swift 字符串不能使用整型值索引。</p><p>使用 <code>startIndex</code> 属性可以访问 <code>String</code> 的第一个 <code>Character</code> 的位置。使用 <code>endIndex</code> 属性可以访问 <code>String</code> 的最后一个 <code>Character</code> 的位置。因此， <code>endIndex</code> 属性并不是字符串下标的有效参数。如果 <code>String</code> 是空串， <code>startIndex</code> 和 <code>endIndex</code> 就是相等的。</p><p>你可以通过使用 <code>String</code> 的 <code>index(before:)</code> 和 <code>index(after:)</code> 方法，访问给定索引的前一个和后一个索引。要访问离给定索引偏移较多的索引，你可以使用 <code>index(_:offsetBy:)</code> 方法，避免多次调用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法。</p><p>使用 <code>indices</code> 属性会创建一个包含全部索引的范围，用来在一个字符串中访问单个字符。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.<span class="built_in">indices</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(greeting[index])</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "G u t e n   T a g ! "</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>你可以在任意一个遵循  <code>Collection</code> 协议的类型里面，使用 <code>startIndex</code> 和 <code>endIndex</code> 属性或者 <code>index(before:)</code> ， <code>index(after:)</code> 和 <code>index(_:offsetBy:)</code> 方法。如上文所示是使用在  <code>String</code> 中，你也可以使用在 <code>Array</code> 、<code>Dictionary</code> 和 <code>Set</code> 中。</p></div><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>在一个字符串指定位置插入单个字符，使用 <code>insert(:at:)</code> 方法，而要插入另一个字符串的内容时，使用 <code>insert(contentsOf:at:)</code> 方法。</p><p>删除一个字符串指定位置的单个字符，用 <code>remove(at:)</code> 方法，而要删除指定范围的子字符串时，用 <code>removeSubrange(_:)</code></p><div class="note warning"><p>注意<br>你可以在任何遵循 RangeReplaceableCollection 协议的类型上使用  <code>insert(_:at:)</code>， <code>insert(contentsOf:at:)</code>，<code>remove(at:)</code>，和 <code>removeSubrange(_:)</code> 方法。除了这里说到的 <code>String</code>，还包括 <code>Array</code>，<code>Dictionary</code>，和  <code>Set</code> 等集合类型。</p></div><h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>当你从字符串中获取一个子字符串 —— 例如使用下标或者  <code>prefix(_:)</code> 之类的方法 —— 就可以得到一个 <code>Substring</code> 的 实例 ，而非另外一个 <code>String</code> 。Swift 里的 <code>Substring</code> 的绝大部分函数都跟 <code>String</code> 一样，意味着你可以使用同样的方式去操作 <code>Substring</code> 和 <code>String</code> 。然而，跟  <code>String</code> 不同的是，你只有在短时间内需要操作字符串时，才会使用 <code>Substring</code> 。当你需要长时间保存结果时，就把 <code>Substring</code> 转化为 <code>String</code> 的实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.firstIndex(of: <span class="string">","</span>) ?? greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning = greeting[..&lt;index]</span><br><span class="line"><span class="comment">// beginning 的值是 "Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把结果转化为 String 以便长期存储。</span></span><br><span class="line"><span class="keyword">let</span> newString = <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure></p><p>就像 <code>String</code> ，每一个 <code>Substring</code> 都会在内存里保存字符集。而 <code>String</code> 和 <code>SubString</code> 的区别在于性能优化上，<code>Substring</code> 可以重用原 <code>String</code> 的内存空间，或者另一个 <code>Substring</code> 的内存空间（<code>String</code> 也有同样的优化，但如果两个 <code>String</code> 共享内存的话，它们就会相等）。这一优化意味着你在修改 <code>String</code> 和 <code>Substring</code> 之前都不需要消耗性能在内存复制。就像前面说的那样，<code>Substring</code> 不适合长期存储 —— 因为它重用了原 <code>String</code> 的内存空间，原 <code>String</code> 的内存空间必须保留直到它的 <code>Substring</code> 不再被使用为止。</p><p>上面的例子， <code>greeting</code> 是一个 <code>String</code>，意味着它在内存里有一片空间保存字符集。而由于 <code>beginning</code> 是 <code>greeting</code> 的 <code>Substring</code>，它重用了  <code>greeting</code> 的内存空间。相反，<code>newString</code> 是一个 <code>String</code> —— 它是使用 <code>Substring</code> 创建的，拥有一片自己的内存空间。下面的图展示了他们之间的关系：<br><img src="/2018/10/07/Swift字符串/swift_string.png"></p><div class="note warning"><p>注意<br> <code>String</code> 和 <code>Substring</code> 都遵循  <code>StringProtocol</code>协议，  这意味着操作字符串的函数使用 <code>StringProtocol</code> 会更加方便。你可以传入 <code>String</code> 或 <code>Substring</code> 去调用函数。<br></p></div><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>Swift 提供了三种方式来比较文本值: 字符串和字符相等、前缀相等、后缀相等。</p><h3 id="字符串和字符相等"><a href="#字符串和字符相等" class="headerlink" title="字符串和字符相等"></a>字符串和字符相等</h3><p>如果他们的扩展字形集是 统一码等价，则这两个 <code>String</code> 值 (或者两个 <code>Character</code> 值) 被认为是等同的。如果它们具有相同的语言含义和外观，即使它们是由不同语义的 Unicode 标量组成，扩展字形集也是等同的。</p><p>例如，<code>LATIN SMALL LETTER E WITH ACUTE</code> (<code>U+00E9</code>) 在规范上等同于 <code>LATIN SMALL LETTER E</code> (<code>U+0065</code>) 加上 <code>COMBINING ACUTE ACCENT</code> (<code>U+0301</code>)。这两个扩展字形簇都是表示字符 <code>é</code> 的有效方法，因此它们被认为是规范等价的</p><p>相反，英文中的 <code>LATIN CAPITAL LETTER A</code> (<code>U+0041</code>，或 <code>「A」</code>)，和俄文中的 <code>CYRILLIC CAPITAL LETTER A</code> (<code>U+0410</code>, 或 <code>「А」</code>) 不相等。这两个字符在视觉上相似，但具有不同的语言含义</p><div class="note warning"><p>注意<br>Swift 中的字符串和字符比较不是区域敏感的。</p></div><h3 id="前缀和后缀比较"><a href="#前缀和后缀比较" class="headerlink" title="前缀和后缀比较"></a>前缀和后缀比较</h3><p>可以使用字符串的 <code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 方法来检查一个字符串是否有特定的前缀、后缀。这两个方法接收一个 <code>String</code> 类型的参数返回一个布尔值。</p><div class="note warning"><p>注意<br> <code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 方法都是在每个字符串的扩展字符集中逐个字符进行比较， 如本文所述  字符串和字符的比较。</p></div><h2 id="字符串的-Unicode-表示形式"><a href="#字符串的-Unicode-表示形式" class="headerlink" title="字符串的 Unicode 表示形式"></a>字符串的 <code>Unicode</code> 表示形式</h2><p>当一个 <code>Unicode</code> 字符串被写入文本文件或者一些其他存储时，字符串中的 <code>Unicode</code> 标量会用 <code>Unicode</code> 定义的几种 <code>编码格式</code> 编码。每一个字符串中的小块编码都叫做 <code>代码单元</code>。这些包括 <code>UTF-8</code> 编码格式 (编码字符串为 8 位的代码单元），<code>UTF-16</code> 编码格式 (编码字符串为16位的代码单元) ， 以及 <code>UTF-32</code> 编码格式 (编码字符串32位的代码单元) 。</p><p>Swift 提供几种不同的方式来访问字符串的 <code>Unicode</code> 表现形式。 你可以使用 <code>for - in</code> 对字符串进行便利， 进而访问其中单个 <code>Character</code> 字符值作为 <code>Unicode</code> 扩展的字符群集。 这个过程描述在 使用字符。</p><p>另外，也可以通过其他三种 <code>Unicode</code> 兼容的方式访问字符串的值：</p><ul><li>UTF-8 代码单元集合（利用字符串的 <code>utf8</code> 属性进行访问）</li><li>UTF-16 代码单元集合 （利用字符串的 <code>utf16</code> 属性进行访问）</li><li>21 位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式（利用字符串的 <code>unicodeScalars</code> 属性进行访问）<br>下面有 <code>D</code> ，<code>o</code> ，<code>g</code> , <code>!!</code> （<code>DOUBLE EXCLAMATION MARK</code> ，或Unicode 标量 <code>U+203C</code> ）和 <code>🐶</code>（<code>DOG FACE</code>，Unicode 标量为 <code>U+1F436</code>）组成的字符串中的每一个字符代表着一种不同的表示：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="UTF-8-表示形式"><a href="#UTF-8-表示形式" class="headerlink" title="UTF-8 表示形式"></a>UTF-8 表示形式</h3><p>你可以通过遍历 <code>String</code> 的 <code>utf8</code> 属性来访问他的 UTF-8 表示。这个属性是 <code>string.UTF8View</code> 类型的，<code>UTF8View</code> 是无符号 8 位（ <code>UInt8</code> ）值得集合，每一个字节都对应一个字符串的 UTF-8 的表现形式：<br><img src="/2018/10/07/Swift字符串/swift_string_utf8.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 打印 "68 111 103 226 128 188 240 159 144 182 "</span></span><br></pre></td></tr></table></figure><p>上面的例子中，前三个 10 进制 <code>codeUnit</code> 值（<code>68</code>，<code>111</code>，<code>103</code>）代表了字符 <code>D</code> <code>o</code> 和 <code>g</code> ，他们的 UTF-8 表示和 ASCII 表示相同。接下来的三个 10 进制 <code>codeUnit</code> 值（<code>226</code>，<code>128</code>, <code>188</code>）是 <code>DOUBLE EXCLAMATION MARK</code> 的 3 字节 UTF-8 表示形式。 最后四个 <code>codeUnit</code> 值 (<code>240</code>, <code>159</code>, <code>144</code>, <code>182</code>) 是 <code>DOG FACE</code> 的 4 字节 UTF-8 表示形式。</p><h3 id="UTF-16-表示形式"><a href="#UTF-16-表示形式" class="headerlink" title="UTF-16 表示形式"></a>UTF-16 表示形式</h3><p>你可以通过遍历 <code>String</code> 的 <code>utf16</code> 属性来访问它的 <code>UTF-16</code> 表示形式。它是 <code>String.UTF16View</code> 类型的属性, 它是一个无符号 16 位 (<code>UInt16</code>) 值的集合，每一个 <code>UInt16</code> 都是一个字符的 UTF-16 表示形式:<br><img src="/2018/10/07/Swift字符串/swift_string_utf8.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 打印 "68 111 103 8252 55357 56374 "</span></span><br></pre></td></tr></table></figure><p>同样，前三个 <code>codeUnit</code> 值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符 <code>D</code>, <code>o</code>, 和 <code>g</code>, 他们的 UTF-16 代码单元和 UTF-8 完全相同 (因为这些 Unicode 标量表示 ASCII 字符)。</p><p>第四个 <code>codeUnit</code> 值 (<code>8252</code>) 是一个等于十六进制 <code>203C</code> 的十进制值，<br>这代表了 <code>DOUBLE EXCLAMATION MARK</code> 字符的 Unicode 标量值 <code>U+203C</code> 。这个字符在 UTF-16 中可以用一个代码单元表示。</p><p>第五个和第六个 <code>codeUnit</code> 值 (<code>55357</code> 和 <code>56374</code>) 是 <code>DOG FACE</code> 字符的 UTF-16 表示形式。 第一个值为 <code>U+D83D</code> (十进制值为 <code>55357</code> ) 第二个值为 <code>U+DC36</code> (十进制值为 <code>56374</code> )。</p><h3 id="Unicode-标量表示形式"><a href="#Unicode-标量表示形式" class="headerlink" title="Unicode 标量表示形式"></a>Unicode 标量表示形式</h3><p>你可以通过遍历 <code>String</code> 值的 <code>unicodeScalars</code> 属性来访问它的 <code>Unicode</code> 标量表示。 它是一个 <code>UnicodeScalarView</code> 类型的属性, <code>UnicodeScalarView</code> 是 <code>UnicodeScalar</code> 类型的值得集合。</p><p>每一个 <code>UnicodeScalar</code>都有一个 <code>value</code>属性，可以返回对应的 21 位数值，用 <code>UInt32</code> 值来表示:<br><img src="/2018/10/07/Swift字符串/swift_string_unicode.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar.value)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 打印 "68 111 103 8252 128054 "</span></span><br></pre></td></tr></table></figure><p>前三个 <code>UnicodeScalar</code> 值 (<code>68</code>, <code>111</code>, <code>103</code>) 的 <code>Value</code> 属性依旧代表着字符 <code>D</code>, <code>o</code>, and <code>g</code>。</p><p>第四个 <code>codeUnit</code> 值 (<code>8252</code>) 依旧是一个等于十六进制 <code>203C</code> 的十进制值, 这代表了 <code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量 <code>U+203C</code>。</p><p>第五个 <code>UnicodeScalar</code> 值的 <code>Value</code> 属性, <code>128054</code>, 是一个十六进制 <code>1F436</code> 的十进制表现, 它代表 <code>DOG FACE</code> 字符的 Unicode 标量 <code>U+1F436</code>。</p><p>作为查询他们的 <code>value</code>属性的一种替代方法, 每一个 <code>UnicodeScalar</code> 值也可以用来构建一个新的 <code>String</code> 值, 比如在字符串插值中使用:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar)</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// ‼</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Swift中的字符串都是String类型的，字符是Character类型，看似简单，其中的细节可不少(•́ω•̀ ٥)&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 基本运算符</title>
    <link href="https://hadesxiye.github.io/2018/10/06/Swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://hadesxiye.github.io/2018/10/06/Swift基本运算符/</id>
    <published>2018-10-06T11:31:35.000Z</published>
    <updated>2018-11-29T01:52:10.413Z</updated>
    
    <content type="html"><![CDATA[<p><center>Swift 支持大多数标准 C 语言运算符，并改进了一些功能，很简单(´･(00)･｀)</center><br><a id="more"></a></p><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>Swift 支持大多数标准 C 语言运算符，并改进了一些功能以消除常见的编码错误。为防止误用等号运算符 (<code>==</code>)， 赋值运算符 (<code>=</code>)并不返回值。为了避免数值在计算时超出它们类型允许值的范围，出现意外结果，算术运算符 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> 等) 会检测且不允许值溢出。你可以使用 Swift 值溢出运算符来选择值溢出行为，相关描述请参见 <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID37" target="_blank" rel="noopener">溢出运算符</a>。</p><p>Swift 还提供了 C 语言中不存在的范围运算符，如 <code>a..&lt;b</code> 和  <code>a...b</code> ，作为表示区间值的快捷方式。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>运算符分为一元的、二元的和三元的：</p><ul><li>一元 运算符运算单个目标值（例如 <code>-a</code> ）。<br>一元 前缀 运算符显示在目标值之前（例如 <code>!b</code>），而一元 后缀 运算符显示在目标值之后（例如 <code>c!</code>）。</li><li>二元 运算符运算两个目标值（例如 <code>2 + 3</code>）并且是 中缀的 因为它们显示在两个目标值之间。</li><li>三元 运算三个目标值。像 C ， Swift 只有一个三元运算符，就是三元条件运算符（<code>a ? b : c</code>）。</li></ul><p>被运算符影响的值叫做 <code>操作数</code> 。在表达式 <code>1 + 2</code> 中， <code>+</code> 号是二元运算符，  <code>1</code> 和 <code>2</code> 是它的两个操作数。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>与 C 和 Objective-C 中的赋值运算符不同，Swift 的赋值运算符本身不返回值。下方的语句是无效的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">    <span class="comment">// 这是无效的，因为 x = y 不返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>与 C 以及 Objective-C 不同的是， 在 Swift 中, 默认情况下算术运算符不允许值溢出。但是你能通过用 Swift 的溢出符号 (正如 <code>a &amp;+ b</code>)去加入值溢出的行为。参考 <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID37" target="_blank" rel="noopener">Overflow Operators</a>。<br>加号同样支持<code>String</code>的连接：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, "</span> + <span class="string">"world"</span>  <span class="comment">// 等于 "hello, world"</span></span><br></pre></td></tr></table></figure></p><h2 id="取余运算符"><a href="#取余运算符" class="headerlink" title="取余运算符"></a>取余运算符</h2><div class="note warning"><p>注意<br>取余运算符 (<code>%</code>) 在别的一些语言中的意思是 模运算符 。不过，严格意义上在 Swift 中，对于负数来说它是取余运算而不是模运算。<br></p></div><h2 id="一元减号运算符"><a href="#一元减号运算符" class="headerlink" title="一元减号运算符"></a>一元减号运算符</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three       <span class="comment">// minusThree 等于 -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree   <span class="comment">// plusThree 等于 3, or "--3"</span></span><br></pre></td></tr></table></figure><h2 id="一元加号运算符"><a href="#一元加号运算符" class="headerlink" title="一元加号运算符"></a>一元加号运算符</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><h2 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h2><p>和 C 类似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span></span><br><span class="line"><span class="comment">// a 现在等于 3</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>复合赋值运算符没有返回值。例如，你不能这么写  <code>let b = a += 2</code>。<br></p></div><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>Swift 支持所有的标准 C 系比较运算符</p><div class="note warning"><p>注意<br>Swift 还提供了两个恒等运算符（<code>===</code> 和 <code>!==</code>），你可以用它们来判断两个对象引用是否指向同一个实例。</p></div><p>如果两个元组有着相同数量和类型的元素，你就可以比较它们。元组的比较是从左向右，逐个比较的，直到遇到不相等的元素为止。也就是说，每次元素比较的返回值都决定着整个元组比较的结果。如果所有对应元素都相等，那么这两个元组就是相等的。比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">"zebra"</span>) &lt; (<span class="number">2</span>, <span class="string">"apple"</span>)   <span class="comment">// true，因为 1 小于 2，"zebra" 和 "apple" 没有被比较。</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">"apple"</span>) &lt; (<span class="number">3</span>, <span class="string">"bird"</span>)    <span class="comment">// true，因为 3 等于 3，而且 "apple" 小于 "bird"。</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">"dog"</span>) == (<span class="number">4</span>, <span class="string">"dog"</span>)      <span class="comment">// true，因为 4 等于 4，而且 "dog" 等于 "dog"。</span></span><br></pre></td></tr></table></figure></p><p>如果一个操作符可以被用来比较两个元组的每个对应元素，那么它就可以被用来比较这两个元组。比如像以下代码演示的那样，你可以比较两个类型为 <code>(String, Int)</code> 的元组，因为 <code>String</code> 和 <code>Int</code> 类型的值都可以用 <code>&lt;</code> 操作符比较。与之形成对比的是，两个 <code>(String, Bool)</code> 类型的元组不能用 <code>&lt;</code> 比较，因为 <code>&lt;</code> 运算符在 <code>Bool</code> 上没有定义。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"blue"</span>, -<span class="number">1</span>) &lt; (<span class="string">"purple"</span>, <span class="number">1</span>)        <span class="comment">// 正确，比较的结果为 true</span></span><br><span class="line">(<span class="string">"blue"</span>, <span class="literal">false</span>) &lt; (<span class="string">"purple"</span>, <span class="literal">true</span>)  <span class="comment">// 错误，因为两个布尔类型的值不能用 &lt; 比较。</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>Swift 标准库只定义了用于比较拥有七个以内元素的元组的操作符，如果想要比较两个拥有七个或更多元素的元组，你就需要自己来实现该运算符。</p></div><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>它的形式是 <code>question ? answer1 : answer2</code></p><h2 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h2><p>空合运算符 (<code>a ?? b</code>) 在可选型 <code>a</code> 有值的时候就为它解包，在 <code>a</code> 为 <code>nil</code> 的时候就返回默认值 <code>b</code> 。表达式 <code>a</code> 一定要是可选型。表达式 <code>b</code> 和 <code>a</code> 存储的值类型一定要一致。</p><p>空合运算符是下面代码的简写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>如果 a 的值不是 nil ，那么 b 的值将不会被计算。这就是 短路求值。</p></div><h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><p>Swift 包含的一些 区间运算符，其实是数值区间表达式的缩写。</p><h3 id="闭合区间运算符"><a href="#闭合区间运算符" class="headerlink" title="闭合区间运算符"></a>闭合区间运算符</h3><p>闭合区间运算符 (<code>a...b</code>) 表示从 <code>a</code> 到 <code>b</code> 的区间，并且包含 <code>a</code> 和 <code>b</code>。<code>a</code> 一定不能大于 <code>b</code>。</p><p>当你想遍历一个区间中的值加以利用时，那么闭合区间运算符就在合适不过了，比如在用 <code>for-in</code> 循环的时候：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure></p><h3 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h3><p>半开区间运算符（<code>a..&lt;b</code>）定义了一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间。之所以称之为半开，是因为该区间只包含第一个值，而不包含最后一个值。与闭区间运算符一样，<code>a</code> 绝不可以大于 <code>b</code>。如果 <code>a</code> 等于 <code>b</code> 的话，就表示该区间为空。</p><p>当你作用于一个索引从 0 开始的列表（比如数组）时，如果你想要从 0 开始，一直数到（但不过包括）列表的长度，半开区间就显得非常有用了:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Person <span class="subst">\(i + <span class="number">1</span>)</span> is called <span class="subst">\(names[i])</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person 1 is called Anna</span></span><br><span class="line"><span class="comment">// Person 2 is called Alex</span></span><br><span class="line"><span class="comment">// Person 3 is called Brian</span></span><br><span class="line"><span class="comment">// Person 4 is called Jack</span></span><br></pre></td></tr></table></figure></p><h3 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h3><p>闭区间运算符还有另外一种形式，表示向一个方向尽可能地延伸——例如在数组中，一个包含了从索引为 2 开始一直到结尾的所有元素的区间。在这些情况下，你可以省去该区间操作符一侧的值。因为这种区间只有一侧有值，所以它们叫作 单侧区间，例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span>...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br><span class="line"><span class="comment">// Brian</span></span><br></pre></td></tr></table></figure></p><p>半开区间操作符如果只保留其终值就是它的单侧形式了。就像它的完全形式一样，终值本身并不是该区间的一部分，例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[..&lt;<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure></p><p>单侧区间不仅仅能被用于下标，还能用于一些其它情况。你无法遍历省略了初始值的单侧区间，因为那种形式没有明确指出遍历应该从哪儿开始。不过你可以遍历没有终值的单侧区间；需要注意的是，因为区间的延伸特性，请务必确保你的遍历循环里有一个清晰的用于结束循环的条件。你还可以检查一个单侧区间是否包含某个特定的值，就像下边代码展示的那样。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = ...<span class="number">5</span></span><br><span class="line">range.<span class="built_in">contains</span>(<span class="number">7</span>)   <span class="comment">// false</span></span><br><span class="line">range.<span class="built_in">contains</span>(<span class="number">4</span>)   <span class="comment">// true</span></span><br><span class="line">range.<span class="built_in">contains</span>(-<span class="number">1</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>Swift 支持基于 C 语言中的 3 种标准逻辑运算符</p><ul><li>逻辑非（<code>!a</code>）</li><li>逻辑与（<code>a &amp;&amp; b</code>）</li><li>逻辑或（<code>a || b</code>）</li></ul><h2 id="混合逻辑运算"><a href="#混合逻辑运算" class="headerlink" title="混合逻辑运算"></a>混合逻辑运算</h2><p>你可以组合多个逻辑运算符来创建更长的复合表达式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Welcome!"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>Swift 逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 都是左关联的，这意味着具有多个逻辑运算符的复合表达式首先判断最左边的子表达式。</p></div><h2 id="显性括号"><a href="#显性括号" class="headerlink" title="显性括号"></a>显性括号</h2><p>括号清楚地表明了前两个值被视为整体逻辑中独立可能状态的一部分。这个复合表达式的结果并没有改变，但是其整体的意图对于读者来说更加清晰了。易读性总是优先于简洁性；在可以帮助你明确意图的地方，使用括号吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Swift 支持大多数标准 C 语言运算符，并改进了一些功能，很简单(´･(00)･｀)&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2（基础篇要点）</title>
    <link href="https://hadesxiye.github.io/2018/10/05/Swift%E5%9F%BA%E7%A1%80/"/>
    <id>https://hadesxiye.github.io/2018/10/05/Swift基础/</id>
    <published>2018-10-05T02:55:28.000Z</published>
    <updated>2018-11-29T01:52:30.847Z</updated>
    
    <content type="html"><![CDATA[<p><center>Swift4.2基础篇摘要ʕ•͡ω•ʔ</center><br><a id="more"></a></p><div class="note info"><p>本章节只是简单的摘录文档里的重要内容（或者是没记住的-  -）如果想从头开始看Swift还是直接看官方文档比较好</p></div><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><p>除了属性的类型，Swift引入了Objective-C中没有的高级类型，比如元组。元组可以让你创建与传递值的分组。你可以使用元组将函数中的多个值作为单个复合值返回。</p><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>Swift 还引入了可以处理缺省值的可选类型。可选类型表示<code>「要么 有 值，并且等于 X」</code>，<code>「要么 没有 值」</code> 。使用可选类型与在 Objective-C 中将指针和 nil 一起使用很相似，但是，可选类型适用于任何类型，不仅仅是类。可选类型不仅比 Objective-C 中的 nil 指针更安全，更具表现力，它还是 Swift 众多强大特性中的核心。</p><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>Swift 是一门 <code>类型安全</code> 的语言，这意味着它有助于明确代码中的值的类型。如果代码中需要一个 String，类型安全可以防止你错误地传递给它一个 Int。同样的，类型安全可以防止你意外地将一个可选的 String 传递给一个需要非可选 String 的代码片段。在开发过程中，类型安全可以帮你尽早捕捉并修复错误。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Swift 中的多行注释可以相互嵌套使用</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>Double 类型可以精确到小数点后15位，而 Float 类型只有6位。<br>如果两种类型都能使用的情况下，优先使用 Double 类型 。</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>因为有了类型推断，Swift 和 C 以及 Objective-C 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。<br>Swift 在推断浮点值的时候始终会选择 Double （而不是Float）。</p><h2 id="数值型字面量"><a href="#数值型字面量" class="headerlink" title="数值型字面量"></a>数值型字面量</h2><p>整数型字面量可以写作：</p><ul><li>十进制数，没有前缀</li><li>二进制数，前缀为 0b</li><li>八进制数，前缀为 0o</li><li>十六进制数，前缀为 0x</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>SomeType(ofInitialValue) 是 Swift 中初始化一个对象的默认方式，在这个过程中需要传入一个初始值。而在底层实现中，UInt16 有一个接收 UInt8 类型的初始化构造器，所以这个构造器是用来转换 UInt8 类型 到 UInt16 类型 的。你不能在这传入 任何 类型，因为必须是 UInt16 初始化构造器允许的类型才可以。扩展现有类型的初始化构造器，让其接收新的类型（包括你自己自定义的类型）的内容在 Extensions 中可以找到。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名 就是给现有类型定义了一个另外的名字。你可以使用 <code>typealias</code> 关键字来声明类型别名。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Swift 有一个基础 布尔 类型 Bool. 布尔值也被称为 逻辑值, 因为它们只能是真或假。 Swift 提供两个布尔常量，<code>true</code> 和 <code>false</code> 。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组 将多个值组合在一起成为一个复合值。元组里面的值可以是任何类型，不需要是相同的类型。<br>你可以将一个元组的内容 分解 为单独的常量或变量，然后你就可以正常使用它们了：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String), 等于 (404, "Not Found")</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure></p><p>如果你只需要元组里的一部分值的话，分解元组的时候使用一个下划线（_） 来忽略元组里面的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The status code is 404"</span></span><br></pre></td></tr></table></figure></p><p>此外，使用从零开始的下标来访问元组里单个元素的值：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"The status code is \(http404Error.0)"</span>)</span></span></span><br><span class="line"><span class="comment">// 打印 "The status code is 404"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"The status message is \(http404Error.1)"</span>)</span></span></span><br><span class="line"><span class="comment">// 打印 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure></p><p>定义元组时，你可以为元组中的单个元素命名：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let http200Status = (<span class="string">statusCode:</span> <span class="number">200</span>, <span class="string">description:</span> <span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure></p><p>如果你在元组里为元素命名了，那么你就可以通过元素名称去获取元素的值：\<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"The status code is \(http200Status.statusCode)"</span>)</span></span></span><br><span class="line"><span class="comment">// 打印 "The status code is 200"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"The status message is \(http200Status.description)"</span>)</span></span></span><br><span class="line"><span class="comment">// 打印 "The status message is OK"</span></span><br></pre></td></tr></table></figure></p><p>元组作为函数的返回值的时候十分有用。一个尝试获取一个网页的函数可能会返回一个 (Int, String) 类型来表示结果的成功或失败。相比于返回一个类型的单个值作为结果，通过返回包含两个不同类型值的一个元组作为返回值，这个函数让自己的返回值提供了更多有用的信息。更多信息，参考 函数参数与返回值</p><div class="note warning"><p><strong>注意</strong><br>元组在临时组织的值的时候很有用。元组并不适合用于创建复杂数据结构。如果你的数据结构<br>比较持久而不是临时使用的话，使用类或者结构体，而不是元组。更多信息，参考 结构体和类.<br></p></div><h2 id="可选类型-1"><a href="#可选类型-1" class="headerlink" title="可选类型"></a>可选类型</h2><div class="note warning"><p><strong>注意</strong><br><code>C</code> 和 <code>Objective-C</code> 中没有可选类型的概念。最接近的是<code>Objective-C</code> 中的一个方法除了返回对象之外还会返回<code>nil</code> 的能力，<code>nil</code>表示缺省一个合法的对象。然而，这仅仅对对象起作用 — 对结构体，基本<code>C</code> 类型或者枚举类型并不起作用。对于这些类型，<code>Objective-C</code> 的方法通常会返回一个特殊的值(比如 <code>NSNotFound</code>)来表示值缺省的情况。这种方式假设方法的调用者知道和记得对特殊值进行处理和检查。<code>Swift</code> 的可选类型可以让你表明任何类型的值缺省的情况，而不需要特殊值。<br></p></div><p>非可选状态下的常量或变量不能使用 <code>nil</code> 。在某些特定条件下，如果你代码中的常量或变量需要指定为空值，则始终将其声明为适当类型的可选值。</p><p>如果你定义了一个可选变量但没有赋值，变量将自动设置为 <code>nil</code></p><div class="note warning"><p><strong>注意</strong><br>Swift 里的 nil 不同于 Objective-C 里的 nil 。 在 Objective-C 里, nil 是一个指向空对象的指针。在 Swift 里， nil 不是指针，而是某种特定类型值的缺失。  任意 类型都可以设置为 nil, 而不仅仅是对象类型。<br></p></div><h2 id="if-语句和强制解析"><a href="#if-语句和强制解析" class="headerlink" title="if 语句和强制解析"></a>if 语句和强制解析</h2><p>你可以在通过一个 <code>if</code> 语句里比较可选项和 <code>nil</code> 的方式来确定其是否包含确定值 。执行比较需要用到“等于”操作符 <code>==</code> ，或者“不等于”操作符<code>!=</code>。</p><p>如果一个可选项包含值，那么它就被认为不等于 <code>nil</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "convertedNumber 包含整型值."</span></span><br></pre></td></tr></table></figure></p><p>一旦你确认可选项包含值，你就可以通过使用在可选项名称后添加<code>!</code>的方式来访问它的值。感叹号的含义是：“我知道这个可选项绝对有值，请使用它。”这就是对可选项值的强制解析。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of <span class="subst">\(convertedNumber!)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "convertedNumber 包含整型值 123."</span></span><br></pre></td></tr></table></figure></p><h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><p>使用可选绑定 <code>optional binding</code>  来判断一个可选类型是否包含值，如果包含就赋给一个临时的常量或者变量使这个值可用。可选绑定可以被用到<code>if</code>和<code>while</code>语句中，用来检差一个值是否是可选类型， 并且将值提取为一个常量或者变量。<br> <code>if</code> 语句的可选绑定可以写成如下这样：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</span><br><span class="line">    <span class="built_in">statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用可选绑定而不是强制解包来重写 可选类型 章节的 possibleNumber 例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\"<span class="subst">\(possibleNumber)</span>\" has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\"<span class="subst">\(possibleNumber)</span>\" could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints ""123" has an integer value of 123"</span></span><br></pre></td></tr></table></figure></p><p>上面的代码可以被理解为：</p><p>“如果通过 <code>Int(possibleNumber)</code>返回的可选 <code>Int</code> 类型包含一个值，那么就创建一个名为 <code>actualNumber</code> 的新的常量并把可选类型中的值赋给它。”</p><p>如果转换成功，常量 <code>actualNumber</code> 可以被用在 <code>if</code> 语句的第一个分支中。它已经被可选类型 包含的 值初始化，因此不再需要使用后缀 <code>!</code> 来获取它的值。在这个例子中，<code>actualNumber</code> 被简单地用来打印转换的结果。</p><div class="note warning"><p><strong>注意</strong><br>在  <code>if</code> 语句中使用可选绑定的常量和变量仅在 <code>if</code>  语句内可用。相反，在  <code>guard</code> 语句中创建的常量和变量在 <code>guard</code>语句后的代码中也可以使用，如上所述 <code>Early Exit</code>.<br></p></div><h2 id="隐式展开可选项"><a href="#隐式展开可选项" class="headerlink" title="隐式展开可选项"></a>隐式展开可选项</h2><p>通过在声明的类型后边添加一个叹号 <code>String!</code> 而非问号 <code>String?</code> 来书写隐式展开可选项。<br>隐式展开可选项是后台中通用的可选项，但是同样也可以像非可选值来使用，每次访问的时候不需要展开。接下来的例子中展示了在访问被明确为 <code>String</code> 的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">//要求使用感叹号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString <span class="comment">// 不需要使用感叹号</span></span><br></pre></td></tr></table></figure></p><blockquote><p>你可以把隐式展开可选项当做在每次访问他的时候被给与了自动进行展开的权限。相比于在每次调用他的时候添加一个叹号，你可以再声明的时候呀添加一个叹号。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>相比于可选项的通过值是否缺失来判断程序的执行正确与否，错误处理机制能允许你判断错误的形成原因，如果需要的话，还能将你的代码中的错误传递到程序的其他地方。<br>当一个函数遇到错误情况，他或 抛出 错误。这个函数的访问者会 捕捉 到这个错误并且做出适当的反应。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数可能会出错也可能不会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在函数声明过程中加入  <code>throws</code> 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，你需要再表达式前预置 <code>try</code> 关键字。</p><p><code>Swift</code> 会自动将错误传递到他们的生效范围之内，直到他们被 <code>catch</code>  分局处理。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> canThrowAnError()</span><br><span class="line">    <span class="comment">// 无错误抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 有错误抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>do</code> 语句创建了一个新的容器范围，可以让错误被传递到不止一个的 <code>catch</code> 分句处理。</p><p>下面的例子演示了如何利用错误处理机制处理不同的错误情况：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.outOfCleanDishes &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.missingIngredients(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本例中，如果没有干净的盘子或某个原料缺失的话，<code>makeASandwich()</code> 函数会抛出一个错误。因为 <code>makeASandwich()</code> 函数抛出了错误，所以对它的调用被包裹在一个 <code>try</code> 表达式里。将函数调用包裹进一个 <code>do</code> 的语句里，任何抛出的错误都会被传播到提供的 <code>catch</code> 从句里。</p><p>如果没有抛出错误，<code>eatASandwich()</code> 方法将会被调用。如果抛出了错误，并且匹配到了 <code>outOfCleanDishes</code> 条件的话，<code>washDishes()</code> 函数就会被调用。如果匹配到了 <code>SandwichError.missingIngredients</code> 条件，<code>buyGroceries(_:)</code> 函数就会被调用，并且使用 <code>catch</code> 捕获的关联 <code>String</code> 值作为参数。</p><h2 id="断言与先决条件"><a href="#断言与先决条件" class="headerlink" title="断言与先决条件"></a>断言与先决条件</h2><p><code>断言</code> 和 <code>先决条件</code> 是程序运行时发生的检查动作。你可以使用它们来检查代码被执行之前的一些必要条件是否被满足。如果断言或先决条件中布尔值的条件等于 <code>true</code>，代码将会像平常一样继续执行下去。如果条件等于 <code>false</code>，当前程序的状态将会是无效的，并且会导致代码执行停止，程序被终止。</p><blockquote><p>断言和先决条件的<strong>不同点</strong>是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。</p></blockquote><h3 id="调试断言"><a href="#调试断言" class="headerlink" title="调试断言"></a>调试断言</h3><p>使用 <code>Swift</code> 标准库中的  <code>assert(_:_:file:line:)</code> 函数来声明一个断言语句。<br>可以向这个函数传入一个值为 <code>true</code> 或 <code>false</code> 的表达式以及如果条件为 <code>false</code> 的情况下的提示性信息。如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person's age can't be less than zero."</span>)</span><br><span class="line"><span class="comment">// 因为 -3 小于 0，所以这个断言失败了</span></span><br></pre></td></tr></table></figure></p><p>上面的例子中，如果 <code>age &gt;= 0</code> 语句结果为 <code>true</code>，代码将继续执行下去，也就是说 <code>age</code> 的值是非负的。如果 <code>age</code> 的值是负数，那么上面的代码中的 <code>age &gt;= 0</code> 语句将返回 <code>false</code>，这将导致断言失败，程序终止。</p><p>你可以省略断言提示信息 — 比如下面的代码，仅仅是单调地重复一下条件语句。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>如果代码中已经检查了条件的话，可以使用  <code>assertionFailure(_:file:line:)</code> 函数来表明断言已经失败。如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You can ride the roller-coaster or the ferris wheel."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You can ride the ferris wheel."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assertionFailure</span>(<span class="string">"A person's age can't be less than zero."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="强制执行先决条件"><a href="#强制执行先决条件" class="headerlink" title="强制执行先决条件"></a>强制执行先决条件</h3><p>只要条件可能会为 <code>false</code> 的时候，就使用先决条件。但代码必须 肯定 为 <code>true</code> 才能继续执行下去。例如，使用先决条件去检查下标是否越界或检查函数是否传入了合法的参数值。</p><p>通过调用 <code>precondition(_:_:file:line:)</code> 函数来声明一个先决条件。你可以向一个先决条件传入结果为 <code>true</code> 或 <code>false</code> 的表达式和当结果为 <code>false</code> 时的提示信息。例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断下标...</span></span><br><span class="line"><span class="built_in">precondition</span>(index &gt; <span class="number">0</span>, <span class="string">"Index must be greater than zero."</span>)</span><br></pre></td></tr></table></figure></p><p>你也可以使用 <code>preconditionFailure(_:file:line:)</code>  函数来表明执行的失败 — 例如，如果一个 <code>switch</code> 语句的默认条件命中了，但是所有有效的输入数据只会被其他条件处理。</p><div class="note warning"><p><strong>注意</strong><br>如果你以不检查的编译模式( <code>Ounchecked</code> )模式进行编译，先决条件将不会起作用。编译器会假设先决条件总是为真，并会根据你的代码做相应的优化。然而，无论优化设置如何，<code>fatalError(_:file:line:)</code> 函数总会停止程序的执行。<br><br>你可以在原型设计和开发的早期过程中使用 <code>fatalError(_:file:line:)</code> 函数来创建尚未实现的功能的存根，编写 <code>fatalError(&quot;Unimplemented&quot;)</code> 作为存根的实现。因为 <code>fatal error</code> 永远不会被优化，与断言和先决条件不同的是，你可以确保程序总是在遇到存根实现时停止。<br></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Swift4.2基础篇摘要ʕ•͡ω•ʔ&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2光速入门٩(๑&gt;◡&lt;๑)۶</title>
    <link href="https://hadesxiye.github.io/2018/10/03/Swift/"/>
    <id>https://hadesxiye.github.io/2018/10/03/Swift/</id>
    <published>2018-10-03T06:08:44.000Z</published>
    <updated>2018-11-29T01:52:44.462Z</updated>
    
    <content type="html"><![CDATA[<p><center>9月25日，Xcode10发布了！支持swift3和swift4，而如今swift也日趋成熟，使用swift开发的项目也越来越多。<br>ʕ•̀ω•́ʔ✧是时候学swift了，一起来光速入门吧~</center><br><a id="more"></a></p><h2 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h2><p>swift采用了现代编程模式，以避免大量常见的低级编程错误：</p><ul><li>变量永远会在被使用前完成初始化</li><li>对数组的索引操作会自动检查是否出现越界错误</li><li>整型数值会自动检查是否溢出</li><li>可选值确保<code>nil</code>值被正确处理</li><li>内存被自动管理</li><li>错误处理允许从异常故障控制恢复</li></ul><p>当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享：</p><ul><li>子字符串的操作返回的实例是<code>Substring</code>类型而不是<code>String</code></li><li>在较少的地方会隐性增加<code>@objc</code>属性</li><li>同一文件中类型的拓展可以访问该类型中的私有成员</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，从hello world开始<br>用swift实现可太tm简单了<br>用xcode创建一个swift blank项目，在playground中输入一句话<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world!"</span>)</span><br></pre></td></tr></table></figure></p><p>全局作用域中的代码会自动作为程序的入口，因此；不需要<code>main()</code>函数，同样的，你也不需要写<code>;</code>了。</p><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><blockquote><p><code>lei</code>声明常量<br><code>var</code>声明变量</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">num =  <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> number  = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，<code>num</code>是个整数，因为它的初始值是一个整数。</p><blockquote><p>如果没有初始值，你又想声明类型，你只要在变量后声明类型，用<code>:</code>分割。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num3:<span class="type">Double</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>swift有一种更简单的方式让值转为字符串：把值写在<code>()</code>内，在括号之前再加一个<code>\</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"girlfriend"</span></span><br><span class="line"><span class="keyword">let</span> sum1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> sum2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I used to have <span class="subst">\(sum1)</span> <span class="subst">\(str)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"and now I have <span class="subst">\(sum1*sum2)</span> <span class="subst">\(str)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"pretty girl check your wechat number and send it to me pls:)"</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>对于占用多行的字符串可以使用三个引号<code>&quot;&quot;&quot;</code>每行的来头缩进要和右引号的缩进相同<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">hello~</span></span><br><span class="line"><span class="string">this my wechat number</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用<code>[]</code>来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"my"</span>,<span class="string">"name"</span>,<span class="string">"is"</span>,<span class="string">"hades"</span>]</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"whz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dic = [</span><br><span class="line">    <span class="string">"key1"</span>:<span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span>:<span class="string">"valeu2"</span></span><br><span class="line">]</span><br><span class="line">dic[<span class="string">"key2"</span>] = <span class="string">"value change"</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用初始化语法来创建一个空数组或者字典<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArr = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDic = [<span class="type">String</span>:<span class="type">String</span>]()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果类型能<strong>被推断</strong>，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line">dic = [:]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><blockquote><p>使用<code>if</code>和<code>switch</code>来创建条件语句，使用<code>for</code>-<code>in</code>,<code>while</code>，以及<code>repeat</code>-<code>while</code>来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArr = [<span class="number">123</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">43</span>,<span class="number">65</span>]</span><br><span class="line"><span class="keyword">var</span> totalNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> tempNum <span class="keyword">in</span> numArr &#123;</span><br><span class="line">    <span class="keyword">if</span> tempNum &lt; <span class="number">50</span> &#123;</span><br><span class="line">        totalNum -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        totalNum += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(totalNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"end of totalnum = <span class="subst">\(totalNum)</span>"</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在<code>if</code>语句中，条件语句必须是布尔表达式，可以使用<code>if</code>和<code>let</code>来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为<code>nil</code>表示值缺失。在值得类型后面跟随一个<code>?</code>则表示这个值是可选的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exampleStr:<span class="type">String</span>? = <span class="string">"hello"</span></span><br><span class="line"><span class="built_in">print</span>(exampleStr == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name:<span class="type">String</span>? = <span class="string">"hades"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"hello~"</span></span><br><span class="line"><span class="comment">//name = "xiye"</span></span><br><span class="line"><span class="comment">//name = nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> nameTemp = name &#123;  <span class="comment">//如果类型转换成功，则将值赋值给nameTemp直接使用</span></span><br><span class="line">    greeting = <span class="string">"hello~ <span class="subst">\(nameTemp)</span>"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"nameTemp = <span class="subst">\(nameTemp)</span> name = <span class="subst">\(name!)</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"( let nameTemp = name ) = true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name = nil "</span>) <span class="comment">//强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"( let nameTemp = name ) = false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>如果可选值为<code>nil</code>，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给<code>let</code>后的常量，这样代码中就可以使用这个值。</p><p>处理可选值得另一种方法是使用<code>??</code>操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nickName: <span class="type">String</span>? = <span class="literal">nil</span> <span class="comment">//"whz"</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> = <span class="string">"hades"</span></span><br><span class="line"><span class="comment">//nickName = "whz"</span></span><br><span class="line"><span class="comment">//nickName = nil</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting = <span class="string">"hi~ <span class="subst">\(nickName ?? fullName)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(informalGreeting)</span><br></pre></td></tr></table></figure><blockquote><p><strong>oc中的nil和swift中的nil</strong><br>Objective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)<br>Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil)</p></blockquote><blockquote><p>‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = <span class="string">"ex"</span></span><br><span class="line"><span class="keyword">switch</span> people &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"girl"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hey~ could you give me your wechat number?"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"man"</span>,<span class="string">"boy"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"oh...next pls"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"x"</span>):<span class="comment">//hasSuffix以指定后缀结束，hasPrefix以指定前缀开始</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"if time can come back..."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello stranger."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。<br>你可以为字典中的键值对起一组名字，并用<code>for</code> <code>in</code>语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumbers = [</span><br><span class="line">    <span class="string">"key1"</span>:[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">31</span>],</span><br><span class="line">    <span class="string">"key2"</span>:[<span class="number">2</span>,<span class="number">43</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">53</span>],</span><br><span class="line">    <span class="string">"key3"</span>:[<span class="number">2345</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">65</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> maxName:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (keyInSomeNumbers,valueInSomeNumbers) <span class="keyword">in</span> someNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> values <span class="keyword">in</span> valueInSomeNumbers &#123;</span><br><span class="line">        <span class="keyword">if</span> values &gt; maxNum &#123;</span><br><span class="line">            maxNum = values</span><br><span class="line">            maxName = <span class="string">"<span class="subst">\(keyInSomeNumbers)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(maxName)</span> <span class="subst">\(maxNum)</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>使用<code>while</code>来循环执行代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n*n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    m = m + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"m = <span class="subst">\(m)</span>"</span>)</span><br><span class="line">&#125;<span class="keyword">while</span> m &lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure></p><p>可以使用<code>..&lt;</code>来限定索引范围，并在循环中遍历该索引范围<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    total += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure></p><h3 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h3><p>使用<code>func</code>来声明一个函数。使用函数名和参数名来调用函数。使用<code>-&gt;</code>来指定函数返回值类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span> <span class="params">(person:String,day:String)</span></span>-&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>,today is <span class="subst">\(day)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"whz"</span>, day: <span class="string">"thuesday"</span>))</span><br></pre></td></tr></table></figure></p><p>默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用<code>_</code>来表示来不使用参数标签。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> preson:String,on day:String)</span></span>-&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello <span class="subst">\(preson)</span>,today is <span class="subst">\(day)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(<span class="string">"hades"</span>, on: <span class="string">"friday"</span>))</span><br></pre></td></tr></table></figure></p><p>使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(scores:[Int])</span></span> -&gt; (<span class="built_in">min</span>:<span class="type">Int</span>,<span class="built_in">max</span>:<span class="type">Int</span>,sum:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>,<span class="built_in">max</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = function(scores: [<span class="number">1</span>,<span class="number">31</span>,<span class="number">413</span>,<span class="number">356</span>,<span class="number">1</span>,<span class="number">376</span>,<span class="number">463</span>])</span><br><span class="line"><span class="built_in">print</span>(result.<span class="built_in">max</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span>-&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(returnFifteen())</span><br></pre></td></tr></table></figure></p><p>函数是一个类型。意味着函数可以作为其他函数的返回值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnOneFunction</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">returnOneInt</span><span class="params">(number:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOneInt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFunction = returnOneFunction()</span><br><span class="line"><span class="built_in">print</span>(anotherFunction(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>一个函数也可以作为参数传入另一个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list:[Int],condition:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">7</span>,<span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure></p><p>函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行<br>你可以使用<code>{}</code>来创建一个匿名闭包。使用<code>in</code>将参数和返回值类型与闭包函数体分离。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">7</span>,<span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br><span class="line"></span><br><span class="line">numbers.<span class="built_in">map</span>(&#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = [<span class="number">3</span>,<span class="number">41</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">51</span>]</span><br><span class="line"><span class="keyword">let</span> temp1 = temp.<span class="built_in">map</span>&#123;</span><br><span class="line">    num <span class="keyword">in</span></span><br><span class="line">    num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>swift自动为闭包提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(temp1)</span><br><span class="line"><span class="keyword">let</span> temp2 = temp.<span class="built_in">map</span>&#123;</span><br><span class="line">    $<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>通过在类名前加<code>class</code>关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在类名称后面插入括号来创建类的实例。使用<code>.</code>语法的方式来访问实例中的属性和方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span>  shapeDescription = shape.simpleDescription()</span><br><span class="line"><span class="built_in">print</span>(shapeDescription)</span><br></pre></td></tr></table></figure></p><p>当一个类的属性没有初始值，你就需要使用<code>init</code>来创建一个构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>self</code>被用来区分<code>name</code>属性和构造器的<code>name</code>参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。<br>如果你需要在对象被释放前执行一些清理的行为，可以使用<code>deinit</code>来创建一个折构器。 </p><p>子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。</p><p>子类如果需要重写父类的方法，则需要使用<code>override</code>来标记—不使用<code>override</code>关键字来标记会导致编译器报错。编译器同样也会检查<code>override</code>标记的方法是否存在父类当中。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>,name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length <span class="subst">\(sideLength)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">4.1</span>, name: <span class="string">"test square"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.area())</span><br><span class="line"><span class="built_in">print</span>(test.description())</span><br></pre></td></tr></table></figure></p><p>除了存储简单的属性，属性还可以拥有getter和setter<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilaterTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>,name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            sideLength = newValue / <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is a triangle with sides of length <span class="subst">\(sideLength)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> triangle = <span class="type">EquilaterTriangle</span>(sideLength: <span class="number">4.3</span>, name: <span class="string">"a triangle"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line">triangle.perimeter = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure></p><p>在<code>perimeter</code>的setter中，新值被隐式的命名为<code>newValue</code>。你可以在<code>set</code>的括号后面，显式的提供一个名字。</p><div class="note warning"><p>注意<code>EquilateralTriangle</code>类的初始化有三个不同的步骤：<br>- 1 设定子类的声明的属性值<br>- 2 调用父类的构造器<br>- 3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。<br></p></div><hr><p>如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用<code>willSet</code>和<code>didSet</code>。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilaterTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square:<span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(size:<span class="type">Double</span>,name:<span class="type">String</span>) &#123;</span><br><span class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle = <span class="type">EquilaterTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"test"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">40</span>, name: <span class="string">"larger square"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure></p><p>在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用<code>?</code>。如果<code>?</code>前的值是<code>nil</code>,则<code>?</code>后面的所有内容都会被忽略，且整个表达式为<code>nil</code>。否则，可选项的值将被展开，然后<code>?</code>后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="string">optionalSquare:</span> Square? = Square(sideLength: <span class="number">2.3</span>, <span class="string">name:</span> <span class="string">"optional square"</span>)</span><br><span class="line">let sideLength = optionalSquare?.sideLength</span><br></pre></td></tr></table></figure></p><hr><h3 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h3><p>使用<code>enum</code>来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ace = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> two,three,four,five,six,seven,eight,nine,ten</span><br><span class="line">    <span class="keyword">case</span> jack,queen,king</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ace:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></span><br><span class="line">        <span class="keyword">case</span> .jack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></span><br><span class="line">        <span class="keyword">case</span> .queen:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></span><br><span class="line">        <span class="keyword">case</span> .king:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"king"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.ace</span><br><span class="line"><span class="keyword">let</span> aceRawValue = ace.rawValue</span><br></pre></td></tr></table></figure></p><p>默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，<code>Ace</code>的原始值被显示赋值为<code>1</code>，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用<code>rawValue</code>属性来访问一个枚举成员的原始值。<br>使用<code>init?(rawValue:)</code>初始化构造器来创建一个拥有原始值得枚举实例。如果在<code>Rank</code>中有与该原始值相匹配的枚举实例则返回该实例，没有则返回<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank = <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> threeDescription = convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spades,hearts,diamonds,clubs</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .spades:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></span><br><span class="line">        <span class="keyword">case</span> .hearts:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></span><br><span class="line">        <span class="keyword">case</span> .diamonds:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></span><br><span class="line">        <span class="keyword">case</span> .clubs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.hearts</span><br><span class="line"><span class="keyword">let</span> haartsDescriotion = hearts.simpleDescription()</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意在上面例子中用了两种方法来调用<code>hearts</code>成员：给<code>hearts</code>指定一个常量时，枚举成员<code>Suit.hearts</code>需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式<code>.hearts</code>被调用，因为<code>self</code>的值已经确定是<code>Suit</code>类型。在值得类型已经被明确的情况下可以使用缩写。<br></p></div><hr><p>如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>,<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.result(<span class="string">"6:00 am"</span>,<span class="string">"8:00 pm"</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.failure(<span class="string">"fail"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise,sunset):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" sunrise is at <span class="subst">\(sunrise)</span> and sunset is at<span class="subst">\(sunset)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"fail - <span class="subst">\(message)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意日出日落时间是如何从<code>ServerResponse</code>值中进行提取，并与 switch cases 相匹配的。</p></div><p>使用<code>struct</code>来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The <span class="subst">\(rank.simpleDescription()</span>) of <span class="subst">\(suit.simpleDescription()</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .three, suit: .spades)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure></p><hr><h3 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h3><p>使用<code>protocol</code>来声明一个协议。<br><code>mutating</code>关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类、枚举和结构都可以遵循协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"a simple class"</span></span><br><span class="line">    <span class="keyword">var</span> anotherPriperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"now 100% adjusted"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"a simple sturcture"</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"(adjusted)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = simpleStructure()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription = b.simpleDescription</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意声明<code>SimpleStructure</code>时使用了关键字<code>mutating</code>来标记一个可以修改结构体的方法。而声明<code>SimpleClass</code>时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。<br></p></div><p>使用<code>extension</code>可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"the number <span class="subst">\(<span class="keyword">self</span>)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure><p>你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">//下面这句会报错</span></span><br><span class="line"><span class="built_in">print</span>(protocolValue.anotherProperty)</span><br></pre></td></tr></table></figure><p>尽管变量<code>protocolValue</code>在运行时类型为<code>SimpleClass</code>，但编译器依旧会把它的类型当做<code>ExampleProtocol</code>。这也就意味着，你不能随意访问在协议外的方法或属性。</p><hr><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>你可以使用任何遵循<code>Error</code>协议的类型来表示错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrintError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>throw</code>跑出异常并且用<code>throws</code>来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName == <span class="string">"Never Has Toner"</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrintError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Job sent"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几种方法可以处理异常。一种是使用<code>do</code>-<code>catch</code>。在<code>do</code>代码块里，你可以是用<code>try</code>在抛出的异常的函数前标记。在<code>catch</code>代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为<code>error</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">"Never Has Toner"</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以提供多个<code>catch</code>代码块来处理特定的错误。你可以在<code>catch</code>后面一个一个模式，就像switch语句里面的<code>case</code>一样。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">"Gutenberg"</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrintError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I'll just put this over here, with the rest of the fire."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrintError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Printer error: <span class="subst">\(printerError)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外一种处理错误的方法是用<code>try?</code>去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为<code>nil</code>。否则，结果是一个包含了函数返回值的和选项。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess = <span class="keyword">try</span>? send(job: <span class="number">1883</span>, toPrinter: <span class="string">"Mergenthaler"</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure = <span class="keyword">try</span>? send(job: <span class="number">1885</span>, toPrinter: <span class="string">"Never Has Toner"</span>)</span><br></pre></td></tr></table></figure></p><p>使用<code>defer</code>来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用<code>defer</code>来简化代码。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent = [<span class="string">"milk"</span>,<span class="string">"eggs"</span>,<span class="string">"leftovers"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span><span class="params">(<span class="number">_</span> food: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = fridgeContent.<span class="built_in">contains</span>(food)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fridgeContains(<span class="string">"milk"</span>)</span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br></pre></td></tr></table></figure></p><p><code>defer</code>常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候<br><code>defer</code>会在该当前声明的作用域结束的时候执行<br>优先级： 局部优先、同级自下而上<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstProcesses</span><span class="params">(<span class="number">_</span> isOpen: Bool)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//作用域1 整个函数作用域</span></span><br><span class="line">    <span class="keyword">defer</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"推迟操作🐢"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"😳"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isOpen == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">//作用域2 if的作用域</span></span><br><span class="line">        <span class="keyword">defer</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"推迟操作🐌"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"😁"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">&#125;</span><br><span class="line">firstProcesses(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>把名字写在尖括号里来创建一个泛型方法或者类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;Item&gt;<span class="params">(repeating item: Item,numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">"knock"</span>, numberOfTimes: <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p>你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; = .<span class="keyword">none</span></span><br><span class="line">possibleInteger = .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>在类型名称后紧接<code>where</code>来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence, U: Sequence&gt;<span class="params">(<span class="number">_</span> lhs: T,<span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">U</span>.<span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><div class="note info"><p>以上就是Swift4.2的概述，看完这些写一个简单的app已经不是难事了~<br>但简单的app可不是我们的目标，还有很多语法上的细节需要深入研究学习，在后面的文章我会逐步更新语法上的细节ʕु•̫͡•ʔु ✧</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;9月25日，Xcode10发布了！支持swift3和swift4，而如今swift也日趋成熟，使用swift开发的项目也越来越多。&lt;br&gt;ʕ•̀ω•́ʔ✧是时候学swift了，一起来光速入门吧~&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
  </entry>
  
  <entry>
    <title>LLVM是什么( ´ﾟωﾟ)？</title>
    <link href="https://hadesxiye.github.io/2018/08/23/LLVM/"/>
    <id>https://hadesxiye.github.io/2018/08/23/LLVM/</id>
    <published>2018-08-23T10:54:52.000Z</published>
    <updated>2018-11-26T09:58:08.686Z</updated>
    
    <content type="html"><![CDATA[<p><center>LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙</center><br><a id="more"></a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a><strong><font color="#FF8C00">LLVM</font></strong></h2><blockquote><p>一个开源编译器架构，目前Xcode采用的就是LLVM架构。</p></blockquote><h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a><strong><font color="#FF8C00">Clang</font></strong></h2><blockquote><p>由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。</p></blockquote><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a><strong><font color="#FF8C00">GCC</font></strong></h2><blockquote><p>GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p></blockquote><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a><strong><font color="#FF8C00">GNU</font></strong></h2><blockquote><p>GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。</p></blockquote><h2 id="在Xcode上使用GCC"><a href="#在Xcode上使用GCC" class="headerlink" title="在Xcode上使用GCC"></a><strong><font color="#FF8C00">在Xcode上使用GCC</font></strong></h2><blockquote><p>Xcode在C和C++上是支持使用GCC的，如下：<br><img src="/2018/08/23/LLVM/XcodeGNU.jpg" title="Xcode9.4上的截图"><br>具体参数的使用请参考：<a href="https://stackoverflow.com/questions/35300064/gnu-gcc-on-xcode" target="_blank" rel="noopener">stackoverflow:Xcode上的GNU GCC</a></p></blockquote><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="LLVM-1"><a href="#LLVM-1" class="headerlink" title="LLVM"></a>LLVM</h3><p>全名：<br>Low Level Virtual Machine  直译：底层虚拟机<br>/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/</p><p>  The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.<br>- 来自LLVM官网的介绍 <a href="http://llvm.org/" target="_blank" rel="noopener">LLVM官网</a></p><p>  LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。</p><p>  LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。<br> - 来自维基百科 <a href="https://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM on wiki</a></p><p>  简单来说</p><blockquote><p>LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。<br>编译器是Clang，GCC，ICC，VC++等。</p></blockquote><h4 id="Xcode和LLVM"><a href="#Xcode和LLVM" class="headerlink" title="Xcode和LLVM"></a>Xcode和LLVM</h4><blockquote><p>Xcode3之前，用的是GCC<br>Xcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器<br>Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留<br>Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能<br>Xcode4.6,LLVM升级到4.2版本<br>Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成</p></blockquote><h3 id="Clang-1"><a href="#Clang-1" class="headerlink" title="Clang"></a>Clang</h3><p>Clang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。<br>Clang项目包括Clang前端和Clang静态分析器等。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang on wiki</a></p><h3 id="GCC-1"><a href="#GCC-1" class="headerlink" title="GCC"></a>GCC</h3><p><a href="http://gcc.gnu.org/" target="_blank" rel="noopener">GCC官网</a><br>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。</p><p>原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。</p><p>许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p><p>GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC on wiki</a></p><h3 id="GNU-1"><a href="#GNU-1" class="headerlink" title="GNU"></a>GNU</h3><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">GNU官网</a><br>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。</p><p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/zh-cn/GNU" target="_blank" rel="noopener">GNU on wiki</a></p><h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><p>LLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。<br>尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。<br>LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。</p><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU Debugger 顾名思义<br>支持编程语言有C、C++、Pascal以及FORTRAN<br>在许多的类UNIX操作系统上都可以使用</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>lexical analysis /ˈlɛksɪkəl/<br>词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>syntactic analysis，也叫 parsing<br>/sɪnˈtæktɪk əˈnæləsəs/  /ˈpɑːzɪŋ/<br>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.</p><h3 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h3><p>parser<br>通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。</p><h3 id="源语言-amp-源程序"><a href="#源语言-amp-源程序" class="headerlink" title="源语言&amp;源程序"></a>源语言&amp;源程序</h3><p>Source language&amp;Source program<br>被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。</p><h3 id="目标语言-amp-目标程序"><a href="#目标语言-amp-目标程序" class="headerlink" title="目标语言&amp;目标程序"></a>目标语言&amp;目标程序</h3><p>Object language or Target language &amp; Object program or Target program<br>编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。</p><h3 id="中间语言（中间表示）"><a href="#中间语言（中间表示）" class="headerlink" title="中间语言（中间表示）"></a>中间语言（中间表示）</h3><p>Intermediate language（representation）<br>在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。</p><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>Grammars<br>/ˈgræməz/<br>文法是用于描述语言的语法结构的形式规则。</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。</p><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>abstract syntax tree或者缩写为AST<br>/ˈæbstrækt ˈsɪnˌtæks tri/<br>抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="CMD-B"><a href="#CMD-B" class="headerlink" title="CMD+B"></a>CMD+B</h3><p>Objective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。<br>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。<br>C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。</p><p>在使用Xcode按下cmd+B后，会经过以下流程：<br><img src="/2018/08/23/LLVM/02.png" title="Clang/LLVM 编译过程"><br><strong>预处理（Pre-process）</strong>：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。</p><p><strong>词法分析 （Lexical Analysis）</strong>：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。</p><p><strong>语法分析（Semantic Analysis）</strong>：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。</p><p><strong>静态分析（Static Analysis）</strong>：使用它来表示用于分析源代码以便自动发现错误。</p><p><strong>中间代码生成（Code Generation）</strong>：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</p><p><strong>优化（Optimize）</strong>：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p><p><strong>生成目标文件（Assemble）</strong>：生成Target相关Object(Mach-o) 。</p><p><strong>链接（Link）</strong>：生成 Executable 可执行文件。</p><p>关于此过程的详细测试，参考<a href="https://juejin.im/post/5a30ea0ff265da43094526f9" target="_blank" rel="noopener">掘金</a></p><h3 id="LLVM的具体操作"><a href="#LLVM的具体操作" class="headerlink" title="LLVM的具体操作"></a>LLVM的具体操作</h3><p>请参考<a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="noopener">关于LLVM，这些东西你必须知道！</a></p><blockquote><p>基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等<br>Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 <code>a+b</code> 改为 <code>a-(-b)</code><br>将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了<br>基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。</p></blockquote><p>所以基于LLVM可以完成：</p><ul><li>做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。</li><li>编写ClangPlugin，命名规范，代码规范，扩展功能。</li><li>编写Pass，代码混淆优化。</li></ul><h3 id="使用Clang进行开发"><a href="#使用Clang进行开发" class="headerlink" title="使用Clang进行开发"></a>使用Clang进行开发</h3><p>详细参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p><p>Clang的特性<br>相比于 GCC，Clang 具有如下优点：</p><ul><li>编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。</li><li>占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。</li><li>模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。</li><li>诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。</li><li>设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。</li></ul><p>当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强：</p><ul><li>支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。</li><li>支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。</li></ul><p>以下是目前GCC和Clang对C++支持的情况：<br><img src="/2018/08/23/LLVM/03.png" title="GCC Clang对C++支持对比"></p><p>更多参考<a href="https://zh.cppreference.com/w/cpp/compiler_support" target="_blank" rel="noopener">C++ 编译器支持情况表</a></p><h3 id="使用LLVM创建一个编译器"><a href="#使用LLVM创建一个编译器" class="headerlink" title="使用LLVM创建一个编译器"></a>使用LLVM创建一个编译器</h3><p>首先参考这篇文章来写一个helloworld<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/" target="_blank" rel="noopener">IBM developerWorks</a></p><p>关于LLVM IR的生成与创建<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm2/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编译相关" scheme="https://hadesxiye.github.io/categories/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="LLVM" scheme="https://hadesxiye.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="https://hadesxiye.github.io/tags/Clang/"/>
    
      <category term="GNU" scheme="https://hadesxiye.github.io/tags/GNU/"/>
    
      <category term="GCC" scheme="https://hadesxiye.github.io/tags/GCC/"/>
    
      <category term="Xcode" scheme="https://hadesxiye.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本的入门（一）</title>
    <link href="https://hadesxiye.github.io/2018/08/15/Shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hadesxiye.github.io/2018/08/15/Shell脚本的入门（一）/</id>
    <published>2018-08-15T10:48:08.000Z</published>
    <updated>2018-11-26T08:30:18.814Z</updated>
    
    <content type="html"><![CDATA[<p><center>Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。</center><br><a id="more"></a></p><h2 id="Simple-BB"><a href="#Simple-BB" class="headerlink" title="Simple BB"></a><strong>Simple BB</strong></h2><blockquote><p>为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路<br>首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。<br>获取目标资源的路径，根据A中的行数进行循环<code>find</code>查找，找到就用<code>cp</code>命令替换，未找到的重定向输出到临时文件B<br>最后打印B的内容，<code>remove</code>临时文件。<br>其中对文本的处理使用了<code>awk</code>命令</p></blockquote><p>脚本下载地址在我的github上 <a href="https://github.com/Hadesxiye/Shell_ReplaceSameNameFile" target="_blank" rel="noopener">资源替换脚本</a></p><hr><h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a><strong>Shell介绍</strong></h2><blockquote><p>Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。<br>而我使用shell只是因为<br>我用的mac - -</p></blockquote><hr><h2 id="Shell的工作原理"><a href="#Shell的工作原理" class="headerlink" title="Shell的工作原理"></a><strong>Shell的工作原理</strong></h2><blockquote><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p></blockquote><hr><h2 id="Shell的创建"><a href="#Shell的创建" class="headerlink" title="Shell的创建"></a><strong>Shell的创建</strong></h2><blockquote><p>1.打开文本编辑工具，输入一下内容<br><code>#!/bin/bashecho &quot;Hello World&quot;</code><br>2.保存为 <code>hello world.sh</code>在目录 A<br>3.在终端<code>cd</code>到目录 A<br>4.终端输入<code>chmod +x ./hello world.sh</code> （这一步是给脚本添加权限）<br>5.执行脚本   <code>./hello world.sh</code> 或者 直接把 <code>hello world.sh</code>拖入终端</p></blockquote><p>这很简单，无图。</p><hr><h2 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a><strong>Shell中的变量</strong></h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=<span class="string">"a1"</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=a1</span><br></pre></td></tr></table></figure><p>但是<br><code>example=a 1</code>  并不等同于 <code>example=&quot;a 1&quot;</code><br>因为<code>&quot; &quot;</code>（空格）在shell中用作指令的间隔<br><code>example=a 1</code> 其实只是将a负责给example 然后在输入了个1</p><blockquote><p>这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！</p></blockquote><h3 id="变量的访问"><a href="#变量的访问" class="headerlink" title="变量的访问"></a>变量的访问</h3><p>在变量前加上<code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$example</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a><strong>Shell中的四则运算</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> + <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> - <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> \* <span class="variable">$b</span></span><br><span class="line"><span class="variable">$a</span> / <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>乘法的时候需要进行转义<br><code>=</code> 赋值时，前后无空格<br>而运算符号前后必须有空格</p></blockquote><hr><h2 id="Shell中的其他运算符"><a href="#Shell中的其他运算符" class="headerlink" title="Shell中的其他运算符"></a><strong>Shell中的其他运算符</strong></h2><blockquote><p>=、==、!=、！、-o、-a</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-o 或</span><br><span class="line">-a 与</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><blockquote><p>-eq        两个数相等返回true<br>-ne          两个数不相等返回true<br>-gt            左侧数大于右侧数返回true<br>-It          左侧数小于右侧数返回true<br>-ge        左侧数大于等于右侧数返回true<br>-le            左侧数小于等于右侧数返回true</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><blockquote><p>=    两个字符串相等返回true<br>!=    两个字符串不相等返回true<br>-z    字符串长度为0返回true<br>-n    字符串长度不为0返回true<br>-d file    检测文件是否是目录，如果是，则返回 true<br>-r file    检测文件是否可读，如果是，则返回 true<br>-w file    检测文件是否可写，如果是，则返回 true<br>-x file    检测文件是否可执行，如果是，则返回 true<br>-s file    检测文件是否为空（文件大小是否大于0，不为空返回 true<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true</p></blockquote><hr><h2 id="Shell字符串操作"><a href="#Shell字符串操作" class="headerlink" title="Shell字符串操作"></a><strong>Shell字符串操作</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtext=<span class="string">"hello"</span>  <span class="comment">#定义字符串</span></span><br><span class="line">mtext2=<span class="string">"world"</span></span><br><span class="line">mtext3=<span class="variable">$mtext</span><span class="string">" "</span><span class="variable">$mtext2</span>  <span class="comment">#字符串的拼接</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$mtext3</span>  <span class="comment">#输出字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#mtext3&#125;</span>  <span class="comment">#输出字符串长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;mtext3:1:4&#125;</span>  <span class="comment">#截取字符串</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a><strong>Shell数组</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4 5)  <span class="comment">#定义数组</span></span><br><span class="line">array2=(aa bb cc dd ee)  <span class="comment">#定义数组</span></span><br><span class="line">value=<span class="variable">$&#123;array[3]&#125;</span>  <span class="comment">#找到某一个下标的数，然后赋值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$value</span>  <span class="comment">#打印</span></span><br><span class="line">value2=<span class="variable">$&#123;array2[3]&#125;</span>  <span class="comment">#找到某一个下标的数，然后赋值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$value2</span>  <span class="comment">#打印</span></span><br><span class="line">length=<span class="variable">$&#123;#array[* ]&#125;</span>  <span class="comment">#获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell输出"><a href="#Shell输出" class="headerlink" title="Shell输出"></a><strong>Shell输出</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell的判断"><a href="#Shell的判断" class="headerlink" title="Shell的判断"></a><strong>Shell的判断</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is equal to b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is greater than b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a is less than b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"None of the condition met"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的test命令"><a href="#Shell中的test命令" class="headerlink" title="Shell中的test命令"></a><strong>Shell中的test命令</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">test</span> $[num1] -eq $[num2]  <span class="comment">#判断两个变量是否相等</span></span><br><span class="line">  <span class="built_in">test</span> num1=num2  <span class="comment">#判断两个数字是否相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-e file    文件存在则返回真</span><br><span class="line">-r file    文件存在并且可读则返回真</span><br><span class="line">-w file    文件存在并且可写则返回真</span><br><span class="line">-x file    文件存在并且可执行则返回真</span><br><span class="line">-s file    文件存在并且内容不为空则返回真</span><br><span class="line">-d file    文件目录存在则返回真</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的循环"><a href="#Shell中的循环" class="headerlink" title="Shell中的循环"></a><strong>Shell中的循环</strong></h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=10;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 5 6 7 8 9</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$HOME</span>/.bash*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$FILE</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNTER</span> -lt 5 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">COUNTER=`expr <span class="variable">$COUNTER</span> + 1`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$COUNTER</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'请输入。。。'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'ctrl + d 即可停止该程序'</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Yeah! great film the <span class="variable">$FILM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span>  <span class="comment">#跳出所有循环</span></span><br><span class="line"><span class="built_in">break</span> n  <span class="comment">#跳出第n层f循环</span></span><br><span class="line"><span class="built_in">continue</span>  <span class="comment">#跳出当前循环</span></span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a><strong>Shell中的函数</strong></h2><blockquote><p>无参数无返回值</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">sysout</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sysout    </span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&gt; 无参数有返回值</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">  <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  aNum=3</span><br><span class="line">  anotherNum=5</span><br><span class="line">  <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">test</span></span><br><span class="line">  result=$?</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&gt; 有参数有返回值</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">  <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$1</span>  <span class="comment">#接收第一个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$2</span>  <span class="comment">#接收第二个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$3</span>  <span class="comment">#接收第三个参数</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$#</span>  <span class="comment">#接收到参数的个数</span></span><br><span class="line">  <span class="built_in">echo</span> $*  <span class="comment">#接收到的所有参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span> aa bb cc</span><br></pre></td></tr></table></figure><h2 id="Shell中的重定向"><a href="#Shell中的重定向" class="headerlink" title="Shell中的重定向"></a><strong>Shell中的重定向</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echo</span> result &gt; file  <span class="comment">#将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写</span></span><br><span class="line"><span class="variable">$echo</span> result &gt;&gt; file  <span class="comment">#将结果写入文件，结果不会在控制台展示，而是在文件中，追加写</span></span><br><span class="line"><span class="built_in">echo</span> input &lt; file  <span class="comment">#获取输入流</span></span><br></pre></td></tr></table></figure><h2 id="Shell中的变量操作"><a href="#Shell中的变量操作" class="headerlink" title="Shell中的变量操作"></a><strong>Shell中的变量操作</strong></h2><blockquote><p>awk 指令<br>获取指定行数的资源名字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceNameTemp=$(awk <span class="string">'NR=="'</span><span class="variable">$i</span><span class="string">'" &#123;print;exit&#125;'</span> <span class="variable">$OutputFile</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取对应文件名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp=<span class="variable">$&#123;temp##*/&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>清空文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: &gt; <span class="string">"<span class="variable">$OutputFile</span>"</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a><strong>常用的Linux命令</strong></h2><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><blockquote><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p></blockquote><blockquote><p>基本结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;'</span> file</span><br></pre></td></tr></table></figure></p></blockquote><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中</p><p> <strong>工作原理</strong></p><blockquote><p>第一步：执行BEGIN{ commands }语句块中的语句；<br>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。<br>第三步：当读至输入流末尾时，执行END{ commands }语句块。</p></blockquote><p><strong>BEGIN</strong>语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p><p><strong>END</strong>语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p><p><strong>pattern</strong>语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p><blockquote><p>获取指定行数的文本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'NR=="'</span><span class="variable">$i</span><span class="string">'" &#123;print;exit&#125;'</span> file</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取文件的行数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print NR&#125;'</span> <span class="string">"file"</span>|tail -n1</span><br></pre></td></tr></table></figure></p></blockquote><p>关于awk的详细用法请参考 <a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">awk命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="https://hadesxiye.github.io/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://hadesxiye.github.io/tags/Shell/"/>
    
      <category term="Linux" scheme="https://hadesxiye.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
