<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hades</title>
  
  <subtitle>这个人很帅，什么都没留下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hadesxiye.github.io/"/>
  <updated>2019-07-01T12:25:27.170Z</updated>
  <id>https://hadesxiye.github.io/</id>
  
  <author>
    <name>Hades</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS砸壳-方法篇</title>
    <link href="https://hadesxiye.github.io/2019/06/28/iOS%E7%A0%B4%E5%A3%B3-%E6%96%B9%E6%B3%95%E7%AF%87/"/>
    <id>https://hadesxiye.github.io/2019/06/28/iOS破壳-方法篇/</id>
    <published>2019-06-28T05:52:53.000Z</published>
    <updated>2019-07-01T12:25:27.170Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/28/iOS破壳-方法篇/逆向.jpg"><p><center>在《iOS逆向工程》第二版中，介绍的是<code>dumpdecrypted</code>砸壳，这种方法繁琐复杂，还需要开2个终端做不同的操作，并且只能获取到二进制文件。<br>而 <code>AloneMonkey</code> 后来又开源了 <code>frida-ios-dump</code>基于<code>frida</code>的一键砸壳脚本，能直接获取砸壳后的<code>ipa</code>包。<br>并且在 <code>AloneMonkey</code> 开源的逆向插件<code>MonkeyDev</code>中自带了一键破壳。<br>先介绍下前两种方法的具体步骤，然后有兴趣的可以看下原理。</center><br><a id="more"></a></p><h2 id="frida-ios-dump安装步骤"><a href="#frida-ios-dump安装步骤" class="headerlink" title="frida-ios-dump安装步骤"></a>frida-ios-dump安装步骤</h2><p><code>github</code>地址：<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">https://github.com/AloneMonkey/frida-ios-dump</a></p><h3 id="1-macOS安装frida"><a href="#1-macOS安装frida" class="headerlink" title="1 macOS安装frida"></a>1 macOS安装frida</h3><p>在终端输入<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install frida</span><br></pre></td></tr></table></figure></p><p>如果失败尝试科学上网</p><h3 id="2-越狱设备安装frida"><a href="#2-越狱设备安装frida" class="headerlink" title="2 越狱设备安装frida"></a>2 越狱设备安装frida</h3><p>打开越狱手机，打开cydia，添加cydia源 <a href="https://build.frida.re/" target="_blank" rel="noopener">https://build.frida.re/</a> ，添加成功之后，搜索Frida插件，5s及以后的都是选择第一个安装。<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/frida.png" title="frida"></p><h3 id="3-验证frida安装"><a href="#3-验证frida安装" class="headerlink" title="3 验证frida安装"></a>3 验证frida安装</h3><p>确认设备和macOS都安装成功后<br>用USB连接设备和电脑<br>终端输入<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure></p><p>如果显示一堆 PID 和 NAME 就说明安装成功。<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616281198370.jpg"></p><h3 id="4-越狱设备安装OpenSSH"><a href="#4-越狱设备安装OpenSSH" class="headerlink" title="4 越狱设备安装OpenSSH"></a>4 越狱设备安装OpenSSH</h3><p>在<code>Cydia</code>中主页就能直接安装</p><h3 id="5-检查OpenSSH安装"><a href="#5-检查OpenSSH安装" class="headerlink" title="5 检查OpenSSH安装"></a>5 检查OpenSSH安装</h3><p>设备和电脑同一<code>wifi</code>，在终端中用<code>ssh</code>连接手机<code>ip</code><br>如我的手机<code>ip</code>是<code>192.168.43.155</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.43.155</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616287170428.jpg"><p><code>OpenSSH</code>初始密码是<code>alpine</code><br>登录成功后如图。<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616287791306.jpg"></p><h3 id="6-安装libmobiledevice和usbmuxd"><a href="#6-安装libmobiledevice和usbmuxd" class="headerlink" title="6 安装libmobiledevice和usbmuxd"></a>6 安装libmobiledevice和usbmuxd</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install libimobiledevice</span><br><span class="line">brew install usbmuxd</span><br></pre></td></tr></table></figure><p>安装完成之后，在终端将USB端口映射到未被使用的端口，这里使用2222<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br></pre></td></tr></table></figure></p><p>然后在新开一个终端，通过ssh连接本地的2222端口<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 root@localhost</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616299471051.jpg"><p>输入OpenSSH密码，即可登录。<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616299952047.jpg"></p><h3 id="7-检查python版本"><a href="#7-检查python版本" class="headerlink" title="7 检查python版本"></a>7 检查python版本</h3><p>打开终端<br>输入<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python  //或者 python -v</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616245953820.jpg"><p>输入<code>quit()</code>可退出<code>python</code>交互界面。</p><h3 id="8-安装frida-ios-dump"><a href="#8-安装frida-ios-dump" class="headerlink" title="8 安装frida-ios-dump"></a>8 安装frida-ios-dump</h3><p>进入 <a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">https://github.com/AloneMonkey/frida-ios-dump</a><br>如果是<code>python2.7</code>就使用<code>master</code>分支。<br><code>python3.x</code>使用 <code>3.x</code> 分支。<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616247707333.jpg"><br>不是以上版本自行安装对应版本<code>python</code>，并重复步骤<code>7</code>确认。</p><p>确认<code>python</code>版本和分支一致后，<code>clone</code>项目到本地<br>然后<code>cd</code>到该项目的根目录<br>执行安装依赖<br><strong>Python 2.7</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure></p><h2 id="frida-ios-dump-使用"><a href="#frida-ios-dump-使用" class="headerlink" title="frida-ios-dump 使用"></a>frida-ios-dump 使用</h2><h3 id="终端A"><a href="#终端A" class="headerlink" title="终端A"></a>终端A</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br></pre></td></tr></table></figure><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616390783179.jpg"><p>输完不要关闭<br>开一个新的终端<code>B</code></p><h3 id="终端B"><a href="#终端B" class="headerlink" title="终端B"></a>终端B</h3><p><strong>先用USB连接越狱设备</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 root@localhost</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616391217160.jpg"><p>输入<code>OpenSSH</code>密码，连接成功<br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616391642788.jpg"><br>此时终端<code>A`</code>B<code>都不要关闭新建终端</code>C`</p><h3 id="终端C"><a href="#终端C" class="headerlink" title="终端C"></a>终端C</h3><p><code>cd</code> 到<code>frida-ios-dump</code>项目的根目录<br>执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dump.py -l</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616393373594.jpg"><p>找到你要逆向的<code>APP</code><br>执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dump.py [上面对应的Name]  </span><br><span class="line">//或者</span><br><span class="line">./dump.py [上面对应的Identifier]</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616397771246.jpg"><p>成功，砸壳的<code>ipa</code>在<code>frida-ios-dump</code>的项目根目录中。</p><p>注意，如果你修改了OpenSSH的密码，或者修改了映射端口号，会砸壳失败，只需要修改 dump.py 里的这里为你修改后的内容就OK了<br></p><h2 id="dumpdecrypt破壳"><a href="#dumpdecrypt破壳" class="headerlink" title="dumpdecrypt破壳"></a><code>dumpdecrypt</code>破壳</h2><p><code>github</code>地址：<a href="https://github.com/VictorZhang2014/dumpdecrypted" target="_blank" rel="noopener">https://github.com/VictorZhang2014/dumpdecrypted</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1 <code>clone</code> 该库到本地<br>2 终端cd到该目录，执行<code>make</code>命令，会生成一个<code>dumpdecrypted.dylib</code><br>3 对<code>dumpdecrypted.dylib</code>进行签名<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 列出可签名证书</span></span><br><span class="line">security find-identity -v -p codesigning</span><br><span class="line"><span class="comment">## 为dumpecrypted.dylib签名</span></span><br><span class="line">codesign --force --verify --verbose --sign <span class="string">"iPhone Developer: xxx xxxx (xxxxxxxxxx)"</span> dumpdecrypted.dylib</span><br></pre></td></tr></table></figure></p><p>4 越狱设备安装<code>OpenSSH</code></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1 连接设备<br>在<code>终端A</code>中用<code>ssh</code>连接越狱设备<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.43.155</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616867674411.jpg"><p>2 定位<code>目标App</code><br>关闭设备全部进程，打开<code>目标App</code><br>执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e</span><br></pre></td></tr></table></figure></p><p>找到目标App <code>WeChat</code><br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616870994332.jpg"></p><blockquote><p><strong>记录前面的<code>PID</code> <code>4841</code> 和后面的app二进制路径<code>/var/containers/Bundle/Application/A0F664FC-E1CB-4977-A7A6-67AE7645A07F/WeChat.app/WeChat</code></strong></p></blockquote><p>3 获取<code>documents</code>所在目录<br>执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cycript -p 4841[上面记录的PID]</span><br></pre></td></tr></table></figure></p><p>进入<code>cycript</code><br><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616911877323.jpg"><br>输入<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSFileManager defaultManager]URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><img src="/2019/06/28/iOS破壳-方法篇/media/15616237472472/15616913126593.jpg"><blockquote><p><strong>记录Document路径<code>/var/mobile/Containers/Data/Application/9F41D812-273D-4E60-B323-8362F060A453/Documents/</code></strong></p></blockquote><p>4 拷贝<code>dumpdecrypted</code>到<code>document</code><br>开启新的终端B<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp [dumpdecrypted.dylib的路径]/dumpdecrypted.dylib root@[手机ip]:[上面记录的Document路径]dumpdecrypted.dylib</span><br><span class="line">//例子</span><br><span class="line">scp /Users/hades/Documents/dumpdecrypted-master/dumpdecrypted.dylib root@192.168.92.140:/var/mobile/Containers/Data/Application/9F41D812-273D-4E60-B323-8362F060A453/Documents/dumpdecrypted.dylib</span><br></pre></td></tr></table></figure></p><p>5 砸壳<br>在<code>终端A</code> <code>ctr+D</code>退出 <code>cycript</code><br><code>cd</code> 到上面记录的<code>document目录</code><br>执行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib [最开始记录的app二进制路径]</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib  /var/containers/Bundle/Application/A0F664FC-E1CB<span class="number">-4977</span>-A7A6<span class="number">-67</span>AE7645A07F/WeChat.app/WeChat</span><br></pre></td></tr></table></figure></p><p>执行完，在对应的<code>document目录</code>下会生成 <code>[appName].decrypted</code><br>6 拷贝<code>[appName].decrypted</code>到电脑<br>终端B<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp root@[手机ip]:[(appName).decrypted路径] [电脑目标路径]</span><br><span class="line">//例子</span><br><span class="line">scp root@192.168.92.140:/var/mobile/Containers/Data/Application/9F41D812-273D-4E60-B323-8362F060A453/Documents/WeChat.decrypted /Users/hades/Documents/</span><br></pre></td></tr></table></figure></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><div class="note info"><p>有的App二进制竟然是中文！而SSH中没法输入中文<br>解决方案：<a href="http://bbs.iosre.com/t/ios-os-ssh/8010" target="_blank" rel="noopener">http://bbs.iosre.com/t/ios-os-ssh/8010</a><br><br>SSH中空格的输入方式 \[空格]</p></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/28/iOS破壳-方法篇/逆向.jpg&quot;&gt;
&lt;p&gt;&lt;center&gt;在《iOS逆向工程》第二版中，介绍的是&lt;code&gt;dumpdecrypted&lt;/code&gt;砸壳，这种方法繁琐复杂，还需要开2个终端做不同的操作，并且只能获取到二进制文件。&lt;br&gt;而 &lt;code&gt;AloneMonkey&lt;/code&gt; 后来又开源了 &lt;code&gt;frida-ios-dump&lt;/code&gt;基于&lt;code&gt;frida&lt;/code&gt;的一键砸壳脚本，能直接获取砸壳后的&lt;code&gt;ipa&lt;/code&gt;包。&lt;br&gt;并且在 &lt;code&gt;AloneMonkey&lt;/code&gt; 开源的逆向插件&lt;code&gt;MonkeyDev&lt;/code&gt;中自带了一键破壳。&lt;br&gt;先介绍下前两种方法的具体步骤，然后有兴趣的可以看下原理。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS逆向" scheme="https://hadesxiye.github.io/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="ipa砸壳" scheme="https://hadesxiye.github.io/tags/ipa%E7%A0%B8%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>MD5算法（消息摘要）</title>
    <link href="https://hadesxiye.github.io/2019/06/26/%E7%AE%97%E6%B3%95MD5/"/>
    <id>https://hadesxiye.github.io/2019/06/26/算法MD5/</id>
    <published>2019-06-26T07:54:55.000Z</published>
    <updated>2019-07-01T12:19:16.650Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/26/算法MD5/MD5.png"><p><center>客户端在向服务端发送请求时，服务端会要求添加数字签名，其中就涉及到MD5算法，OC中实现MD5很简单，短短几行一搜就有，但MD5究竟是什么，为什么能用于数字签名呢？</center><br><a id="more"></a></p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p><code>MD5 Message-Digest Algorithm</code>，一种被广泛使用的消息摘要算法，可以产生出一个<code>128</code>位元（<code>16</code>位元组）的散列值（<code>hash value</code>），用于确保信息传输完整一致。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><code>压缩性</code>：任意长度的数据，算出的MD5值长度都是固定的。</li><li><code>容易计算</code>：从原数据计算出MD5值很容易。</li><li><code>抗修改性</code>：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li><code>强抗碰撞</code>：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li><code>文件校验</code>：如，客户端向服务端发送的数据，附加上原数据<code>MD5</code>的值，服务端就可验证是否是未篡改数据。</li><li><code>密码加密</code>：如，客户端存储用户密码，只存储用户密码的<code>MD5</code>值在数据库，用户再次登录只需将密码<code>MD5</code>值和数据库内的做比较即可。</li><li><code>数字签名</code>：如，客户端向服务器发送数据，并将原始数据按约定的算法进行运算，并将结果的<code>MD5</code>值一同发送给服务端，服务端在接受到数据后，只需要对原始数据做一样的操作，对比两个MD5值是否相同就能确保数据未篡改。</li><li><code>鉴权协议</code>：有个称为<code>挑战-认证模式</code>的鉴权协议：需要鉴权的一方，向将被鉴权的一方发送随机串（<code>挑战</code>），被鉴权方将该随机串和自己的鉴权口令字一起进行 <code>Hash</code> 运算后，返还鉴权方，鉴权方将收到的<code>Hash</code>值与在己端用该随机串和对方的鉴权口令字进行 <code>Hash</code> 运算的结果相比较（<code>认证</code>），如相同，则可在统计上认为对方拥有该口令字，即通过鉴权。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>普遍认为<code>MD5</code>是很安全，因为暴力破解的时间是一般人无法接受的。实际上如果把用户的密码<code>MD5</code>处理后再存储到数据库，其实是很不安全的。因为用户的密码是比较短的，而且很多用户的密码都使用生日，手机号码，身份证号码，电话号码等等。或者使用常用的一些吉利的数字，或者某个英文单词。如果我把常用的密码先<code>MD5</code>处理，把数据存储起来，然后再跟你的<code>MD5</code>结果匹配，这时我就有可能得到明文。比如某个<a href="http://www.cmd5.com/default.aspx" target="_blank" rel="noopener">MD5破解网站</a>，所以现在大多数网站密码的策略是强制要求用户使用数字大小写字母的组合的方式提高用户密码的安全度。</p><h2 id="唯一性？"><a href="#唯一性？" class="headerlink" title="唯一性？"></a>唯一性？</h2><p>首先<code>MD5</code>是数据摘要，得到的是<code>128</code>位数据，大致一想，显然比原数据少了很多很多，必然会出现多个原数据对应一个<code>MD5</code>的情况。只不过概率很低，而且如果还想把特定数据加入原数据就更难了。<br>网上的专业回答：</p><blockquote><p><code>md5</code>是用来做消息摘要的，不是加密算法，当然它可以作为普通的密码验证字串作为保存来屏蔽密码泄露。任何散列算法都是会碰撞的，毕竟将任意数据散列为一个固定长度的整数不出现重复是不可能的，但是为了验证数据有效性的消息摘要算法，需要保证散列的雪崩性——即是越是相近的数据散列出来的结果差异越大，由此特性来明确数据的差异能做到覆盖任何情况，毕竟两个差异过于明显的数据是不需要用散列来认证的。<br>举个例子来说，一般现在网上实现了很多网盘的功能的急速秒传就是通过散列来认证服务器是否存在相同文件，而且算法很多是<code>sha1</code>(和<code>md5</code>相同功能但是更加高级精确的散列算法)，但是就芸芸众多文件而已，不发生碰撞是不可能的，但是为什么还是可以用这个算法来认真，就是因为算法本身的雪崩性，两个发生碰撞的数据，其差异很有可能异常巨大，如果发生碰撞，只要稍微判断一下其它项即可解决，例如数据长度，数据首<code>N</code>个数据段或者尾N数据段进行匹配即可。</p></blockquote><h2 id="攻击MD5手段"><a href="#攻击MD5手段" class="headerlink" title="攻击MD5手段"></a>攻击MD5手段</h2><ul><li>预计算的哈希链集（<code>Precomputed hash chains</code>）</li><li>彩虹表（<code>rainbow table</code>）</li></ul><h2 id="防止MD5攻击手段"><a href="#防止MD5攻击手段" class="headerlink" title="防止MD5攻击手段"></a>防止MD5攻击手段</h2><p>在密码保护上，客户端一般只能做下对密码明文的加密，将加密的密码传给服务端或者存在本地数据库。<br>而在服务端的防护看链接<a href="https://www.zhihu.com/question/20060155" target="_blank" rel="noopener">知乎链接</a></p><h2 id="MD5的计算逻辑"><a href="#MD5的计算逻辑" class="headerlink" title="MD5的计算逻辑"></a>MD5的计算逻辑</h2><h3 id="大致逻辑"><a href="#大致逻辑" class="headerlink" title="大致逻辑"></a>大致逻辑</h3><p>MD5将输入的信息以512位分组来处理，且每一分组又被划分为16个32位子分组，​经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h4 id="第一步：填充"><a href="#第一步：填充" class="headerlink" title="第一步：填充"></a>第一步：填充</h4><p>如果输入信息的长度(<a href="https://baike.baidu.com/item/%E6%AF%94%E7%89%B9%28bit%29/7675114?fr=aladdin" target="_blank" rel="noopener">bit</a>)对<code>512</code>求余的结果不等于<code>448</code>，就需要填充使得对<code>512</code>求余的结果等于<code>448</code>。<br> ​填充的方法是填充<code>1</code>个<code>1</code>和<code>n</code>个<code>0</code>。填充完后，信息的长度就为<code>N*512+448</code>(bit)；<br> ​</p><h4 id="​第二步：记录信息长度"><a href="#​第二步：记录信息长度" class="headerlink" title="​第二步：记录信息长度"></a>​第二步：记录信息长度</h4><p>用<code>64</code>位来存储填充前信息长度。这<code>64</code>位加在第一步结果的后面，这样信息长度就变为<code>N*512+448+64=(N+1)*512</code>位。</p><h4 id="第三步：装入标准的幻数（四个整数参数）"><a href="#第三步：装入标准的幻数（四个整数参数）" class="headerlink" title="第三步：装入标准的幻数（四个整数参数）"></a>第三步：装入标准的幻数（四个整数参数）</h4><p>标准的幻数（物理顺序）是（<code>A=(01234567)16</code>，<code>B=(89ABCDEF)16</code>，<code>C=(FEDCBA98)16</code>，<code>D=(76543210)16</code>）。如果在程序中定义应该是（<code>A=0x67452301</code>，<code>B=0xEFCDAB89</code>，<code>C=0x98BADCFE</code>，<code>D=0x10325476</code>）。</p><h4 id="第四步：四轮循环运算"><a href="#第四步：四轮循环运算" class="headerlink" title="第四步：四轮循环运算"></a>第四步：四轮循环运算</h4><p>循环的次数是分组的个数（<code>N+1</code>）<br>（1）将每一<code>512</code>字节细分成<code>16</code>个小组，每个小组<code>64</code>位（<code>8</code>个字节）<br>（2）先认识四个线性函数(<code>&amp;</code>是与,<code>|</code>是或,<code>~</code>是非,<code>^</code>是异或)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z)  </span><br><span class="line">G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z))  </span><br><span class="line">H(X,Y,Z)=X^Y^Z  </span><br><span class="line">I(X,Y,Z)=Y^(X|(~Z))</span><br></pre></td></tr></table></figure></p><p>（3）设<code>Mj</code>表示消息的第<code>j</code>个子分组（从0到15），<code>&lt;&lt;&lt;s</code>表示循环左移<code>s</code>位，则四种操作为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s)  </span><br><span class="line">GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s)  </span><br><span class="line">HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s)  </span><br><span class="line">II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s)</span><br></pre></td></tr></table></figure><p> （4）四轮运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">第一轮  </span><br><span class="line"> a=FF(a,b,c,d,M0,<span class="number">7</span>,<span class="number">0xd76aa478</span>)  </span><br><span class="line"> b=FF(d,a,b,c,M1,<span class="number">12</span>,<span class="number">0xe8c7b756</span>)  </span><br><span class="line"> c=FF(c,d,a,b,M2,<span class="number">17</span>,<span class="number">0x242070db</span>)  </span><br><span class="line"> d=FF(b,c,d,a,M3,<span class="number">22</span>,<span class="number">0xc1bdceee</span>)  </span><br><span class="line"> a=FF(a,b,c,d,M4,<span class="number">7</span>,<span class="number">0xf57c0faf</span>)  </span><br><span class="line"> b=FF(d,a,b,c,M5,<span class="number">12</span>,<span class="number">0x4787c62a</span>)  </span><br><span class="line"> c=FF(c,d,a,b,M6,<span class="number">17</span>,<span class="number">0xa8304613</span>)  </span><br><span class="line"> d=FF(b,c,d,a,M7,<span class="number">22</span>,<span class="number">0xfd469501</span>)  </span><br><span class="line"> a=FF(a,b,c,d,M8,<span class="number">7</span>,<span class="number">0x698098d8</span>)  </span><br><span class="line"> b=FF(d,a,b,c,M9,<span class="number">12</span>,<span class="number">0x8b44f7af</span>)  </span><br><span class="line"> c=FF(c,d,a,b,M10,<span class="number">17</span>,<span class="number">0xffff5bb1</span>)  </span><br><span class="line"> d=FF(b,c,d,a,M11,<span class="number">22</span>,<span class="number">0x895cd7be</span>)  </span><br><span class="line"> a=FF(a,b,c,d,M12,<span class="number">7</span>,<span class="number">0x6b901122</span>)  </span><br><span class="line"> b=FF(d,a,b,c,M13,<span class="number">12</span>,<span class="number">0xfd987193</span>)  </span><br><span class="line"> c=FF(c,d,a,b,M14,<span class="number">17</span>,<span class="number">0xa679438e</span>)  </span><br><span class="line"> d=FF(b,c,d,a,M15,<span class="number">22</span>,<span class="number">0x49b40821</span>)  </span><br><span class="line">  </span><br><span class="line">第二轮  </span><br><span class="line"> a=GG(a,b,c,d,M1,<span class="number">5</span>,<span class="number">0xf61e2562</span>)  </span><br><span class="line"> b=GG(d,a,b,c,M6,<span class="number">9</span>,<span class="number">0xc040b340</span>)  </span><br><span class="line"> c=GG(c,d,a,b,M11,<span class="number">14</span>,<span class="number">0x265e5a51</span>)  </span><br><span class="line"> d=GG(b,c,d,a,M0,<span class="number">20</span>,<span class="number">0xe9b6c7aa</span>)  </span><br><span class="line"> a=GG(a,b,c,d,M5,<span class="number">5</span>,<span class="number">0xd62f105d</span>)  </span><br><span class="line"> b=GG(d,a,b,c,M10,<span class="number">9</span>,<span class="number">0x02441453</span>)  </span><br><span class="line"> c=GG(c,d,a,b,M15,<span class="number">14</span>,<span class="number">0xd8a1e681</span>)  </span><br><span class="line"> d=GG(b,c,d,a,M4,<span class="number">20</span>,<span class="number">0xe7d3fbc8</span>)  </span><br><span class="line"> a=GG(a,b,c,d,M9,<span class="number">5</span>,<span class="number">0x21e1cde6</span>)  </span><br><span class="line"> b=GG(d,a,b,c,M14,<span class="number">9</span>,<span class="number">0xc33707d6</span>)  </span><br><span class="line"> c=GG(c,d,a,b,M3,<span class="number">14</span>,<span class="number">0xf4d50d87</span>)  </span><br><span class="line"> d=GG(b,c,d,a,M8,<span class="number">20</span>,<span class="number">0x455a14ed</span>)  </span><br><span class="line"> a=GG(a,b,c,d,M13,<span class="number">5</span>,<span class="number">0xa9e3e905</span>)  </span><br><span class="line"> b=GG(d,a,b,c,M2,<span class="number">9</span>,<span class="number">0xfcefa3f8</span>)  </span><br><span class="line"> c=GG(c,d,a,b,M7,<span class="number">14</span>,<span class="number">0x676f02d9</span>)  </span><br><span class="line"> d=GG(b,c,d,a,M12,<span class="number">20</span>,<span class="number">0x8d2a4c8a</span>)  </span><br><span class="line">  </span><br><span class="line">第三轮  </span><br><span class="line"> a=HH(a,b,c,d,M5,<span class="number">4</span>,<span class="number">0xfffa3942</span>)  </span><br><span class="line"> b=HH(d,a,b,c,M8,<span class="number">11</span>,<span class="number">0x8771f681</span>)  </span><br><span class="line"> c=HH(c,d,a,b,M11,<span class="number">16</span>,<span class="number">0x6d9d6122</span>)  </span><br><span class="line"> d=HH(b,c,d,a,M14,<span class="number">23</span>,<span class="number">0xfde5380c</span>)  </span><br><span class="line"> a=HH(a,b,c,d,M1,<span class="number">4</span>,<span class="number">0xa4beea44</span>)  </span><br><span class="line"> b=HH(d,a,b,c,M4,<span class="number">11</span>,<span class="number">0x4bdecfa9</span>)  </span><br><span class="line"> c=HH(c,d,a,b,M7,<span class="number">16</span>,<span class="number">0xf6bb4b60</span>)  </span><br><span class="line"> d=HH(b,c,d,a,M10,<span class="number">23</span>,<span class="number">0xbebfbc70</span>)  </span><br><span class="line"> a=HH(a,b,c,d,M13,<span class="number">4</span>,<span class="number">0x289b7ec6</span>)  </span><br><span class="line"> b=HH(d,a,b,c,M0,<span class="number">11</span>,<span class="number">0xeaa127fa</span>)  </span><br><span class="line"> c=HH(c,d,a,b,M3,<span class="number">16</span>,<span class="number">0xd4ef3085</span>)  </span><br><span class="line"> d=HH(b,c,d,a,M6,<span class="number">23</span>,<span class="number">0x04881d05</span>)  </span><br><span class="line"> a=HH(a,b,c,d,M9,<span class="number">4</span>,<span class="number">0xd9d4d039</span>)  </span><br><span class="line"> b=HH(d,a,b,c,M12,<span class="number">11</span>,<span class="number">0xe6db99e5</span>)  </span><br><span class="line"> c=HH(c,d,a,b,M15,<span class="number">16</span>,<span class="number">0x1fa27cf8</span>)  </span><br><span class="line"> d=HH(b,c,d,a,M2,<span class="number">23</span>,<span class="number">0xc4ac5665</span>)  </span><br><span class="line">  </span><br><span class="line">第四轮  </span><br><span class="line"> a=II(a,b,c,d,M0,<span class="number">6</span>,<span class="number">0xf4292244</span>)  </span><br><span class="line"> b=II(d,a,b,c,M7,<span class="number">10</span>,<span class="number">0x432aff97</span>)  </span><br><span class="line"> c=II(c,d,a,b,M14,<span class="number">15</span>,<span class="number">0xab9423a7</span>)  </span><br><span class="line"> d=II(b,c,d,a,M5,<span class="number">21</span>,<span class="number">0xfc93a039</span>)  </span><br><span class="line"> a=II(a,b,c,d,M12,<span class="number">6</span>,<span class="number">0x655b59c3</span>)  </span><br><span class="line"> b=II(d,a,b,c,M3,<span class="number">10</span>,<span class="number">0x8f0ccc92</span>)  </span><br><span class="line"> c=II(c,d,a,b,M10,<span class="number">15</span>,<span class="number">0xffeff47d</span>)  </span><br><span class="line"> d=II(b,c,d,a,M1,<span class="number">21</span>,<span class="number">0x85845dd1</span>)  </span><br><span class="line"> a=II(a,b,c,d,M8,<span class="number">6</span>,<span class="number">0x6fa87e4f</span>)  </span><br><span class="line"> b=II(d,a,b,c,M15,<span class="number">10</span>,<span class="number">0xfe2ce6e0</span>)  </span><br><span class="line"> c=II(c,d,a,b,M6,<span class="number">15</span>,<span class="number">0xa3014314</span>)  </span><br><span class="line"> d=II(b,c,d,a,M13,<span class="number">21</span>,<span class="number">0x4e0811a1</span>)  </span><br><span class="line"> a=II(a,b,c,d,M4,<span class="number">6</span>,<span class="number">0xf7537e82</span>)  </span><br><span class="line"> b=II(d,a,b,c,M11,<span class="number">10</span>,<span class="number">0xbd3af235</span>)  </span><br><span class="line"> c=II(c,d,a,b,M2,<span class="number">15</span>,<span class="number">0x2ad7d2bb</span>)  </span><br><span class="line"> d=II(b,c,d,a,M9,<span class="number">21</span>,<span class="number">0xeb86d391</span>)</span><br></pre></td></tr></table></figure><p>（5）每轮循环后，将<code>A</code>，<code>B</code>，<code>C</code>，<code>D</code>分别加上<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，然后进入下一循环<br>所有这些完成之后，将<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>分别在原来基础上再加上<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>。<br>即<code>a = a + A</code>，<code>b = b + B</code>，<code>c = c + C</code>，<code>d = d + D</code><br>然后用下一分组数据继续运行以上算法。</p><h4 id="第五步：输出"><a href="#第五步：输出" class="headerlink" title="第五步：输出"></a>第五步：输出</h4><p> 最后的输出是<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>的级联。</p><h2 id="OC实现MD5"><a href="#OC实现MD5" class="headerlink" title="OC实现MD5"></a>OC实现MD5</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *) md5</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cStr = [<span class="keyword">self</span> UTF8String];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> digest[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5( cStr, strlen(cStr), digest );</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableString</span> *output = [<span class="built_in">NSMutableString</span> stringWithCapacity:CC_MD5_DIGEST_LENGTH * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CC_MD5_DIGEST_LENGTH; i++)</span><br><span class="line">        [output appendFormat:<span class="string">@"%02x"</span>, digest[i]];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/26/算法MD5/MD5.png&quot;&gt;
&lt;p&gt;&lt;center&gt;客户端在向服务端发送请求时，服务端会要求添加数字签名，其中就涉及到MD5算法，OC中实现MD5很简单，短短几行一搜就有，但MD5究竟是什么，为什么能用于数字签名呢？&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hadesxiye.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="MD5" scheme="https://hadesxiye.github.io/tags/MD5/"/>
    
      <category term="信息安全" scheme="https://hadesxiye.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Runtime</title>
    <link href="https://hadesxiye.github.io/2019/06/02/Runtime/"/>
    <id>https://hadesxiye.github.io/2019/06/02/Runtime/</id>
    <published>2019-06-02T06:59:26.000Z</published>
    <updated>2019-06-26T08:16:38.399Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/02/Runtime/runtime.png"><center>Runtime相关介绍</center><a id="more"></a><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>数据结构<ul><li><code>objc_object</code></li><li><code>objc_class</code></li><li><code>isa</code>指针</li><li><code>method_t</code></li></ul></li><li>类对象与元类对象</li><li>消息传递</li><li>方法缓存 </li><li>消息转发</li><li><code>Method-Swizzling</code> 可做代码混淆</li><li>动态添加方法</li><li>动态方法解析</li></ul><h2 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h2><img src="/2019/06/02/Runtime/1557752732104.png"><h2 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h2><img src="/2019/06/02/Runtime/1557752999524.png"><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><img src="/2019/06/02/Runtime/1557797910085.png"><div class="note info"><p><br><strong><code>isa</code>是什么？</strong><br><code>isa</code>首先分为指针型<code>isa</code>和非指针型<code>isa</code><br>对于<code>ARM64</code>架构下，只需要三四十位就能代表<code>Class</code>的地址，剩余的位数就可以存储其他数据。以此达到节省内存的目的。<br></p></div><h2 id="isa指向"><a href="#isa指向" class="headerlink" title="isa指向"></a>isa指向</h2><img src="/2019/06/02/Runtime/1557798381294.png"><h2 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h2><ul><li>用于<code>快速</code>查找方法执行函数</li><li>是可<code>增量扩展</code>的<code>哈希表</code>结构</li><li>是<code>局部性原理</code>的最佳应用<ul><li>局部性原理的简单说明：一个类中部分方法使用频次较高，就将这些方法放入缓存中，这样下次调用方法，直接从缓存中读取的概率就比较高。<img src="/2019/06/02/Runtime/1557903750536.png"><code>cache_t</code>的数据结构<br>是个数组类型，成员是bucket_t类型<br><code>bucket_t</code>包含 <code>key</code> 和 <code>IMP</code><br><code>key</code>就是方法选择器的名称，通过<code>SEL</code>调用<br><code>IMP</code>是个无类型的函数指针<br>根据<code>key</code>，用哈希查找算法，定位当前<code>key</code>所对应的<code>bucket_t</code>类型的数据结构，位于数据哪个位置，然后根据<code>IMP</code>调用函数</li></ul></li></ul><h2 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h2><ul><li><code>class_data_bits_t</code>主要是对<code>class_rw_t</code>的封装</li><li><code>class_rw_t</code>代表了类相关的读写信息（如分类，协议，方法，属性等）、对<code>class_ro_t</code>的封装（<code>readonly</code> 成员变量，内部方法等）</li><li><code>class_ro_t</code>代表了类相关的只读信息</li></ul><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><img src="/2019/06/02/Runtime/1558007614045.png"><p>一般情况下，都是存储分类方法添加的内容</p><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><img src="/2019/06/02/Runtime/1558008204799.png"><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><img src="/2019/06/02/Runtime/1558008401781.png"><h3 id="Type-Encodings"><a href="#Type-Encodings" class="headerlink" title="Type Encodings"></a>Type Encodings</h3><ul><li><code>const char* types;</code><img src="/2019/06/02/Runtime/1558008700782.png"></li></ul><h2 id="整体数据结构"><a href="#整体数据结构" class="headerlink" title="整体数据结构"></a>整体数据结构</h2><img src="/2019/06/02/Runtime/1558355463856.png"><hr><h1 id="对象、类对象、元类对象"><a href="#对象、类对象、元类对象" class="headerlink" title="对象、类对象、元类对象"></a>对象、类对象、元类对象</h1><ul><li>类对象存储实例方法列表等信息</li><li>元类对象存储类方法列表等信息<img src="/2019/06/02/Runtime/1558359358555.png"></li></ul><div class="note info"><p><br><strong>Q:</strong>类对象和元类对象有什么区别？<br><strong>A:</strong>1.实例对象可以通过isa指针找到类对象，访问实例方法列表并通过类的isa指针找到元类对象，访问类方法列表等。<br> 2.任何一个元类对象的isa指针，都指向根元类对象，包括根元类对象本身。<br><br><strong>Q:</strong>如果我们调用的一个类方法，没有对应的实现，但是根类有同名的实例方法的时候，这时候会不会发生崩溃，会不会产生实际调用？<br><strong>A:</strong> 由于根元类的superClass指针，指向根类，所以会调用根类的同名实例方法。<br></p></div><p> 消息传递简述<br> 调用实例方法<code>a</code>，根据<code>isa</code>指针，找到对应的类的方法列表，然后找父类，然后父类，最后<code>nil</code>。<br> 调用类方法<code>a</code>，通过类的<code>isa</code>指针，找到对应的类，然后找类的方法列表，然后根据<code>superClass</code>指针找父类的，到根类，最后<code>nil</code>。</p><h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">void</span> <span class="comment">/* id self,SEL op, ... */</span>)</span><br></pre></td></tr></table></figure><img src="/2019/06/02/Runtime/1558359712388.png"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSendSuper(<span class="keyword">void</span> <span class="comment">/* struct objc_super *super,SEL op, ...*/</span>)</span><br></pre></td></tr></table></figure><img src="/2019/06/02/Runtime/1558359927515.png"><img src="/2019/06/02/Runtime/1558360327967.png"><img src="/2019/06/02/Runtime/1558360366032.png"><div class="note info"><p><br>&gt;答案：都是 Phone<br>&gt;理由：因为objc_msgSend和objc_msgSendSuper的消息接收者，都是self这个实例对象。<br>&gt;objc_msgSendSuper只是代表，寻找方法从父类开始查找，而class这个方法是NSObject的方法，父类Mobile中也没有，所以最终都是Phone<br></p></div><h2 id="缓存查找"><a href="#缓存查找" class="headerlink" title="缓存查找"></a>缓存查找</h2><img src="/2019/06/02/Runtime/1558437185524.png"><h2 id="当前类中查找"><a href="#当前类中查找" class="headerlink" title="当前类中查找"></a>当前类中查找</h2><ul><li>对于已排好序的列表，采用二分查找算法查找方法对应执行函数</li><li>对于没有排序的列表，采用一般遍历查找方法对应执行函数</li></ul><h3 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找/折半查找"></a>二分查找/折半查找</h3><ul><li>1.必须采用顺序存储结构。</li><li>2.必须按关键字大小有序排列。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> a: [T], key: T)</span></span> -&gt; <span class="type">Int</span>? &#123;    </span><br><span class="line">    <span class="keyword">var</span> lowerBound = <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">var</span> upperBound = a.<span class="built_in">count</span>    </span><br><span class="line">    <span class="keyword">while</span> lowerBound &lt; upperBound &#123;        </span><br><span class="line">        <span class="keyword">let</span> midIndex = lowerBound + (upperBound - lowerBound) / <span class="number">2</span>        </span><br><span class="line">        <span class="keyword">if</span> a[midIndex] == key &#123;            </span><br><span class="line">            <span class="keyword">return</span> midIndex        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> a[midIndex] &lt; key &#123;            </span><br><span class="line">            lowerBound = midIndex + <span class="number">1</span>        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            upperBound = midIndex        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="父类逐级查找"><a href="#父类逐级查找" class="headerlink" title="父类逐级查找"></a>父类逐级查找</h2><img src="/2019/06/02/Runtime/1558438196945.png"><h1 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h1><p>1 动态方法解析</p><ul><li>向当前类发送<code>resolveInstanceMethod:</code>信号，检查是否动态向该类添加了方法。 </li><li><code>resolveInstanceMethod:</code>参数是 <code>SEL</code>类型 ，返回<code>BOOL</code> 。告诉系统是否解决这个方法的实现。</li></ul><p>2 快速消息转发 </p><ul><li>检查该类是否实现了<code>forwardingTargetForSelector:</code> 方法，若实现了则调用这个方法。若该方法返回值对象非<code>nil</code>或非<code>self</code>，则向该返回对象重新发送消息。 </li><li><code>forwardingTargetForSelector:</code>参数是 <code>SEL</code>类型，返回 <code>id</code>。告诉系统这个方法的处理对象是谁。</li></ul><p>3 标准消息转发 </p><ul><li>为了达到间接实现多继承目的的方法，可利用消息转发</li><li><code>methodSignatureForSelector:</code>参数是 <code>SEL</code>类型，返回 <code>id</code> 方法签名。是包含 方法选择器的返回值类型，参数个数和参数类型的一个封装。并取到返回的方法签名用于生成 <code>NSInvocation</code>对象</li></ul><p>4 消息转发机制</p><ul><li><code>forwardInvocation</code><img src="/2019/06/02/Runtime/1558445548665.png"></li></ul><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method-Swizzling"></a>Method-Swizzling</h1><img src="/2019/06/02/Runtime/1558862620685.png"><p>简单的来说。就是交换了方法的实现</p><p><code>RuntimeObject.h</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>RuntimeObject.m</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"RuntimeObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="comment">//获取test方法</span></span><br><span class="line">    Method test = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(test));</span><br><span class="line">    <span class="comment">//获取otherTest的结构体</span></span><br><span class="line">    Method otherTest = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(otherTest));</span><br><span class="line">    <span class="comment">//交换方法实现</span></span><br><span class="line">    method_exchangeImplementations(test, otherTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest&#123;</span><br><span class="line">    <span class="comment">//实际上是调用了test的具体实现</span></span><br><span class="line">    [<span class="keyword">self</span> otherTest];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"otherTest"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际业务场景：比如很多时候需要记录<code>viewWillAppear</code> <code>viewDidLoad</code>的操作，不可能每个页面去添加，可以替换系统的方法，然后加一句代码，就能统计到。</p><h1 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是text方法。打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//动态添加test方法实现</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(test), testImp, <span class="string">"v@:"</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果返回YES，则消息转发流程就结束了。为了看后续效果，先返回NO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//返回父类的默认调用</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h1><p><code>@dynamic</code></p><ul><li>动态运行时语言将函数决议推迟到运行时。</li><li>编译时语言在编译期进行函数决议。</li></ul><h1 id="Runtime实战"><a href="#Runtime实战" class="headerlink" title="Runtime实战"></a>Runtime实战</h1><div class="note info"><p><br> <strong><code>[obj foo]</code> 和 <code>objc_msgSend()</code> 函数之间有什么关系？</strong><br> - <code>[obj foo]</code> 等于 <code>ojc_mesSend(obj,foo)</code> <code>&quot;v@:&quot;</code><br><br> <strong><code>runtime</code>如何通过<code>Selector</code>找到对应<code>IMP</code>地址的？</strong><br> - 首先找到当前实例变量对应的类，去这个类的方法缓存中查找方法，未命中就去类的方法列表查找，再去父类的方法缓存中查找，以此类推，如果最后都没找到，就返回<code>nil</code>。<br><br> <strong>能否向编译后的类中增加实例变量？</strong><br> 不能。因为编译后的实例变量存储在<code>class_ro_t</code>中，是只读的。<br> 但能在动态添加的方法中添加实例变量。<br></p></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/02/Runtime/runtime.png&quot;&gt;
&lt;center&gt;Runtime相关介绍&lt;/center&gt;
    
    </summary>
    
      <category term="Object-C" scheme="https://hadesxiye.github.io/categories/Object-C/"/>
    
    
  </entry>
  
  <entry>
    <title>UIView圆形动画</title>
    <link href="https://hadesxiye.github.io/2019/03/02/UIView%E5%9C%86%E5%BD%A2%E5%8A%A8%E7%94%BB/"/>
    <id>https://hadesxiye.github.io/2019/03/02/UIView圆形动画/</id>
    <published>2019-03-02T07:26:36.000Z</published>
    <updated>2019-06-26T08:18:01.903Z</updated>
    
    <content type="html"><![CDATA[<center>自己封装的一个动画效果=。=</center><a id="more"></a><h1 id="UIView圆圈显示隐藏动画"><a href="#UIView圆圈显示隐藏动画" class="headerlink" title="UIView圆圈显示隐藏动画"></a>UIView圆圈显示隐藏动画</h1><p>在一些日常的开发中，常用的动画有：</p><ul><li><code>UIView Animation</code>配合<code>UIView</code>的<code>frame</code>、<code>alpha</code>、<code>transform</code>等属性变化，能几行代码实现渐入、渐出、缩放、位移、旋转等常用动画效果。</li><li><code>Spring</code>能一句代码实现弹簧动画。</li><li><code>animationKeyframes</code>可以实现颜色渐变动画。</li><li><code>transition</code>动画可以实现翻转动画。</li></ul><hr><p>对这些动画组合使用能满足很多日常的需求。<br>简单实用但不够炫酷。<br>今天先介绍一个简单的实例，效果如下：<br><img src="" alt="HZAnimation"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><blockquote><ul><li>首先获取并记录动画对象<code>View</code>的<code>frame</code>和其子视图的<code>frame</code>。</li><li>计算出以动画对象View的斜对角线作为直径，中心为圆点。</li><li>使用<code>UIBezierPath</code>将<strong>初始状态</strong>和<strong>最终状态</strong>画出来。（这里显示的<strong>初始状态</strong>是圆点，<strong>最终状态</strong>是斜对角线为直径，中点为圆心的圆。隐藏时的以此类推）。</li><li>创建一个关于<code>Path</code>的<code>CABasicAnimation</code>动画从<strong>初始状态</strong>到<strong>最终状态</strong>。</li><li>将子视图的<code>frame</code>设置为父视图的中心。</li><li>为动画对象的<code>.layer.mask</code>属性添加一个<code>layer</code>，并添加<code>CABasicAnimation</code>动画，同时用<code>UIView animation</code>实现子视图复原动画。</li></ul></blockquote><blockquote><p><strong>显示动画完成，隐藏以此类推咯。</strong></p></blockquote><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建一个<code>UIView</code>的<code>Category</code>：<code>HZAnimation</code></p><h3 id="UIView-HZAnimation-h"><a href="#UIView-HZAnimation-h" class="headerlink" title="UIView+HZAnimation.h"></a><code>UIView+HZAnimation.h</code></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">HZAnimation</span>)&lt;<span class="title">CAAnimationDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^HZAnimationBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 圆形遮罩显示动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)HZCircleShowAnimationDuration:(<span class="built_in">NSTimeInterval</span>)animationTime Completed:(HZAnimationBlock)completed;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 圆形遮罩隐藏动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)HZCircleHideAnimationDuration:(<span class="built_in">NSTimeInterval</span>)animationTime Completed:(HZAnimationBlock)completed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><h3 id="UIView-HZAnimation-m"><a href="#UIView-HZAnimation-m" class="headerlink" title="UIView+HZAnimation.m"></a><code>UIView+HZAnimation.m</code></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView+HZAnimation.m</span></span><br><span class="line"><span class="comment">//  HZViewAnimationDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by 王浩祯 on 2019/4/9.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Hades. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"UIView+HZAnimation.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">HZAnimation</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)HZCircleShowAnimationDuration:(<span class="built_in">NSTimeInterval</span>)animationTime Completed:(HZAnimationBlock)completed&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> HZAnimationShowDuration:animationTime CustomColor:<span class="keyword">self</span>.backgroundColor SubviewsAnimation:<span class="literal">YES</span> Completed:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">            completed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)HZCircleHideAnimationDuration:(<span class="built_in">NSTimeInterval</span>)animationTime Completed:(HZAnimationBlock)completed&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> HZAnimationHideDuration:animationTime CustomColor:<span class="keyword">self</span>.backgroundColor SubviewsAnimation:<span class="literal">YES</span> Completed:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">            completed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark -- HZAnimation detail ------ =͟͟͞͞⊂(⊂ 'ω')</span></span><br><span class="line">- (<span class="keyword">void</span>)HZAnimationShowDuration:(<span class="built_in">NSTimeInterval</span>)animationTime CustomColor:(<span class="built_in">UIColor</span> *)color SubviewsAnimation:(<span class="built_in">BOOL</span>)isSubviewsAnimation Completed:(HZAnimationBlock)completed&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录父视图的属性</span></span><br><span class="line">    <span class="built_in">UIColor</span>* originalColor = <span class="keyword">self</span>.backgroundColor;</span><br><span class="line">    <span class="built_in">CGFloat</span> originalWid = <span class="keyword">self</span>.frame.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> originalHei = <span class="keyword">self</span>.frame.size.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> animationViewLength;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span>* subviewsFrameArr = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算动画视图圆的半径</span></span><br><span class="line">    animationViewLength = sqrt(originalWid * originalWid + originalHei * originalHei)/<span class="number">2</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制路径</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span>* originalCircle = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span>, originalHei/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span>* finalCircle = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span> - animationViewLength, originalHei/<span class="number">2</span> - animationViewLength, animationViewLength * <span class="number">2</span>, animationViewLength * <span class="number">2</span>)];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//创建一个关于Path的CABasicAnimation动画从originalCircle到finalCircle</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *hzAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"path"</span>];</span><br><span class="line">    hzAnimation.fromValue = (__bridge <span class="keyword">id</span>)(originalCircle.CGPath);</span><br><span class="line">    hzAnimation.toValue = (__bridge <span class="keyword">id</span>)((finalCircle.CGPath));</span><br><span class="line">    hzAnimation.duration = animationTime;</span><br><span class="line">    hzAnimation.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//填充效果：动画结束后，动画将保持最后的表现状态</span></span><br><span class="line">    hzAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">    hzAnimation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//记录子视图frame并修改</span></span><br><span class="line">    <span class="keyword">if</span> (isSubviewsAnimation) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span>* viewObj <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</span><br><span class="line"></span><br><span class="line">            [subviewsFrameArr addObject:[<span class="built_in">NSValue</span> valueWithCGRect:viewObj.frame]];</span><br><span class="line">            viewObj.frame = <span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span>, originalHei/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给mask属性赋值一个layer</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *maskLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.layer.mask = maskLayer;</span><br><span class="line">    <span class="keyword">self</span>.layer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">    [maskLayer addAnimation:hzAnimation forKey:<span class="string">@"path"</span>];</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:animationTime animations:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSubviewsAnimation) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> subviewsNumber = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.subviews.count; i ++) &#123;</span><br><span class="line">                <span class="built_in">UIView</span>* viewObj = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">              </span><br><span class="line">                viewObj.frame = [subviewsFrameArr[subviewsNumber] <span class="built_in">CGRectValue</span>];</span><br><span class="line">                subviewsNumber ++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = originalColor;</span><br><span class="line">        completed();</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)HZAnimationHideDuration:(<span class="built_in">NSTimeInterval</span>)animationTime CustomColor:(<span class="built_in">UIColor</span> *)color SubviewsAnimation:(<span class="built_in">BOOL</span>)isSubviewsAnimation Completed:(HZAnimationBlock)completed&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录父视图的属性</span></span><br><span class="line">    <span class="built_in">CGFloat</span> originalWid = <span class="keyword">self</span>.frame.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> originalHei = <span class="keyword">self</span>.frame.size.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> animationViewLength;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算动画视图圆的半径</span></span><br><span class="line">    animationViewLength = sqrt(originalWid * originalWid + originalHei * originalHei)/<span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//绘制路径</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span>* originalCircle = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span> - animationViewLength, originalHei/<span class="number">2</span> - animationViewLength, animationViewLength * <span class="number">2</span>, animationViewLength * <span class="number">2</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span>* finalCircle = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span>, originalHei/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *maskLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    maskLayer.path = finalCircle.CGPath;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.layer.mask = maskLayer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个关于Path的CABasicAnimation动画从originalCircle到finalCircle</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *hzAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"path"</span>];</span><br><span class="line">    hzAnimation.fromValue = (__bridge <span class="keyword">id</span>)(originalCircle.CGPath);</span><br><span class="line">    hzAnimation.toValue = (__bridge <span class="keyword">id</span>)((finalCircle.CGPath));</span><br><span class="line">    hzAnimation.duration = animationTime;</span><br><span class="line">    hzAnimation.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.layer.masksToBounds = <span class="literal">YES</span>;</span><br><span class="line">    [maskLayer addAnimation:hzAnimation forKey:<span class="string">@"path"</span>];</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:animationTime animations:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSubviewsAnimation) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UIView</span>* viewObj <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</span><br><span class="line">                viewObj.frame = <span class="built_in">CGRectMake</span>(originalWid/<span class="number">2</span>, originalHei/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        </span><br><span class="line">        completed();</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - CABasicAnimation的Delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"caani end"</span>);</span><br><span class="line">    <span class="comment">//清除 fromVC 的 mask</span></span><br><span class="line">    <span class="keyword">self</span>.layer.mask = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="meta">#your UIView obj#&gt; HZAnimationShowDuration:<span class="meta-string">&lt;#AnimationDuration#&gt;</span>  Completed:^&#123;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Animation completed"</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&lt;#your UIView obj#&gt; HZAnimationHideDuration:&lt;#AnimationDuration#&gt; Completed:^&#123;</span><br><span class="line">        //TODO: remove view from superView</span><br><span class="line">        //other thing</span><br><span class="line">        NSLog(@&quot;Animation completed&quot;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h2 id="项目DEMO"><a href="#项目DEMO" class="headerlink" title="项目DEMO"></a>项目DEMO</h2><p><a href="https://github.com/Hadesxiye/HZAnimation" target="_blank" rel="noopener">HZAniamtion</a><br><strong>给个star吧！！铁汁!</strong><img src="/2019/03/02/UIView圆形动画/qiu.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;自己封装的一个动画效果=。=&lt;/center&gt;
    
    </summary>
    
      <category term="动画" scheme="https://hadesxiye.github.io/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="动画" scheme="https://hadesxiye.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 拓展</title>
    <link href="https://hadesxiye.github.io/2018/10/24/Swift%E6%8B%93%E5%B1%95/"/>
    <id>https://hadesxiye.github.io/2018/10/24/Swift拓展/</id>
    <published>2018-10-24T11:06:24.000Z</published>
    <updated>2018-12-11T12:04:18.638Z</updated>
    
    <content type="html"><![CDATA[<p><center><code>Extensions</code>：为已存在的类、结构体、枚举或者协议类型增添了一个新的功能。这项功能包括在对你无法访问源码的情况下进行类的扩展的能力（例如“追溯模型”）。Swift 中的 <code>Extensions</code> 与 <code>Objective-C</code> 中的 <code>Categories</code> 类似。（但与<code>Objective-C</code> 中 <code>Categories</code> 有所不同的是，Swift 中的 <code>Extensions</code> 并没有一个具体的命名）</center><br><a id="more"></a></p><p>在 Swift 中 <code>Extensions</code> 可以做到：</p><ul><li>添加计算实例属性和计算类型属性</li><li>定义实例方法和类方法</li><li>提供新的初始化方法</li><li>定义下标脚本</li><li>定义和使用新的嵌套类型</li><li>使现有类型符合协议<br>在 Swift 中，甚至你可以实现扩展一个协议去满足你的需求或者增添一个额外的类型去使用。更多信息请参阅 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID521" target="_blank" rel="noopener">Protocol Extensions</a></li></ul><div class="note warning"><p>注意<br><code>Extensions</code> 可以为类增添一个新的功能，但却不能重写之前已经存在的功能。</p></div><h2 id="Extension-语法"><a href="#Extension-语法" class="headerlink" title="Extension 语法"></a><code>Extension</code> 语法</h2><p>使用关键字 <code>Extension</code> 来声明一个扩展：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写 SomeType 的新功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个 <code>Extension</code> 可以实现扩展现有类型去遵循一个或多个协议。为了保持协议的一致性，请你以在声明这个类或者结构体时的方式去声明这个协议名。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>以这种方式去保持协议描述的一致性 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID277" target="_blank" rel="noopener">Adding Protocol Conformance with an Extension</a>.</p><p>一个 <code>Extension</code> 可以被用于去扩展一个泛型，例如 <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID185" target="_blank" rel="noopener">Extending a Generic Type</a>. 当然你也可以去为所扩展的泛型添加一些功能条件，如下所述  <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553" target="_blank" rel="noopener">Extensions with a Generic Where Clause</a>.</p><div class="note warning"><p>注意<br>如果你想为一个已经存在的类型的进行扩展并添加一个新的功能，那么这个功能将会被该类所有的实例使用，即使在这个 <code>Extension</code> 被定义之前。</p></div><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p><code>Extensions</code> 可以将计算实例属性与计算类型属性添加到现有类中去。例如以下就是在 Swift 的内置类型 <code>Double</code> 中添加了五个计算实例属性，为距离单位提供了基础支持：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch = <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"One inch is \(oneInch) meters"</span>)</span><br><span class="line"><span class="comment">// Prints "One inch is 0.0254 meters"</span></span><br><span class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Three feet is \(threeFeet) meters"</span>)</span><br><span class="line"><span class="comment">// Prints "Three feet is 0.914399970739201 meters"</span></span><br></pre></td></tr></table></figure></p><p>这些计算属性应该被看作是 <code>Double</code> 值中的一个特定长度单位。尽管它们被看作是计算属性而被实现的，但是这些属性仍然可以被用于浮点类型的点语法而调用，被作为一种字面值去进行距离转换。</p><p>在这个举例中，当 <code>Double</code> 值为 <code>1.0</code> 时可被看作是 <code>1</code>米 。这就是为什么使用 <code>m</code> 时的计算属性会返回<code>Self</code> – 表达式 <code>1.m</code> 就表示是 <code>1.0</code> 的 <code>Double</code> 值。</p><p>其它的单位就需要作一些转换以便用作于以米为单位的表达。一公里就表示一千米，所以 <code>km</code> 这个计算属性将会通过乘以 <code>1_000.00</code> 去转换为米作单位去表达。同样，<code>3.28084</code> 英尺也可以表示为 <code>1</code>米 ，因此 ft 的计算属性将用 <code>Double</code> 值去除以 <code>3.28084</code> ，从而实现从英尺到米的转换。</p><p>为了代码的简洁性，这些属性是只读的，所以他们不能使用 <code>get</code> 关键字去调用。当然他们的返回值也是 <code>Double</code> 类型，并且他们能在任何可以使用 <code>Double</code> 类型的地方进行数学计算。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon = <span class="number">42</span>.km + <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A marathon is \(aMarathon) meters long"</span>)</span><br><span class="line"><span class="comment">// Prints "A marathon is 42195.0 meters long"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br><code>Extensions</code> 可以添加一个新的属性，但是他们不能存储这些属性，也不能为现有类型添加属性观察者。</p></div><h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><p><code>Extensions</code> 可以给现有类型添加一个新的初始化构造器。 这使你能够扩展一些其他类型去接收你自定义的类型用作为初始化参数，或者提供该类型的源码实现中未包含的初始化类型。</p><p><code>Extensions</code> 可以给类添加一个便利初始化器，但它们不能够提供特定的初始化器或者折构器。特定的初始化器和反初始化器都必须由原始类去提供。</p><p>如果你要为一个值类型去添加初始化器，并将这个值所存储的属性设置默认值，而又不为其定义任何自定义的初始化器时，那么你可以在你所扩展的初始化器中调用该类型的默认初始化器和成员初始化器。如果你已经将这个初始化器作为这个值类型的原始实现的一部分，那么将不再遵循以上规则, 如下所述 <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID215" target="_blank" rel="noopener">Initializer Delegation for Value Types</a>.</p><p>如果你使用一个 <code>Extension</code> 去给另一个模块中声明的结构添加一个初始化器，那么在这个模块被定义之前，这个新的初始化器将无法访问 <code>Self</code> 。</p><p>下面的例子自定义了一个名为 <code>Rect</code> 的结构体去表示一个几何矩形。同时还定义了 <code>Size</code> 和 <code>Point</code> 两个结构体去支持它, 这两个结构体都的属性默认值都被赋值为 <code>0.0</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 <code>Rect</code> 结构体为其属性提供了默认值, 所以他可以接受它的默认初始化器以及成员初始化器， 如下描述 <code>Default Initializers</code> 这些初始化器可以被用于去创建一个新的 <code>Rect</code>实例:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">   size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure></p><p>你可以为 <code>Rect</code> 结构体扩展一个额外的初始化器，并且给与这个额外的初始化器特定的 <code>Center</code> 和 <code>Size</code> 值:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个新的初始化器可以基于 <code>Center</code> 和 <code>Size</code> 的值去计算一个恰当的初始点，然后通过这个初始化器去调用 <code>init(origin:size:)</code> 这个自动初始化成员方法，这将会把新的 <code>Origin</code> 和 <code>Size</code> 保存在相对的属性中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>如果你声明了一个带有扩展的新的初始化器，那么你仍然有责任去确认在这个初始化器完成之后，每一个实例都已经被初始化完成。</p></div><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>扩展可以向已经存在的类型添加实例方法或类方法。<br>在下面的例子中，我们将为Int类型添加一个新的实例方法 <code>repetitions</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>repetitions(task:)</code>这个方法接收一个<code>() -&gt; Void</code>类型的参数，也就是一个没有参数没有返回值的闭包。<br>在成功定义这个扩展之后，你可以通过点语法在任意<code>Int</code>类型之后调用<code>repetitions</code>这个方法，并在闭包中输入你希望执行的代码，代码被执行的次数由这个<code>Int</code>决定。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure></p><h2 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h2><p>我们可以通过在扩展中添加实例方法来实现修改变量。<br>在结构体以及枚举当中，我们只需要对需要改变成员变量的方法添加<code>mutating</code>关键字即可。</p><p>在下面这个例子当中，由于square这个方法已经修改了<code>self</code>的值，所以我们需要在方法前加上<code>mutating</code>关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 现在已经变成 9 了</span></span><br><span class="line">``` </span><br><span class="line">## 下标</span><br><span class="line">`<span class="type">Extensions</span>` 能够对已经存在的类型添加下标。 下面的例子就是对 <span class="type">Swift</span> 的内置 `<span class="type">Int</span>` 类型添加一个整型下标。通过下标 `[n]`返回十进制数字的从右数` n` 个位置的数字：</span><br><span class="line"></span><br><span class="line">`<span class="number">123456789</span>[<span class="number">0</span>]` 返回 `<span class="number">9</span>`</span><br><span class="line">`<span class="number">123456789</span>[<span class="number">1</span>]` 返回 `<span class="number">8</span>`</span><br><span class="line">...等等:</span><br><span class="line">```swift</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;digitIndex &#123;</span><br><span class="line">            decimalBase *= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure></p><p>如果这个 <code>Int</code> 类型的值对于请求的索引没有足够的数字，使用下标访问会返回 <code>0</code>， 就如同用<code>0</code>填充了数字的左边:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0, 如同这样的请求:</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>我们可以通过扩展<code>Extensions</code>来向任何已经存在的类、结构体或枚举添加新的嵌套类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个针对 <code>Int</code> 类型的扩展 <code>Kind</code>，在这个扩展中，我们可以针对任意一个 <code>Int</code> 类型作出进一步的细分，比如：负数（<code>negative</code>），零 （<code>zero</code>）, 与正数 （<code>positive</code>）。</p><p>在这个例子中还另外为 <code>Int</code> 添加了一个计算属性 <code>kind</code>，这个属性可以根据具体的数字返回对于该数字的描述。</p><p>现在这个嵌套枚举已经可以在所有的 <code>Int</code> 变量中使用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printIntegerKinds</span><span class="params">(<span class="number">_</span> numbers: [Int])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0 "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"+ "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, -<span class="number">27</span>, <span class="number">0</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// Prints "+ + - 0 - 0 + "</span></span><br></pre></td></tr></table></figure></p><p>在 <code>printIntegerKinds(_:)</code> 这个函数中，它接收一个 <code>Int</code> 类型的数组，然后对其进行遍历，再根据嵌套枚举中 <code>kind</code> 这个计算属性对每一个元素输出对应的描述。</p><div class="note warning"><p>注意<br>因为<code>number.kind</code>已经定义在<code>Int.Kind</code>扩展中，所以我们可以在<code>switch</code>分支语句中直接使用，出于简洁性考虑，对比<code>Int.Kind.negative</code>这种写法，<code>.negative</code> 会显得更 Swift。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;code&gt;Extensions&lt;/code&gt;：为已存在的类、结构体、枚举或者协议类型增添了一个新的功能。这项功能包括在对你无法访问源码的情况下进行类的扩展的能力（例如“追溯模型”）。Swift 中的 &lt;code&gt;Extensions&lt;/code&gt; 与 &lt;code&gt;Objective-C&lt;/code&gt; 中的 &lt;code&gt;Categories&lt;/code&gt; 类似。（但与&lt;code&gt;Objective-C&lt;/code&gt; 中 &lt;code&gt;Categories&lt;/code&gt; 有所不同的是，Swift 中的 &lt;code&gt;Extensions&lt;/code&gt; 并没有一个具体的命名）&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="拓展" scheme="https://hadesxiye.github.io/tags/%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 嵌套类型</title>
    <link href="https://hadesxiye.github.io/2018/10/23/Swift%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    <id>https://hadesxiye.github.io/2018/10/23/Swift嵌套类型/</id>
    <published>2018-10-23T11:06:11.000Z</published>
    <updated>2018-12-11T12:04:19.284Z</updated>
    
    <content type="html"><![CDATA[<p><center>通常我们会创建枚举来支持特定的类或结构体的功能。类似地，为了可以方便地定义在更复杂类型上下文中使用的实用工具类和结构，Swift 允许你定义 嵌套类型 ，从而实现在枚举、类和结构体中的定义嵌套类型。</center><br><a id="more"></a><br>如果要将一个类型嵌套在另一个类型中，只需在支持类型的大括号内定义嵌套类型即可。类型支持多层嵌套。</p><h2 id="嵌套类型的使用"><a href="#嵌套类型的使用" class="headerlink" title="嵌套类型的使用"></a>嵌套类型的使用</h2><p>下面的示例定义了一个名为 <code>BlackjackCard</code> 的结构体，该结构体模拟了二十一点游戏中使用的扑克牌。 <code>BlackjackCard</code> 结构体包含两个名为 <code>Suit</code> 和 <code>Rank</code> 的嵌套枚举类型。</p><p>在二十一点游戏中，<code>Ace</code> 可以表示一或十一。这个特性由一个嵌套在 <code>Rank</code> 中的 <code>Values</code> 结构体表示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlackjackCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> spades = <span class="string">"♠"</span>, hearts = <span class="string">"♡"</span>, diamonds = <span class="string">"♢"</span>, clubs = <span class="string">"♣"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> two = <span class="number">2</span>, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">        <span class="keyword">case</span> jack, queen, king, ace</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .ace:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">case</span> .jack, .queen, .king:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="string">"suit is \(suit.rawValue),"</span></span><br><span class="line">        output += <span class="string">" value is \(rank.values.first)"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second = rank.values.second &#123;</span><br><span class="line">            output += <span class="string">" or \(second)"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Suit</code> 枚举描述了四种常见的扑克牌花色，并用原始的 <code>Character</code> 值来表示。</p><p><code>Rank</code> 枚举描述了十三种可能的扑克牌等级，并用枚举原始 <code>Int</code> 值来表示它的点数值。（ <code>Jack</code>、<code>Queen</code>、<code>King</code> 和 <code>Ace</code> 并不是用枚举原始的 <code>Int</code> 值表示的。）</p><p>如上所述，<code>Rank</code> 枚举中定义了嵌套结构体 <code>Values</code> 。这个结构体封装了大多数扑克牌只有一个值，而 <code>Ace</code> 有两个值的事实。 <code>Values</code> 结构体中定义了两个属性：</p><ul><li><code>first</code>，类型为 <code>Int</code></li><li><code>second</code>，类型为 <code>Int?</code> ，或者叫做「可选<code>Int</code>」<br><code>Rank</code> 还定义了一个计算属性 <code>values</code> ，它返回一个 <code>Values</code> 结构体的实例。此计算属性会根据扑克牌的点数，使用适当的值来初始化一个新创建的 <code>Values</code> 实例。对于 <code>jack</code>、<code>queen</code>、<code>king</code> 和 <code>ace</code> 扑克牌，使用了特殊值来表示。对于数字扑克牌，它使用自己本身的原始 <code>Int</code> 值来表示。</li></ul><p><code>BlackjackCard</code> 结构体本身有两个属性 — <code>rank</code> 和 <code>suit</code> 。它还定义了一个名为 <code>description</code> 的计算属性，它使用存储在 <code>rank</code> 和 <code>suit</code> 中的值来生成扑克牌的名称和值的描述。<code>description</code> 属性会使用可选绑定来检查是否添加第二个值的描述。</p><p>因为 <code>BlackjackCard</code> 是一个没有自定义构造器的结构体，所以它有一个隐式的成员构造器，参见 结构体类型的成员构造器 中描述。你可以使用此构造器来初始化一个名为 <code>theAceOfSpades</code> 的常量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades = <span class="type">BlackjackCard</span>(rank: .ace, suit: .spades)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"theAceOfSpades: \(theAceOfSpades.description)"</span>)</span><br><span class="line"><span class="comment">// 打印 "theAceOfSpades: suit is ♠, value is 1 or 11"</span></span><br></pre></td></tr></table></figure></p><p>尽管 <code>Rank</code>和 <code>Suit</code> 嵌套在 <code>BlackjackCard</code> 中，它们的类型也可以从上下文推断出来，因此这个实例的初始化方法能够通过它们的名称（ <code>.ace</code> 和 <code>.spades</code> ）来推断出对应的具体枚举实例。在上面的例子中，<code>description</code> 属性正确地反映了黑体 A 的值是 <code>1</code> 或者 <code>11</code>。</p><h2 id="引用嵌套类型"><a href="#引用嵌套类型" class="headerlink" title="引用嵌套类型"></a>引用嵌套类型</h2><p>要在其定义上下文之外使用嵌套类型，需要在其名称前面加上嵌套在其中的类型的名称：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol = <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.hearts.rawValue</span><br><span class="line"><span class="comment">// heartsSymbol 是「♡」</span></span><br></pre></td></tr></table></figure></p><p>对于上面的例子，可以使 <code>Suit</code>、<code>Rank</code> 和 <code>Values</code> 的名称尽可能的简短，因为它们的名称会自然地被定义它们的上下文限定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;通常我们会创建枚举来支持特定的类或结构体的功能。类似地，为了可以方便地定义在更复杂类型上下文中使用的实用工具类和结构，Swift 允许你定义 嵌套类型 ，从而实现在枚举、类和结构体中的定义嵌套类型。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="嵌套类型" scheme="https://hadesxiye.github.io/tags/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 类型转换</title>
    <link href="https://hadesxiye.github.io/2018/10/22/Swift%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://hadesxiye.github.io/2018/10/22/Swift类型转换/</id>
    <published>2018-10-22T02:08:33.000Z</published>
    <updated>2018-12-10T11:32:16.367Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>类型转换</strong> 是一种检查实例类型的方法，同时也能够将该实例转为其类继承关系中其他的父类或子类。</center><br><a id="more"></a><br>Swift 中的类型转换是通过 <code>is</code> 和 <code>as</code> 运算符实现的。 这两个运算符提供了一种简单而直观的方法来检查值的类型，或将值转换为其他类型。</p><h2 id="定义一个类结构作为类型转换示例"><a href="#定义一个类结构作为类型转换示例" class="headerlink" title="定义一个类结构作为类型转换示例"></a>定义一个类结构作为类型转换示例</h2><p>你可以使用类型转换连同类和子类的层次结构来检查特定类的实例类型，并将该实例强制转换为同一层次结构中的另一个类。 下面的三个代码片段定义了一种类的层次结构，以及一个包含了这些类的实例的数组，用于类型转换的示例。</p><p>第一个片段定义了一个名为 <code>MediaItem</code> 的新的基类。 此类为数字媒体库中显示的任何项目提供基本功能。 具体来说，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，以及 <code>init name</code> 初始化方法。 （假设所有媒体项目，包括所有电影和歌曲，都有一个名字。）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下一个片段定义了两个 <code>MediaItem</code> 的子类 。 第一个子类 <code>Movie</code> 封装了有关电影或影片的额外信息。 它在基类 <code>MediaItem</code> 的顶部添加了一个 <code>director</code> 属性，以及相应的初始化方法。 第二个子类 <code>Song</code> 在基类之上添加了 <code>artist</code> 属性和初始化方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, director: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.director = director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, artist: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist = artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一段代码创建了一个名为 <code>library</code> 的常量数组，其中包含了两个 <code>Movie</code> 实例和三个 <code>Song</code> 实例。 <code>library</code> 数组的类型是在其初始化时，根据数组中所包含的内容来推断的。 Swift 的类型检查器能够推断出 <code>Movie</code> 和 <code>Song</code> 有一个共同的父类 <code>MediaItem</code> ，因此它推断出 <code>library</code> 数组的类型为 <code>[MediaItem]</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> library = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Casablanca"</span>, director: <span class="string">"Michael Curtiz"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Blue Suede Shoes"</span>, artist: <span class="string">"Elvis Presley"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Citizen Kane"</span>, director: <span class="string">"Orson Welles"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"The One And Only"</span>, artist: <span class="string">"Chesney Hawkes"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Never Gonna Give You Up"</span>, artist: <span class="string">"Rick Astley"</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 「library」的类型被推断为 [MediaItem]</span></span><br></pre></td></tr></table></figure></p><p>虽然实际存储在 <code>library</code> 中的项目仍然是 <code>Movie</code> 和 <code>Song</code> 的实例。 但是当你迭代此数组时，你将得到 <code>MediaItem</code> 类型的实例，而不是 <code>Movie</code> 或 <code>Song</code> 。 为了把它们作为原类型使用，你需要 <strong>检查</strong> 它们的类型，或者将他们 <strong>强转</strong> 为其他类型，如下所述。</p><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用 类型检查运算符（ <code>is</code> ）来检查实例是否属于某个特定子类型。 如果实例属于该子类型，则类型检查运算符将返回 <code>true</code> ，否则，将返回 <code>false</code> 。</p><p>下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code> ，它们分别计算 <code>library</code> 数组中 <code>Movie</code> 和 <code>Song</code> 实例的数量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        movieCount += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        songCount += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Media library contains \(movieCount) movies and \(songCount) songs"</span>)</span><br><span class="line"><span class="comment">// 打印 "Media library contains 2 movies and 3 songs"</span></span><br></pre></td></tr></table></figure></p><p>此示例遍历了 <code>library</code> 数组中的所有项。 在每次跳转时，<code>for</code> - <code>in</code> 循环将 <code>item</code> 常量设置为数组中的下一个 <code>MediaItem</code> 。</p><p>如果当前的 <code>MediaItem</code> 是一个 <code>Movie</code> 实例，那么 <code>item is Movie</code> 将返回 <code>true</code> ，如果不是，则返回 <code>false</code> 。 类似地，<code>item is Song</code> 检查该项是否是 <code>Song</code> 的实例。 在 <code>for</code> - <code>in</code> 循环结束时，<code>movieCount</code> 和 <code>songCount</code> 的值就是每种类型所包含的 <code>MediaItem</code> 实例的个数。</p><h2 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h2><p>实际上某个类型的常量或变量可能本来就是某个子类的实例。当确认是这种情况情况时，你可以尝试使用 类型强制转换运算符 （ <code>as?</code> 或 <code>as!</code> ）将该常量或变量 强制转换 成子类型。</p><p>由于强制转换可能会失败，因该类型转换运算符有两种不同的形式。条件形式 <code>as?</code> 会返回你尝试强制转换的类型的可选值。强制形式 <code>as!</code> 则会尝试强制转换，并同时将结果强制解包。</p><p>当你不确定强制转换是否成功时，请使用类型转换运算符的条件形式（ <code>as?</code> ）。这种形式的运算符将始终返回一个可选值，如果无法进行强制转换，该值将为 <code>nil</code> 。这使得你可以检查强制转换是否成功。</p><p>仅当你确定强制转换会始终成功时，才使用类型转换运算符的强制形式（ <code>as!</code> ）。如果你尝试强制转换为不正确的类型，此形式的运算符将触发运行时错误。</p><p>下面的示例遍历了 <code>library</code> 中的每个 <code>MediaItem</code> ，并为每个元素打印适当的描述。 要做到这一点，它需要把每个元素当作真正的 <code>Movie</code> 或 <code>Song</code> 来访问，而不仅仅是作为 <code>MediaItem</code> 。 这是必要的，以便它能够访问 <code>Movie</code> 或 <code>Song</code> 的 <code>director</code> 或 <code>artist</code>属性用于描述。</p><p>在这个例子中，数组中的每个元素可能是 <code>Movie</code> ，也可能是 <code>Song</code> 。 你事先并不知道每个元素的真实类型，因此建议使用类型转换运算符的条件形式（ <code>as?</code> ）来检查每次循环时的强制转换：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie = item <span class="keyword">as</span>? <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Movie: \(movie.name), dir. \(movie.director)"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song = item <span class="keyword">as</span>? <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Song: \(song.name), by \(song.artist)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: Casablanca, dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: Blue Suede Shoes, by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: Citizen Kane, dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: The One And Only, by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: Never Gonna Give You Up, by Rick Astley</span></span><br></pre></td></tr></table></figure></p><p>该示例首先尝试将当前的 <code>item</code> 强制转换为 <code>Movie</code> 。 因为 <code>item</code> 是一个 <code>MediaItem</code> 的实例，它 可能是 一个<code>Movie</code> ，也可能是一个 <code>Song</code> ，甚至只是一个基础 <code>MediaItem</code> 。 由于这种不确定性，类型转换运算符 <code>as?</code> 在尝试强制转换子类型时会返回 可选 值。 <code>item as? Movie</code> 的结果是 <code>Movie?</code> 类型，即「可选 <code>Movie</code>」类型。</p><p>将数组中的 <code>Song</code> 实例强制转换为 <code>Movie</code> 时会失败。为了解决这个问题，上面的例子使用了可选绑定来检查可选的 <code>Movie</code> 是否包含一个值（也就是说，判断强转是否成功。）这个可选绑定是「 <code>if let movie = item as? Movie</code> 」，可以被理解为：</p><p>「尝试将 <code>item</code> 当作 <code>Movie</code> 来访问。如果成功，则将存储在可选 <code>Movie</code> 中的值赋给一个名为 <code>movie</code> 的新的临时常量。」</p><p>如果强制转换成功，那么 <code>movie</code> 的属性将被用于打印该 <code>Movie</code> 实例的描述，包括其 <code>director</code> 的名称。类似的原理也被用于检查 <code>Song</code> 实例，并在库中找到 <code>Song</code> 时打印适当的描述（包括 <code>artist</code> 名称）。</p><div class="note warning"><p>注意<br>转换实际上不会变更实例或修改其值。原本的实例保持不变；我们仅仅把它看作是它类型的实例，对其进行简单地处理和访问。</p></div><h2 id="对Any和AnyObject做类型转换"><a href="#对Any和AnyObject做类型转换" class="headerlink" title="对Any和AnyObject做类型转换"></a>对Any和AnyObject做类型转换</h2><p>Swift 提供了两种特殊的类型来处理非特定类型：</p><ul><li><code>Any</code> 可以表示任何类型的实例，包括函数类型。</li><li><code>AnyObject</code> 可以表示任何类类型的实例。<br>只有在明确需要 <code>Any</code> 或 <code>AnyObject</code> 所提供的行为和功能时才使用他们。 最好在你的代码中明确需要使用的类型。</li></ul><p>下面是使用 <code>Any</code> 来处理不同类型混合的示例，包括函数类型和非类类型。 该示例创建了一个名为 <code>things</code> 的数组，它可以存储类型为 <code>Any</code> 的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">"hello"</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">"Ghostbusters"</span>, director: <span class="string">"Ivan Reitman"</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Hello, \(name)"</span> &#125;)</span><br></pre></td></tr></table></figure></p><p><code>things</code> 数组包含了两个 <code>Int</code> 值，两个 <code>Double</code> 值，一个 <code>String</code> 值，一个类型为 <code>(Double，Double)</code> 的元组，一个名为 <code>Ghostbusters</code> 的 <code>movie</code> ，以及一个包含 <code>String</code> 参数并返回另一个 <code>String</code> 值的闭包表达式。</p><p>如果要查看一个常量或变量的具体类型，但只知道它的类型是 <code>Any</code> 或 <code>AnyObject</code> ，可以在 <code>switch</code> 分句中使用 <code>is</code> 或 <code>as</code> 模式。 下面的示例遍历了 <code>things</code> 数组中的元素，并使用 <code>switch</code> 语句查询每个元素的类型。 这几个 <code>switch</code> 分句将每个元素所匹配到的值绑定到指定类型的常量中，以使其值可以打印：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as an Int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as a Double"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an integer value of \(someInt)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a positive double value of \(someDouble)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"some other double value that I don't want to print"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a string value of \"\(someString)\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an (x, y) point at \(x), \(y)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a movie called \(movie.name), dir. \(movie.director)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> (<span class="type">String</span>) -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">"Michael"</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"something else"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of "hello"</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called Ghostbusters, dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br><code>Any</code> 类型表示任何类型的值，包括可选类型。 如果程序需要一个类型为 <code>Any</code> 的值，而你却使用了可选类型，<code>Swift</code> 会向你发出警告。 如果你确实需要将可选值作为 <code>Any</code> 使用，可以使用 <code>as</code> 操作符将可选类型显式地转换为<code>Any</code> 类型，如下所示。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalNumber: <span class="type">Int</span>? = <span class="number">3</span></span><br><span class="line">things.append(optionalNumber)        <span class="comment">// 警告</span></span><br><span class="line">things.append(optionalNumber <span class="keyword">as</span> <span class="type">Any</span>) <span class="comment">// 没有警告</span></span><br></pre></td></tr></table></figure><br><br></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;类型转换&lt;/strong&gt; 是一种检查实例类型的方法，同时也能够将该实例转为其类继承关系中其他的父类或子类。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="类型转换" scheme="https://hadesxiye.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 错误处理</title>
    <link href="https://hadesxiye.github.io/2018/10/21/Swift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://hadesxiye.github.io/2018/10/21/Swift错误处理/</id>
    <published>2018-10-21T02:08:05.000Z</published>
    <updated>2018-12-10T09:39:29.721Z</updated>
    
    <content type="html"><![CDATA[<p><center>错误处理是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。</center><br><a id="more"></a><br>我们不能保证所有的操作都可以全部被执行，也不能保证都可以生成有用的结果。当操作失败时，可以使用可选类型表示缺省值，但是了解导致失败的原因通常是很有用的，这样您的代码就可以做出相应的响应。</p><p>举个例子，假设有个任务是从磁盘读取并处理数据。可能有很多种方法导致这个任务失败，比如指定路径下的文件不存在，没有文件的读取权限，或者文件的编码格式不兼容。区分导致错误的不同情况可以让程序解决这些错误，并把解决不了的错误反馈给用户。</p><div class="note warning"><p>注意<br>Swift 中的错误处理与在 <code>Cocoa</code> 和 <code>Objective-C</code> 中使用的 <code>NSError</code> 的错误处理模式互操作。</p></div><h2 id="表示和抛出错误"><a href="#表示和抛出错误" class="headerlink" title="表示和抛出错误"></a>表示和抛出错误</h2><p>在 Swift 中，错误是遵循 <code>Error</code> 协议的值。<code>Error</code> 是一个空协议，表明遵循该协议的类型可以用于错误处理。</p><p>Swift 中的枚举特别适合对一组相关的错误条件进行建模，关联值允许传递有关错误的附加信息。例如，以下是您可能在游戏中操作自动售货机时出现的错误情况：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> invalidSelection</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> outOfStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>您可以通过抛出错误表示发生了意外情况，导致正常的执行流程不能继续执行下去。您可以使用 <code>throw</code> 语句抛出错误。例如，以下代码通过抛出错误表明自动售货机还需要 <code>5</code> 个硬币：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>当抛出错误时，它周围的代码必须负责处理错误。例如，通过尝试替换方案或将错误通知用户来纠正错误。</p><p>在 Swift 中有四种处理错误的方式。您可以将错误从函数传递给调用该函数的代码，可以使用 <code>do-catch</code> 语句处理错误，可以通过可选值处理错误，或者通过断言保证错误不会发生。在下面章节会对每种方式进行详细讲解。</p><p>当函数抛出错误时，它会改变程序的流程，因此快速定位问题显得尤为重要。在调用可能引发错误的函数、方法或初始化程序的代码之前，使用 <code>try</code> 关键字，或者使用它的变体 <code>try?</code> 或 <code>try!</code>，在您的代码中定位错误的位置。这些关键字在下面的章节中有详细描述。</p><div class="note warning"><p>注意<br>在 Swift 中使用 <code>try</code>、<code>catch</code> 和 <code>throw</code> 关键字进行错误处理的语法和其他语言的异常处理差不多。不同于 <code>Objective-C</code> 等语言的异常处理，Swift 中的错误处理不会展开调用堆栈，因为这个过程的计算成本很高。因此，<code>throw</code> 语句的性能特性和 <code>return</code> 语句的性能特性相差无几。</p></div><h2 id="使用抛出函数传递错误"><a href="#使用抛出函数传递错误" class="headerlink" title="使用抛出函数传递错误"></a>使用抛出函数传递错误</h2><p>为了让函数、方法或者初始化程序可以抛出错误，您需要在函数声明的参数后面添写 <code>throws</code> 关键字。标有 <code>throws</code> 的函数称为抛出函数。如果函数指定了返回类型，则在返回箭头 (<code>-&gt;</code>) 之前添写 <code>throws</code> 关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure></p><p>抛出函数将函数中的错误传递给调用该函数的代码。</p><div class="note warning"><p>注意<br>只有抛出函数才能传递错误。任何在非抛出函数中抛出错误都必须在函数内部进行处理。</p></div><p>在下面的示例中，<code>VendingMachine</code> 类有一个 <code>vend(itemNamed:)</code> 方法，如果请求的对象不可用，缺货或成本超出当前存款金额，则抛出适当的 <code>VendingMachineError</code> 错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> newItem = item</span><br><span class="line">        newItem.<span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        inventory[name] = newItem</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing \(name)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当无法满足购买零食的要求，<code>vend(itemNamed:)</code> 方法将使用 <code>guard</code> 语句提前退出方法，并抛出适当的错误。 因为 <code>throw</code> 语句会立即转移程序控制，所以只有当满足所有要求时程序才会出售物品。</p><p>因为 <code>vend(itemNamed:)</code> 方法会传播它抛出的任何错误，因此调用此方法的任何代码都必须处理错误 — 使用 <code>do- catch</code> 语句，<code>try?</code> 或 <code>try!</code> — 或继续传播它们。 例如，下面示例中的 <code>buyFavoriteSnack(person:vendingMachine:)</code> 也是一个可抛出函数，所以 <code>vend(itemNamed:)</code> 方法抛出的任何错误都将传播到调用 <code>buyFavoriteSnack(person: vendingMachine:)</code> 函数的地方。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">    <span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">    <span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">    <span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">    <span class="keyword">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>buyFavoriteSnack(person: vendingMachine:)</code> 函数查找某个人最喜欢的零食并尝试通过调用 <code>vend(itemNamed:)</code> 方法购买它。 因为 <code>vend(itemNamed:)</code> 方法可能抛出错误，所以需要在它前面用 <code>try</code> 关键字调用它。</p><p>可抛出构造器可以像抛出函数一样传播错误。 例如，下面清单中 <code>PurchasedSnack</code> 结构的构造器将可抛出函数作为初始化过程的一部分调用，该构造器通过将错误传播给调用者来处理它遇到的任何错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PurchasedSnack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, vendingMachine: <span class="type">VendingMachine</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> vendingMachine.vend(itemNamed: name)</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用-Do-Catch-处理错误"><a href="#使用-Do-Catch-处理错误" class="headerlink" title="使用 Do-Catch 处理错误"></a>使用 Do-Catch 处理错误</h2><p><code>do</code> - <code>catch</code> 语句通过运行代码块来处理错误。 如果 <code>do</code> 子句中的代码抛出错误，它将与 <code>catch</code> 子句一一匹配，以确定它们中的哪一个子句可以处理错误。</p><p>这是 <code>do</code> - <code>catch</code> 语句的一般形式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>catch</code> 之后写一个模式来表明该子句可以处理的错误。如果 <code>catch</code> 子句没有模式，则该子句将会匹配所有错误并将错误绑定到名为 <code>error</code> 的本地常量。 有关模式匹配的更多信息，请参阅 <a href="https://docs.swift.org/swift-book/ReferenceManual/Patterns.html" target="_blank" rel="noopener">模式</a> 。</p><p>例如，以下代码匹配 VendingMachineError 枚举的所有三种情况。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> buyFavoriteSnack(person: <span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Success! Yum."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.invalidSelection &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.outOfStock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.insufficientFunds(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional \(coinsNeeded) coins."</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unexpected error: \(error)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Insufficient funds. Please insert an additional 2 coins."</span></span><br></pre></td></tr></table></figure></p><p>在上面的例子中，<code>buyFavoriteSnack(person:vendingMachine:)</code> 函数在 <code>try</code> 表达式中调用，因为它可能会抛出错误。 如果抛出错误，执行会被立即转移到匹配的 <code>catch</code> 子句，该子句决定是否允许继续执行。 如果没有匹配的模式，则错误会被最终的 <code>catch</code> 子句捕获并绑定到本地 <code>error</code> 常量。 如果没有抛出错误，则执行 <code>do</code> 语句中的其余语句。</p><p><code>catch</code> 子句不必处理 <code>do</code> 子句中抛出的所有可能错误。 如果所有 <code>catch</code> 子句都没能处理错误，错误会向周围传播。 但是，传播的错误必须能被附近的 一些 作用域处理。 在非抛出函数中，封闭的 <code>do</code> - <code>catch</code> 子句必须处理错误。 在可抛出函数中，封闭的 <code>do</code> - <code>catch</code> 子句或调用者必须处理错误。 如果错误传播到顶级作用域而未被处理，则会出现运行时错误。</p><p>例如，之前的例子中，任何非 VendingMachineError 的错误都会被调用函数捕获：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nourish</span><span class="params">(with item: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> vendingMachine.vend(itemNamed: item)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">is</span> <span class="type">VendingMachineError</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Invalid selection, out of stock, or not enough money."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> nourish(with: <span class="string">"Beet-Flavored Chips"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unexpected non-vending-machine-related error: \(error)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Invalid selection, out of stock, or not enough money."</span></span><br></pre></td></tr></table></figure></p><p>在 <code>nourish(with:)</code> 函数中，如果 <code>vend(itemNamed:)</code> 抛出一个错误，且这个错误是 <code>VendingMachineError</code> 枚举中的其中一个，那么 <code>nourish(with:)</code> 将通过打印消息来处理错误。 否则，<code>nourish(with:)</code> 将错误传播到其调用栈，然后通过通用 <code>catch</code> 子句捕获错误。</p><h2 id="将错误转换为可选值"><a href="#将错误转换为可选值" class="headerlink" title="将错误转换为可选值"></a>将错误转换为可选值</h2><p>你可以使用 <code>try?</code> 将错误转换为可选值来处理错误。 如果在执行 <code>try?</code> 表达式时抛出错误，表达式的值将为 <code>nil</code> 。 例如，在下面的代码中，<code>x</code> 和 <code>y</code> 具有相同的值和行为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">try</span>? someThrowingFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = <span class="keyword">try</span> someThrowingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 <code>someThrowingFunction()</code> 抛出错误，则 <code>x</code> 和 <code>y</code> 的值为 <code>nil</code> 。 否则，<code>x</code> 和 <code>y</code> 的值是函数返回的值。 请注意，<code>x</code> 和 <code>y</code>是 <code>someThrowingFunction()</code> 返回的任何类型的可选项。 这里函数返回一个整数，因此 <code>x</code> 和 <code>y</code> 是可选的整数类型。</p><p>当你想以同样的方式处理所有错误时，使用 <code>try?</code> 可以帮助你编写出简洁的错误处理代码。 例如，以下代码使用多种途径来获取数据，如果所有方法都失败则返回 <code>nil</code> 。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="禁用错误传递"><a href="#禁用错误传递" class="headerlink" title="禁用错误传递"></a>禁用错误传递</h2><p>有时你知道可抛出函数或方法实际上不会在运行时抛出错误。 在这种情况下，你可以在表达式之前添加 <code>try!</code> 来禁用错误传播，并把调用过程包装在运行时断言中，从而禁止其抛出错误。 而如果实际运行时抛出了错误，你将收到运行时错误。</p><p>例如，以下代码使用 <code>loadImage(atPath:)</code> 函数，该函数会加载指定路径下的资源，如果无法加载图像则抛出错误。 在这种情况下，由于图片随应用程序一起提供，因此运行时不会抛出任何错误，因此禁用错误传播是合适的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = <span class="keyword">try</span>! loadImage(atPath: <span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="指定清理操作"><a href="#指定清理操作" class="headerlink" title="指定清理操作"></a>指定清理操作</h2><p>当代码执行到即将离开当前代码块之前，可以使用 <code>defer</code> 语句来执行一组语句。无论是因为错误而离开 — 抑或是因为诸如 <code>return</code> 或 <code>break</code> 等语句而离开， <code>defer</code> 语句都可以让你执行一些必要的清理。例如，你可以使用 <code>defer</code> 语句来关闭文件描述符或释放手动分配的内存。</p><p><code>defer</code> 语句会推迟执行，直到退出当前作用域。该语句由 <code>defer</code> 关键字和稍后要执行的语句组成。延迟语句可能不包含任何将控制转移出语句的代码，例如 <code>break</code> 或 <code>return</code> 语句，或抛出错误。延迟操作的执行顺序与它们在源代码中编写的顺序相反。也就是说，第一个 <code>defer</code> 语句中的代码最后一个执行，第二个 <code>defer</code> 语句中的代码倒数第二个执行，依此类推。源代码中的最后一个 <code>defer</code> 语句最先执行。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = <span class="keyword">open</span>(filename)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = <span class="keyword">try</span> file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在此关闭（文件），位于语句的末端。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子使用 <code>defer</code> 语句来确保 <code>open(_:)</code> 函数有相应的 <code>close(_:)</code> 函数调用。</p><div class="note warning"><p>注意<br>即使没有涉及错误处理代码，也可以使用 <code>defer</code> 语句。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;错误处理是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="错误处理" scheme="https://hadesxiye.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 可选链</title>
    <link href="https://hadesxiye.github.io/2018/10/20/Swift%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    <id>https://hadesxiye.github.io/2018/10/20/Swift可选链/</id>
    <published>2018-10-20T03:34:33.000Z</published>
    <updated>2018-12-07T09:56:39.097Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>可选链</strong> 是在当前可能为 <code>nil</code> 的可选值上查询和调用属性、方法和下标的过程。如果可选值有值，则属性、方法或下标调用成功；如果可选值为 <code>nil</code> ，则属性、方法或下标调用返回 <code>nil</code>。多个查询可以链接在一起，如果链中的任何一个节点为 <code>nil</code> ，整个链会返回失败。</center><br><a id="more"></a></p><div class="note warning"><p>注意<br>Swift 中的可选链类似于 Objective-C 中向 <code>nil</code> 传递消息，不过适用于任何类型，并且可以检查其成功与否。</p></div><h2 id="可选链作为强制展开的代替品"><a href="#可选链作为强制展开的代替品" class="headerlink" title="可选链作为强制展开的代替品"></a>可选链作为强制展开的代替品</h2><p>如果可选项不为 <code>nil</code>， 可以在可选值后面加上问号（<code>?</code>） ，从而指定可选链。 这非常类似于在可选值之后放置感叹号（<code>!</code>）来强制展开它的值。主要的区别是，可选链在可选项为 <code>nil</code> 时只会调用失败，而强制展开在可选项为 <code>nil</code> 时会触发运行时错误。</p><p>为了反映可选链可以对 <code>nil</code> 值进行调用这一事实，可选链调用的结果总是一个可选值，即使正在查询的属性、方法或下标返回一个不可选值。可以使用这个可选的返回值来检查可选链调用是否成功（返回的可选项包含一个值），或者由于链中的 <code>nil</code> 值而没有成功（返回的可选值是 <code>nil</code>）。</p><p>具体来说，可选链调用的结果与预期返回值的类型相同，但包装在一个可选值中。一个平时返回 <code>Int</code> 的属性，在可选链中访问将返回 <code>Int?</code> 。</p><p>接下来的几个代码片段演示了可选链与强制解包的区别，并且能够检查是否成功。</p><p>首先，定义两个类 <code>Person</code> 和 <code>Residence</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Residence</code> 实例有一个 <code>Int</code> 类型的属性 <code>numberOfRooms</code>，其默认值为 <code>1</code>。<code>Person</code> 实例有一个可选属性 <code>residence</code>，其类型为 <code>Residence?</code>。</p><p>如果你新建一个 <code>Person</code> 实例，由于 <code>residence</code> 是可选的，所以会被初始化为 <code>nil</code>。如下代码所示，<code>john</code> 拥有一个 <code>residence</code> 属性，其值为 <code>nil</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br></pre></td></tr></table></figure></p><p>如果你尝试访问此人 <code>residence</code> 的 <code>numberOfRooms</code> 属性，通过在 <code>residence</code> 后面放置一个感叹号来强制展开其值，则会触发运行时错误，因为没有值来解包：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> roomCount = john.residence!.numberOfRooms</span><br><span class="line"><span class="comment">// 这里会触发运行时错误</span></span><br></pre></td></tr></table></figure></p><p>上述代码在 <code>john.residence</code> 有非 <code>nil</code> 值并且将 <code>roomCount</code> 设置为包含适当房间数的 <code>Int</code> 值时会运行成功。但是如上所述，此代码在 <code>residence</code> 为 <code>nil</code> 时始终会触发运行时错误。</p><p>可选链提供了另一种访问 <code>numberOfRooms</code> 值的方法。要使用可选链，请使用问号代替感叹号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has \(roomCount) room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to retrieve the number of rooms."</span></span><br></pre></td></tr></table></figure></p><p>这样就告诉 Swift 在可选的 <code>residence</code> 属性上「链接」，如果存在 <code>residence</code> 则检索 <code>numberOfRooms</code> 的值。</p><p>因为访问 <code>numberOfRooms</code> 的尝试有可能失败，所以可选链尝试返回类型为 <code>Int?</code>，或者说「可选 <code>Int</code> 」。如上例所示，当 <code>residence</code> 为 <code>nil</code>，这个可选的 <code>Int</code> 也将是 <code>nil</code>，这反映了无法访问 <code>numberOfRooms</code> 这一事实。通过可选绑定访问该可选的 <code>Int</code> 值来展开整数并且将非可选值赋值给 <code>roomCount</code>。</p><p>请注意，即使 <code>numberOfRooms</code> 是非可选的 <code>Int</code> 也是如此。这意味着通过可选链访问 <code>numberOfRooms</code> 将始终返回 <code>Int?</code> 而不是 <code>Int</code>。</p><p>你可以把一个 <code>Residence</code> 实例赋值给 <code>john.residence</code>，以使它不再是 <code>nil</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence = <span class="type">Residence</span>()</span><br></pre></td></tr></table></figure></p><p><code>john.residence</code> 现在拥有了一个真正的 <code>Residence</code> 实例，而不是 <code>nil</code>。这时用和之前相同的可选链来访问 <code>numberOfRooms</code>，则会返回包含 <code>numberOfRooms</code> 默认值 <code>1</code> 的一个 <code>Int?</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has \(roomCount) room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "John's residence has 1 room(s)."</span></span><br></pre></td></tr></table></figure></p><h2 id="为可选链定义模型类"><a href="#为可选链定义模型类" class="headerlink" title="为可选链定义模型类"></a>为可选链定义模型类</h2><p>你可以使用可选链来调用超过一级深度的属性、方法和下标。 这使你可以深入查看相互关联类型的复杂模型中的子属性，并检查是否可以访问这些子属性上的属性、方法和下标。</p><p>下面的代码片段定义了四个模型类，用于后续几个示例，包括多级可选链的示例。这些类是从上面的 <code>Person</code> 和 <code>Residence</code> 扩展而来，添加了 <code>Room</code> 和 <code>Address</code> 类以及相关的属性、方法和下标。</p><p><code>Person</code> 类的定义和之前一样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Residence</code> 类比之前复杂一点。这里定义一个变量属性 <code>rooms</code>，并初始化成类型为 <code>[Room]</code> 的空数组。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rooms = [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The number of rooms is \(numberOfRooms)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这个版本的 <code>Residence</code> 储存了一个 <code>Room</code> 的数组示例，所以 <code>numberOfRooms</code> 属性变成了计算属性，而不是存储属性。计算出的 <code>numberOfRooms</code> 属性返回 <code>rooms</code> 数组的 <code>count</code> 属性的值。</p><p>这个版本的 <code>Residence</code> 提供了一个可读写的下标作为访问 <code>rooms</code> 数组的快捷方式，可以访问 <code>rooms</code> 数组对应索引值下的房间。</p><p><code>Residence</code> 同时提供了一个 <code>printNumberOfRooms</code> 方法来打印房间数量。</p><p>最后，<code>Residence</code> 定义了一个 <code>Address?</code> 类型的可选属性 <code>address</code>，<code>Address</code> 类会在随后定义。</p><p><code>rooms</code> 数组中的 <code>Room</code> 类只有一个 <code>name</code> 属性，以及一个初始化构造函数来将该属性设置为合适的房间名：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是 <code>Address</code> 类。这个类有<code>3</code>个 <code>String?</code> 类型的可选属性。前两个属性 <code>buildingName</code> 和 <code>buildingNumber</code> 是该地址建筑物的标识。 第三个属性 <code>street</code> 是该地址的街道名：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildingIdentifier</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> buildingNumber = buildingNumber, <span class="keyword">let</span> street = street &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\(buildingNumber) \(street)"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> buildingName != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Address</code> 类同时提供了一个 <code>buildingIdentifier()</code> 方法，其返回值类型为 <code>String?</code>。这个方法检查地址的属性，如果 <code>buildingNumber</code> 和 <code>street</code> 都有值则把它们连接起来并返回，如果 <code>buildingName</code> 有值则返回其值，否则返回 <code>nil</code>。</p><h2 id="通过可选链访问属性"><a href="#通过可选链访问属性" class="headerlink" title="通过可选链访问属性"></a>通过可选链访问属性</h2><p>就像这篇文档演示的一样， 可选链作为一种强制解包的可选方式， 你可以用可选链访问可选类型值得属性，并检查是否成功访问。</p><p>用上面定义的类来创建一个新的 <code>Person</code> 实例，并跟前面一样去访问该实例的 <code>numberOfRooms</code> 属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has \(roomCount) room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to retrieve the number of rooms."</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>john.residence</code> 的值是 <code>nil</code>，所以此次可选链的调用仍然会失败。</p><p>你也可以试着用可选链去设置属性的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line">john.residence?.address = someAddress</span><br></pre></td></tr></table></figure></p><p>在该例中，因为 <code>john.residence</code> 当前的值为 <code>nil</code>，所以试图设置 <code>john.residence</code> 的 <code>address</code> 属性的值将会失败。</p><p>赋值是可选链的一部分，也就意味着 <code>=</code> 操作符的右操作数不会被计算。而之所以前面的例子不容易看出来 <code>someAddress</code> 的值从未被计算，那是因为访问常量没有副作用。接下来看下面的代码片段，它同样是赋值，但是是用函数创建 <code>Address</code> 的实例。“函数被调用” 在函数返回值之前就打印出来了，这样你可以清楚的看到是否 <code>=</code> 右操作数被计算了。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAddress</span><span class="params">()</span></span> -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"函数被调用。"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">    someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence?.address = createAddress()</span><br></pre></td></tr></table></figure></p><p>因为什么都没有打印，所以你可以区分出来函数 <code>createAddress()</code>  未被调用。</p><h2 id="通过可选链调用方法"><a href="#通过可选链调用方法" class="headerlink" title="通过可选链调用方法"></a>通过可选链调用方法</h2><p>你可以使用可选链来调用一个可选值的方法，以及检查调用是否成功。即使那个方法没有返回值你依然可以这样做。</p><p><code>Residence</code> 的 <code>printNumberOfRooms()</code> 方法打印当前 <code>numberOfRooms</code> 的值。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number of rooms is \(numberOfRooms)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法没有指定返回类型。但是，没有返回值的函数和方法会有一个隐式返回类型 <code>Void</code>，可在此查看 无返回值函数。这意味着会返回一个 <code>()</code>，或者说一个空的元组。</p><p>如果你用可选链调用一个可选值的方法，这个方法的返回类型会是 <code>Void?</code>，而不是 <code>Void</code>。因为可选链永远返回可选值。这使得你可以使用 <code>if</code> 表达式来检查是否可以调用 <code>printNumberOfRooms()</code> 方法，即使这个方法本身没有定义返回值。将 <code>printNumberOfRooms</code> 的返回值与 nil 进行比较来查看方法是否调用成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence?.printNumberOfRooms() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was possible to print the number of rooms."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was not possible to print the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "It was not possible to print the number of rooms."</span></span><br></pre></td></tr></table></figure></p><p>通过可选链尝试给一个属性赋值也是同样。这个例子 通过可选链访问属性 尝试给 <code>john.residence</code> 设置一个 <code>address</code> 值，即便这时 <code>residence</code> 属性是个 <code>nil</code>。任何通过可选链给属性赋值的尝试都会返回一个 <code>Void?</code> 类型的值。这样你可以和 <code>nil</code> 比较来检查赋值是否成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence?.address = someAddress) != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was possible to set the address."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was not possible to set the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "It was not possible to set the address."</span></span><br></pre></td></tr></table></figure></p><h2 id="通过可选链访问下标"><a href="#通过可选链访问下标" class="headerlink" title="通过可选链访问下标"></a>通过可选链访问下标</h2><p>你可以使用可选链尝试从可选值的下标中检索和设置值，并检查该下标调用是否成功。</p><div class="note warning"><p>注意<br>当你通过可选链访问一个可选值的下标时，在下标中括号 前面 放置问号，而不是后面。可选链的问号永远是直接跟在可选表达式后面。</p></div><p>下面的示例尝试使用 Residence 类中定义的下标检索 <code>john.residence</code> 属性的 <code>rooms</code> 数组中第一个房间的名称。由于 <code>john.residence</code> 当前是 <code>nil</code>，下标访问失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first room name is \(firstRoomName)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to retrieve the first room name."</span></span><br></pre></td></tr></table></figure></p><p>这里的问号直接跟在 <code>john.residence</code> 后面，下标中括号的前面。因为是在 <code>john.residence</code> 这个可选值上尝试取值。</p><p>类似的，你可以尝试通过可选链下标来设置一个新的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence?[<span class="number">0</span>] = <span class="type">Room</span>(name: <span class="string">"Bathroom"</span>)</span><br></pre></td></tr></table></figure></p><p>在这里赋值的尝试都会失败，因为 <code>residence</code> 当前是 <code>nil</code>。</p><p>如果你创建一个 <code>Residence</code> 实例并赋值给 <code>john.residence</code>，并且 <code>rooms</code> 数组中有一个或更多 <code>Room</code> 实例， 你就可以通过可选链来真正地用 <code>Residence</code> 下标访问到 <code>rooms</code> 数组里的实际内容：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Living Room"</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Kitchen"</span>))</span><br><span class="line">john.residence = johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first room name is \(firstRoomName)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The first room name is Living Room."</span></span><br></pre></td></tr></table></figure></p><h2 id="访问可选类型的下标"><a href="#访问可选类型的下标" class="headerlink" title="访问可选类型的下标"></a>访问可选类型的下标</h2><p>如果下标返回一个可选类型的值，例如 Swift 中 <code>Dictionary</code> 的键下标，在下标的右括号 后面 放置一个问号来链接其可选的返回值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores = [<span class="string">"Dave"</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">"Bev"</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">"Dave"</span>]?[<span class="number">0</span>] = <span class="number">91</span></span><br><span class="line">testScores[<span class="string">"Bev"</span>]?[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">testScores[<span class="string">"Brian"</span>]?[<span class="number">0</span>] = <span class="number">72</span></span><br><span class="line"><span class="comment">// 「Dave」 数组现在是 [91, 82, 84] ，「Bev」 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure></p><p>上述示例定义了一个 <code>testScores</code> 字典，它包含两个键值对，将 <code>String</code> 类型的键映射到 <code>Int</code> 值的数组。该例中使用可选链将 <code>Dave</code> 数组中的第一个元素置为 <code>91</code>；将 <code>Bev</code> 数组的第一个元素加 <code>1</code>；尝试向 <code>Brian</code> 的第一个元素设一个值。前两个调用成功，因为 <code>testScores</code> 字典包含 <code>Dave</code> 和 <code>Bev</code> 两个键。第三个调用失败，因为 <code>testScores</code> 不包含 <code>Brian</code> 键。</p><h2 id="多级链表关联"><a href="#多级链表关联" class="headerlink" title="多级链表关联"></a>多级链表关联</h2><p>你可以关联多层次的可选链，以深入到模型中更深层次的属性、方法和下标。但是，多个可选链表级别不增加返回值的可选级别。</p><p>换个说法:</p><ul><li>如果要检索的类型不是可选的，通过可选链，它将成为可选的。</li><li>如果您要检索的类型已经是可选的，那么它将保持原状。</li><li><p>因此:</p></li><li><p>如果你试图通过可选链检索一个 <code>Int</code> 值，那么不管用了多少链，总是返回一个 <code>Int?</code> 。</p></li><li>同样，你试图通过可选链检索一个 <code>Int?</code> 值，无论使用多少链，也总是返回一个 <code>Int?</code> 。</li></ul><p>下面的例子尝试访问 <code>John</code> 中的 <code>Residence</code> 属性中的 <code>Address</code> 属性中的 <code>Street</code> 属性。这里使用了两层可选链式调用，<code>Residence</code> 以及  <code>Address</code>  都是可选值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is \(johnsStreet)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to retrieve the address."</span></span><br></pre></td></tr></table></figure></p><p> <code>john.residence</code> 现在包含一个有效的 <code>Residence</code> 实例。然而， <code>john.residence.address</code> 的值当前为 <code>nil</code> 。因此，调用   <code>john.residence?.address?.street</code> 会失败。</p><p>需要注意的是，上面的例子中， <code>Street</code> 的属性为 <code>String?</code> 。 <code>john.residence?.address?.street</code>  的返回值也依然是 <code>String?</code> ，即使已经使用了两层可选链式调用。</p><p>如果为 <code>john.residence.address</code> 赋值一个 <code>Address</code> 实例，并且为  <code>Address</code> 中的 <code>Street</code> 属性设置一个有效值，我们就能过通过可选链式调用来访问 <code>Street</code> 属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsAddress = <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName = <span class="string">"The Larches"</span></span><br><span class="line">johnsAddress.street = <span class="string">"Laurel Street"</span></span><br><span class="line">john.residence?.address = johnsAddress</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is \(johnsStreet)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "John's street name is Laurel Street."</span></span><br></pre></td></tr></table></figure></p><p>在上面的例子中，因为 <code>john.residence</code> 包含一个有效的 <code>Address</code> 实例，所以对 <code>john.residence</code> 的 <code>Address</code> 属性赋值将会成功。</p><h2 id="在方法的可选返回值上进行可选链式调用"><a href="#在方法的可选返回值上进行可选链式调用" class="headerlink" title="在方法的可选返回值上进行可选链式调用"></a>在方法的可选返回值上进行可选链式调用</h2><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p><p>在下面的例子中，通过可选链式调用来调用 <code>Address</code> 的  <code>buildingIdentifier()</code> 方法。这个方法返回 <code>String?</code> 类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是 <code>String?</code> 类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's building identifier is \(buildingIdentifier)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "John's building identifier is The Larches."</span></span><br></pre></td></tr></table></figure></p><p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe =</span><br><span class="line">    john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class="string">"The"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"John's building identifier begins with \"The\"."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"John's building identifier does not begin with \"The\"."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "John's building identifier begins with "The"."</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>在上面的例子中，在方法的圆括号后面加上问号是因为你要在  <code>buildingIdentifier()</code> 方法的可选返回值上进行可选链式调用，而不是  <code>buildingIdentifier()</code> 方法本身。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;可选链&lt;/strong&gt; 是在当前可能为 &lt;code&gt;nil&lt;/code&gt; 的可选值上查询和调用属性、方法和下标的过程。如果可选值有值，则属性、方法或下标调用成功；如果可选值为 &lt;code&gt;nil&lt;/code&gt; ，则属性、方法或下标调用返回 &lt;code&gt;nil&lt;/code&gt;。多个查询可以链接在一起，如果链中的任何一个节点为 &lt;code&gt;nil&lt;/code&gt; ，整个链会返回失败。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="可选链" scheme="https://hadesxiye.github.io/tags/%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 折构过程</title>
    <link href="https://hadesxiye.github.io/2018/10/19/Swift%E6%8A%98%E6%9E%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://hadesxiye.github.io/2018/10/19/Swift折构过程/</id>
    <published>2018-10-19T03:34:03.000Z</published>
    <updated>2018-12-07T08:24:40.268Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>析构器</strong> 会在类的实例销毁之前被立即调用。使用 <code>deinit</code> 关键字来标示析构器，类似于使用 <code>init</code> 关键字标示构造器。 析构器仅适用于 <code>class</code> 类型。</center><br><a id="more"></a></p><h2 id="析构器是如何运作的"><a href="#析构器是如何运作的" class="headerlink" title="析构器是如何运作的"></a>析构器是如何运作的</h2><p>当不再需要某一个实例时，<code>Swift</code> 会自动销毁该实例，以释放资源。 <code>Swift</code> 通过 <strong>自动引用计数</strong>（ ARC ）来管理实例内存，就如 自动引用计数 中所述。通常在实例释放时，你无需行手执动清理。但是，当你在使用自己的资源时，可能需要自己执行一些额外的清理。例如，如果你创建了一个自定义类以打开文件并向其写入一些数据，则可能需要在销毁类实例之前关闭该文件。</p><p>在类的定义中, <strong>类最多只能有一个析构器</strong>。 析构器不接受任何参数，并且没有括号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">//执行析构器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在实例销毁之前，会自动调用析构器。你不能自己调用析构器。父类的析构器由其子类继承，父类析构器会在子类析构器实现的末尾自动调用。即使子类不提供自己的析构器，父类析构器也会被调用。</p><p>因为实例在调用析构器之后才会被释放，所以析构器可以访问调用它的实例的所有属性，并可以根据这些属性修改其行为（例如查找需要关闭的文件的名称） ）。</p><h2 id="析构器实践"><a href="#析构器实践" class="headerlink" title="析构器实践"></a>析构器实践</h2><p>这是一个析构器的实践。这个例子为一个简单的游戏定义了两个新类型， <code>Bank</code> 和 <code>Player</code> 。 <code>Bank</code> 类管理一种虚拟货币，且流通的货币永远不会超过<code>10,000</code>枚。在游戏中有且只有一个 <code>Bank</code> ，因此 <code>Bank</code> 使用类来实现, 并且该类含有类型属性以及用于存储和管理其当前状态的类型方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">distribute</span><span class="params">(coins numberOfCoinsRequested: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> numberOfCoinsToVend = <span class="built_in">min</span>(numberOfCoinsRequested, coinsInBank)</span><br><span class="line">        coinsInBank -= numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInBank += coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Bank</code> 使用 <code>coinsInBank</code> 属性跟踪它当前持有的硬币的数量。它还提供了两个方法— <code>distribute(coins:)</code> 和 <code>receive(coins:)</code> —来处理硬币的分配和收集。</p><p><code>distribute(coins:)</code> 方法在分配硬币之前先检查银行中是否有足够的硬币。如果没有足够的硬币，<code>Bank</code> 返回的数字将会小于请求的数字（如果银行中没有硬币则返回零）。该方法返回一个整数值，表示实际可提供的硬币数。</p><p><code>receive(coins:)</code> 方法只是将得到的硬币数量添加回银行的总硬币数中。</p><p><code>Player</code> 类描述了游戏中的玩家。每个玩家的钱包在任何时候都有一定数量的硬币。这个数量是由玩家的 <code>coinsInPurse</code> 属性表示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(coins: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse = <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">win</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInPurse += <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receive(coins: coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 <code>Player</code> 实例在初始化期间, 会得到来自银行的指定数量硬币。但是如果银行没有足够的硬币，那么 <code>Player</code> 实例只能拿到少于指定数量的硬币。</p><p><code>Player</code> 类定义了一个 <code>win(coins:)</code> 方法，它从银行中取回一定数量的硬币并将它们添加到玩家的钱包中。 <code>Player</code> 类还实现了一个析构器，它会在 <code>Player</code> 实例被释放前调用。在这个例子中，析构器只是将所有玩家的硬币归还给银行：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? = <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A new player has joined the game with \(playerOne!.coinsInPurse) coins"</span>)</span><br><span class="line"><span class="comment">// 打印 「一个新玩家加入了游戏并获得了100个硬币」</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are now \(Bank.coinsInBank) coins left in the bank"</span>)</span><br><span class="line"><span class="comment">// 打印 「银行现在剩余9900个硬币」</span></span><br></pre></td></tr></table></figure></p><p>如果剩余硬币充足，创建一个新 Player 实例同时就需要立即分配<code>100</code>个硬币。这个 <code>Player</code> 实例存储在一个名为 <code>playerOne</code> 的可选值变量中。这里使用可选变量，因为玩家可以随时离开游戏。可选项方式可让你跟踪游戏中当前玩家是否存在。</p><p>因为 <code>playerOne</code> 是一个可选值，所以当我们尝试访问它的 <code>coinsInPurse</code> 属性以打印其默认硬币数，或调用它的 <code>win(coins:)</code> 方法时，我们需要加上一个感叹号 （ <code>!</code> ） 来解包：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne!.win(coins: <span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins"</span>)</span><br><span class="line"><span class="comment">// 打印 「PlayerOne 赢了2000个硬币，现在有2100个硬币」</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now only has \(Bank.coinsInBank) coins left"</span>)</span><br><span class="line"><span class="comment">// 打印 「银行现在只剩下7900个硬币」</span></span><br></pre></td></tr></table></figure></p><p>现在，玩家赢得了 <code>2,000</code> 个硬币。玩家的钱包现在包含 <code>2,100</code> 个硬币，银行只剩下 <code>7,900</code> 个硬币。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne has left the game"</span>)</span><br><span class="line"><span class="comment">// 打印 「PlayerOne 离开游戏」</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now has \(Bank.coinsInBank) coins"</span>)</span><br><span class="line"><span class="comment">// 打印 「银行现在有10000个硬币」</span></span><br></pre></td></tr></table></figure></p><p>玩家现在已离开了游戏。通过将可选的 <code>playerOne</code> 变量置为 <code>nil</code> 来表示 「没有 <code>Player</code> 实例。」 此时， <code>playerOne</code> 变量对 <code>Player</code> 实例的引用被销毁。没有其他属性或变量仍然引用着 <code>Player</code> 实例，因此它就会被销毁以释放其内存。在销毁前， <code>Player</code>自动调用了它的析构器被，并将它的硬币送回银行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;析构器&lt;/strong&gt; 会在类的实例销毁之前被立即调用。使用 &lt;code&gt;deinit&lt;/code&gt; 关键字来标示析构器，类似于使用 &lt;code&gt;init&lt;/code&gt; 关键字标示构造器。 析构器仅适用于 &lt;code&gt;class&lt;/code&gt; 类型。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="折构过程" scheme="https://hadesxiye.github.io/tags/%E6%8A%98%E6%9E%84%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 构造过程</title>
    <link href="https://hadesxiye.github.io/2018/10/18/Swift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/"/>
    <id>https://hadesxiye.github.io/2018/10/18/Swift构造过程/</id>
    <published>2018-10-18T11:50:56.000Z</published>
    <updated>2018-12-07T02:42:05.711Z</updated>
    
    <content type="html"><![CDATA[<p><center>实例的准备过程，这个过程包含了设置实例每个存储属性的初始值并在实例使用之前执行全部所需的其他设置或初始化。</center><br><a id="more"></a><br>构造过程 就是使用类，结构体或枚举</p><p>通过定义构造器来实现构造过程，这更像调用创建某一类型实例的特殊方法。和 Objective-C 的构造器不同，Swift 的构造器不用返回值。它们主要的作用就是确保在第一次使用前某类型的实例都能正确的初始化。</p><p>类的实例也可以实现析构器，在该类实例释放前执行自定义的清理工作。关于析构器的更多信息，请参阅 <a href="https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html" target="_blank" rel="noopener">析构过程</a>.</p><h2 id="设置存储属性的初始值"><a href="#设置存储属性的初始值" class="headerlink" title="设置存储属性的初始值"></a>设置存储属性的初始值</h2><p>类和结构体在其创建实例时 <strong>必须</strong> 为它们所有的存储属性设置适当的初始值。存储属性<strong>不能处于未知状态</strong>。</p><p>你可以在构造器中为存储属性设置初始值，或是作为定义属性时的一部分设置其默认值。详情如下。</p><div class="note warning"><p>注意<br>当你为存储属性设置默认值时，或是在构造器中设置其初始值，属性值是直接设置的，并不会调用任何属性观察器。</p></div><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><strong>构造器</strong> 在创建某类实例时调用。其最简单的形式用 <code>init</code> 关键字来写，就像一个不带参数的实例方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="comment">// 在这执行初始化设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的例子定义了一个名为 <code>Fahrenheit</code> 的新结构体，用于保存华氏温度。<code>Fahrenheit</code> 结构体有一个 <code>Double</code> 类型的存储属性 <code>temperature</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature = <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The default temperature is \(f.temperature)° Fahrenheit"</span>)</span><br><span class="line"><span class="comment">// 打印 "The default temperature is 32.0° Fahrenheit"</span></span><br></pre></td></tr></table></figure></p><p>这个结构体定义了一个没有参数的构造器 <code>init</code>，并将存储属性 <code>temperature</code> 的值初始化为 <code>32.0</code> ( 水冰点的华氏温度 )。</p><h2 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h2><p>如上所示，你可以在构造器中设置一个存储属性的初始值。或指定一个 <strong>默认属性值</strong> 作为声明属性的一部分。指定默认属性值你可以通过在属性定义时为其赋一个初始值。</p><div class="note warning"><p>注意<br>如果一个属性总是相同的初始值，与其在构造器中设置一个值不如提供一个默认值。其效果是相同的，但是默认值与属性构造器的联系更紧密一些。它使构造器更简短，更清晰，并且可以通过默认值推断属性类型。默认值也使你更易使用默认构造器和构造器继承，本章稍后会详细解释。</p></div><p>你可以通过上述为 <code>temperature</code> 属性提供默认值的简单形式来写结构体 <code>Fahrenheit</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature = <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="自定义构造过程"><a href="#自定义构造过程" class="headerlink" title="自定义构造过程"></a>自定义构造过程</h2><p>如下所述，你可以通过输入参数和可选类型属性，或在构造过程中给常量属性赋值来自定义构造过程。</p><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p>你可以提供 <strong>构造参数</strong> 作为构造器定义的一部分，以定义自定义构造过程中值的类型和名字。构造参数有着与函数参数和方法参数相同的功能和语法。</p><p>下面的例子定义了一个名为 <code>Celsius</code> 的结构体，用于存储摄氏度温度。结构体<code>Celsius</code> 实现了名为 <code>init(fromFahrenheit:)</code> 和 <code>init(fromKelvin:)</code> 的两个构造器，使用不同单位温度的值初始化了一个结构体实例:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater = <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius is 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater = <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius is 0.0</span></span><br></pre></td></tr></table></figure></p><p>第一个构造器有一个构造参数，其外部参数名为<code>fromFahrenheit</code>，内部参数名为 <code>fahrenheit</code>。第二个也有一个构造参数，其外部参数名为 <code>fromKelvin</code>，内部参数名为 <code>kelvin</code>。 两个构造器都将它们的参数转换为对应的摄氏温度并将其值存入名为 <code>temperatureInCelsius</code> 属性中。</p><h3 id="内部参数名和外部参数名"><a href="#内部参数名和外部参数名" class="headerlink" title="内部参数名和外部参数名"></a>内部参数名和外部参数名</h3><p>与函数和方法的参数一样，构造参数有一个在构造器中使用的内部参数名和一个调用构造器时使用的外部参数名。</p><p>不过，构造器并不像函数和方法在括号之前有一个可识别的名字。因此，构造参数的名字和类型就在识别哪一个构造器应该被调用时扮演了一个非常重要的角色。因此，如果你在构造器中没有为 每一个 参数提供外部参数名，Swift 就会自动为其提供外部参数名。</p><p>下面的例子定义了一个名为 <code>Color</code> 的结构体，并有名为 <code>red</code>，<code>green</code> 和 <code>blue</code> 三个常量。这三个属性存储了 <code>0.0</code> 到 <code>1.0</code> 之间的值，用于表示颜色中红，绿，蓝的值。</p><p><code>Color</code> 提供了一个带有红，蓝，绿三个 <code>Double</code> 类型参数的构造器。<code>Color</code> 也提供了只带有 <code>white</code> 参数的第二个构造器，用于给三个颜色组件设置相同的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(red: <span class="type">Double</span>, green: <span class="type">Double</span>, blue: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.red   = red</span><br><span class="line">        <span class="keyword">self</span>.green = green</span><br><span class="line">        <span class="keyword">self</span>.blue  = blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(white: <span class="type">Double</span>) &#123;</span><br><span class="line">        red   = white</span><br><span class="line">        green = white</span><br><span class="line">        blue  = white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过为每个构造参数传值，两个构造器都能创建一个新的 <code>Color</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> magenta = <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray = <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></p><p>注意如果不使用外部参数名是无法调用这些构造器的。如果在构造器中定义了外部参数名就必须使用，忽略它将会触发编译错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> veryGreen = <span class="type">Color</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 这会报编译错误 - 必须使用外部参数名</span></span><br></pre></td></tr></table></figure></p><h3 id="无需外部参数名的构造参数"><a href="#无需外部参数名的构造参数" class="headerlink" title="无需外部参数名的构造参数"></a>无需外部参数名的构造参数</h3><p>如果你不想对构造参数使用外部参数名，写一个下划线（<code>_</code>）来代替显式外部参数名以重写其默认行为。</p><p>这有一个之前 构造参数 中 <code>Celsius</code> 例子的扩展版本，使用已经是摄氏温度的 <code>Double</code> 值传入额外构造器以创建一个新的 <code>Celsius</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> celsius: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature = <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius is 37.0</span></span><br></pre></td></tr></table></figure></p><p>构造器 <code>Celsius(37.0)</code> 有清晰的调用意图而无需外部参数名。因此将构造器写成 <code>init(_ celsius: Double)</code> 这种很恰当，这样就可以使用没有名字的 <code>Double</code> 值来调用。</p><h3 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h3><p>如果你的自定义类型有一个逻辑上允许『 没有值 』存储属性 — 也许因为构造过程期间不为其赋值，或是因为它在稍后的某个时间点上被设置为『没有值』— 声明属性为 可选 类型。可选类型的属性会自动被初始化为 nil，表示属性在构造过程期间故意设置为『没有值』。</p><p>下面的例子定义了一个名为 <code>SurveyQuestion</code> 的类，并有一个名为 <code>response</code> 的可选类型其关联值类型为 <code>String</code> 类型的属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"Do you like cheese?"</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// 打印 "Do you like cheese?"</span></span><br><span class="line">cheeseQuestion.response = <span class="string">"Yes, I do like cheese."</span></span><br></pre></td></tr></table></figure></p><p>提出调查问题后，才能知道答案，所以声明 <code>response</code> 属性为 <code>String?</code>  类型，或是『 <code>optional String</code>』。当 <code>SurveyQuestion</code> 的实例被初始化时，它会自动被赋值为 <code>nil</code>，意味着『 <code>还没有字符串</code> 』。</p><h3 id="在构造过程期间给常量赋值"><a href="#在构造过程期间给常量赋值" class="headerlink" title="在构造过程期间给常量赋值"></a>在构造过程期间给常量赋值</h3><p>构造过程期间你可以在任何时间点给常量属性赋值，只要构造完成时设置了确定值即可。一旦常量属性被赋值，就不能再次修改。</p><div class="note warning"><p>注意<br>对于类的实例来说，常量属性只能在定义常量属性类的构造器中修改。不能在派生类中修改。</p></div><p>你可以修改上面 <code>SurveyQuestion</code> 的例子，使用常量属性而不是变量属性来表示问题 <code>text</code> ，用于指明一旦创建了 <code>SurveyQuestion</code> 实例，问题就不会再次修改。即使 <code>text</code> 属性现在是一个常量，但你仍然可以在类的构造器中设置其值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> beetsQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"How about beets?"</span>)</span><br><span class="line">beetsQuestion.ask()</span><br><span class="line"><span class="comment">// 打印 "How about beets?"</span></span><br><span class="line">beetsQuestion.response = <span class="string">"I also like beets. (But not with cheese.)"</span></span><br></pre></td></tr></table></figure></p><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>Swift 为属性均有默认值和没有构造器的结构体或类提供了一个 默认构造器 。默认构造器创建了一个所有属性都有默认值的新实例。</p><p>例子中定义了一个名为 <code>ShoppingListItem</code> 的类，并封装了购物清单中物品的名字，数量和购买状态：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure></p><p>因为 <code>ShoppingListItem</code> 类的所有属性都有默认值，而且它是一个没有父类的基类，所以 <code>ShoppingListItem</code> 自动获得了一个默认构造器以创建一个新的实例，并为其所有属性设置默认值。（ <code>name</code> 属性是一个关联值类型为 <code>String</code> 的可选类型，虽然代码中没有写，但它会自动接收默认值 <code>nil</code>。） 上面的例子使用 <code>ShoppingListItem()</code> 这种形式的构造语法调用默认构造器为 <code>ShoppingListItem</code> 类创建了一个新的实例，并将这个新的实例赋值给名为 <code>item</code> 的变量。</p><h2 id="结构体类型的成员构造器"><a href="#结构体类型的成员构造器" class="headerlink" title="结构体类型的成员构造器"></a>结构体类型的成员构造器</h2><p>如果结构体没有任何自定义构造器，那么结构体类型会自动接收一个 <strong>成员构造器</strong>。不同于默认构造器，即使结构体的存储属性没有默认值，它也会接收成员构造器。</p><p>成员构造器是初始化结构体实例所有成员属性的便捷方法。实例的属性初始值通过参数名称传给成员构造器。</p><p>下面的例子定义了一个名为 <code>Size</code> 的结构体并有名为 <code>width</code> 和 <code>height</code> 的两个属性。通过为属性分配一个默认值 <code>0.0</code> 从而推断出属性类型是 <code>Double</code>。</p><p><code>Size</code> 结构体自动接收了成员构造器 <code>init(width:height:)</code>，用于初始化一个新的 <code>Size</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo = <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure></p><h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>构造器可以调用其他构造器来执行实例的部分构造过程。这个过程称之为 <strong>构造器代理</strong> ，以避免多个构造器之间的重复代码。</p><p>构造器代理的工作规则和形式规则都不同于值类型或类类型。值类型（ 结构体和枚举 ）不支持继承，所以其构造代理过程相对简单，因为他们只能代理给自己提供的其他构造器。如 继承 中所述，类是可以继承于其他类的。这意味着类有确保在构造期间将继承来的存储属性合理赋值的额外责任。这些责任稍后会在 类的继承和构造过程 中介绍。</p><p>对于值类型，在自定义构造器中使用 <code>self.init</code> 来引用同一类型中的其他构造器。你只能在构造器中调用 <code>self.init</code>。</p><p>如果你为值类型定义了一个自定义构造器，你将无法再访问该类型的默认构造器（ 如果是结构体就是成员构造器 ）。这个约束避免了一种缺陷，就是某人使用了某个自动构造器而意外绕开了一个带有额外必要设置且更复杂的构造器。</p><div class="note warning"><p>注意<br>如果你想让你的自定义类型可以使用默认构造器，成员构造器，自定义构造器来进行初始化，就把自定义构造器写在扩展中，而不是作为值类型原始实现的一部分。更多详情，请参阅 扩展。</p></div><p>下面的例子定义了一个用以表示几何矩形的结构体 <code>Rect</code> 。这个例子需要名为 <code>Size</code> 和 <code>Point</code> 的两个辅助结构体，它们都为自己所有属性提供了一个默认值 <code>0.0</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用以下三种方式中的任意一种来初始化结构体 <code>Rect</code>— 使用默认值为 <code>0</code> 的 <code>origin</code> 和 <code>size</code> 属性，提供指定的 <code>origin</code> 和 <code>size</code>，或是提供指定的 <code>center</code> 和 <code>size</code>。在结构体的定义中用三种自定义构造器来表示这三种构造方式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个 <code>Rect</code> 构造器，<code>init()</code>，与结构体没自定义构造器时接收的默认构造器功能相同。用一堆大括号 <code>{}</code> 来表示此构造器为空。调用这个构造器返回一个 <code>Rect</code> 实例，其 <code>origin</code> 和 <code>size</code> 属性使用属性定义时的默认值 <code>Point(x: 0.0, y: 0.0)</code> 和 <code>Size(width: 0.0, height: 0.0)</code> 来初始化：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> basicRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="comment">// basicRect 的 origin 是（ 0.0，0.0 ），它的 size 是（ 0.0，0.0 ）</span></span><br></pre></td></tr></table></figure></p><p>第二个 <code>Rect</code> 构造器，<code>init(origin:size:)</code>，与结构体没自定义构造器时接收的成员构造器功能相同。这个构造器只是简单的把 <code>origin</code> 和 <code>size</code> 参数值赋值给适当的存储属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br><span class="line"><span class="comment">// originRect 的 origin 是（ 2.0，2.0 ），它的 size 是（ 5.0，5.0 ）</span></span><br></pre></td></tr></table></figure></p><p>第三个 <code>Rect</code> 构造器，<code>init(center:size:)</code>，稍微有些复杂。先基于 <code>center</code> 和 <code>size</code> 的值计算了合适的原点。然后调用（ 或是代理给 ）构造器 <code>init(origin:size:)</code> 以在合适的属性中存储新的 <code>origin</code> 和 <code>size</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// // centerRect 的 origin 是（ 2.5，2.5 ），它的 size 是（ 3.0，3.0 ）</span></span><br></pre></td></tr></table></figure></p><p>构造器 <code>init(center:size:)</code> 可以把 <code>origin</code> 和 <code>size</code>的新值赋给合适的属性。然而构造器 <code>init(center:size:)</code> 利用已提供了相同功能的现有构造器会更方便（ 并且意图更清晰 ）。</p><h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><p>类的所有存储属性 — 包括任何从父类继承而来的属性 — 必须 在构造过程期间赋值。</p><p>Swift 给类类型定义了两种构造器以确保所有存储属性都能接收到初始值。它们分别是指定构造器和便利构造器。</p><h3 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h3><p><strong>指定构造器</strong> 是类的主要构造器。一个指定构造器初始化该类引入的所有属性，并调用合适的父类构造器以继续父类链上的构造过程。</p><p>类往往只有很少的指定构造器，通常一个类只有一个指定构造器。指定构造器是构造过程发生的『漏斗（funnel）』点，通过该点将构造过程持续到其父类链。</p><p>每个类至少要有一个指定构造器。如同稍后在 <strong>自动构造器的继承</strong> 中描述的那样，一些情况下，这个条件都是继承父类的一个或多个指定构造器而满足的。</p><p>其次是 <strong>便利构造器</strong>，类的辅助构造器。你可以定义便利构造器来调用同一类中的指定构造器并为指定构造器的一些参数设置默认值。你也可以定义便利构造器为特殊用例类或是输入类型类创建实例。</p><p>你应当只在你的类需要时而为其提供便利构造器。相比普通的构造模式，创建便利构造器会节省很多时间并将类的构造过程变得更加清晰。</p><h3 id="指定构造器和便利构造器的语法"><a href="#指定构造器和便利构造器的语法" class="headerlink" title="指定构造器和便利构造器的语法"></a>指定构造器和便利构造器的语法</h3><p>类的指定构造器和值类型的简单构造器写法相同：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>便利构造器有着相同风格的写法，但是在 <code>init</code> 关键字之前需要放置 <code>convenience</code> 修饰符，并使用空格来分隔：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类的构造代理"><a href="#类的构造代理" class="headerlink" title="类的构造代理"></a>类的构造代理</h3><p>为了简化指定构造器和便利构造器之间的关系。Swift 对构造器之间的代理采用了如下三条规则：</p><p><strong>规则 1</strong></p><ul><li>指定构造器必须调用其直系父类的指定构造器。</li></ul><p><strong>规则 2</strong></p><ul><li>便利构造器必须调用 同一 类中的其他构造器。</li></ul><p><strong>规则 3</strong></p><ul><li>便利构造器最后必须调用指定构造器。</li></ul><p>简单的记忆方法：</p><ul><li>指定构造器必须 向上 代理。</li><li>便利构造器必须 横向 代理。</li></ul><p>下图解释了这些规则<br><img src="/2018/10/18/Swift构造过程/构造过程01.png"><br>父类有一个指定构造器和两个便利构造器。一个便利构造器调用另一个便利构造器，后者又调用指定构造器。这符合上述规则 2 和规则 3。 父类本身并没有父类，所以规则 1 不适用。</p><p>该图中的派生类有两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的一个，因为它只能调用同一类中的其他构造器。这符合上述规则 2 和规则 3。两个指定构造器必须调用父类中唯一的指定构造器，所以也符合上述规则 1。</p><div class="note warning"><p>注意<br>这些规则并不影响每个类 创建 实例。上图中的任何构造器都可以用于为其所属类创建完全初始化的实例。这些规则只会影响类的构造器实现。</p></div><p>下图展示了一个关于四个类之间更复杂的层级结构。它解释了这个层级结构中的指定构造器如何在类的构造过程中饰演『 漏斗（<code>funnel</code>）』点，并简化了构造链中类之间的关系：<br><img src="/2018/10/18/Swift构造过程/构造过程02.png"></p><h2 id="两段式构造器过程"><a href="#两段式构造器过程" class="headerlink" title="两段式构造器过程"></a>两段式构造器过程</h2><p>Swift 中类的构造过程是两段式处理。第一阶段，为类引入的每个存储属性赋一个初始值。一旦确定了所有存储属性的初始状态，第二阶段开始，在新的实例被认为可以使用前，每个类都有机会进一步定制其存储属性。</p><p>两段式构造过程的使用让构造过程更安全，同时对于类层级结构中的每个类仍然给予完全的灵活性。两段式构造过程防止了属性在初始化前访问其值，并防止其他构造器意外给属性赋予不同的值。</p><div class="note warning"><p>注意<br>Swift 的两段式构造过程类似于 <code>Objective-C</code> 的构造过程。主要区别就是在第一阶段期间，<code>Objective-C</code> 对每个属性赋值为 <code>0</code> 或空（例如 <code>0</code> 或 <code>nil</code>），Swift 的构造过程的流程就更灵活，允许设置自定义初始值，并能应付一些 <code>0</code> 或 <code>nil</code> 不能作为有效默认值的类型。</p></div><p>Swift 的编译器执行了四个有帮助的安全检查以确保两段式构造过程无误完成：</p><p><strong>安全检查 1</strong></p><p>指定构造器必须确保其类引入的所有属性在向上代理父类构造器之前完成初始化。</p><p>如上所述，一个对象的内存只在其所有存储属性初始状态已知时才被认为完全初始化。为了符合此规则，指定构造器必须确保其所属类拥有的属性在向上代理前完成初始化。</p><p><strong>安全检查 2</strong></p><p>指定构造器必须在继承属性赋值前向上代理父类构造器，否则，便利构造器赋予的新值将被父类构造过程的一部分重写。</p><p><strong>安全检查 3</strong></p><p>便利构造器必须在 任何 属性（包括同一类中定义的属性）赋值前代理另一个构造器。否则便利构造器赋予的新值将被其所属类的指定构造器重写。</p><p><strong>安全检查 4</strong></p><p>构造器在第一阶段构造过程完成前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。</p><hr><p>类实例在第一阶段完成前并不是完全有效的。一旦第一阶段结束，类实例才是有效的，才能访问属性，调用方法。</p><p>以下是基于以上四个安全检查的两段式构造过程的流程：</p><p><strong>阶段 1</strong></p><ul><li>在类中调用指定或便利构造器。</li><li>对一个新实例分配内存，但内存没还没有初始化。</li><li>指定构造器确认其所属类的所有存储属性都有值。现在那些存储属性的内存初始化完成。</li><li>指定构造器移交给父类构造器以为其存储属性执行相同的任务。</li><li>这个过程沿着类的继承链持续向上，直到到达继承链的顶端。</li><li>一旦到达链的顶端，并且链中最后的类确保其所有存储属性都有值，则认为实例的内存已经完全初始化，至此阶段 1 完成。</li></ul><p><strong>阶段 2</strong></p><ul><li>从链顶端往下，链中每个指定构造器都可以选择进一步定制实例，构造器现在可以访问 self 并修改它的属性，调用实例方法，等等。</li><li>最终，在链中的任何便利构造器也都可以选择定制实例以及使用 self 。</li></ul><p>以下展示了假设的派生类和父类之间的构造过程阶段 1：<br><img src="/2018/10/18/Swift构造过程/构造过程03.png"><br>在这个例子中，构造过程开始于在派生类上调用一个便利构造器。便利构造器还不能修改任何属性。它横向代理了同一类中的指定构造器。</p><p>根据安全检查 1，指定构造器确保派生类的所有属性都有值，然后在它的父类上调用指定构造器以持续链上的构造过程。</p><p>父类的指定构造器确保父类所有属性都有值。这里没有父类要初始化，所以所无需进一步代理。</p><p>一旦父类的所有属性都有了初始值，就认为其内存完全初始化，此时阶段 1 完成。</p><p>以下展示了同一构造过程 阶段 2 ：<br><img src="/2018/10/18/Swift构造过程/构造过程04.png"><br>父类的指定构造器现在有机会进一步定制实例了（尽管不做也可以）。</p><p>一旦父类的指定构造器调用结束，派生类的指定构造器就可以执行额外的自定义设置（尽管这也可不做）。</p><p>最终，派生类的指定构造器调用结束，最初调用的便利构造器可执行额外的自定义设置。</p><h2 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h2><p>与 Objective-C 的派生类不同，Swift 的派生类默认不继承其父类构造器。Swift 这种机制防止了更定制化的派生类继承父类的简单构造器，也防止将简单构造器用于创建不完全初始化或是错误初始化的派生类实例。</p><div class="note warning"><p>注意<br>在安全和适合的情况下，父类构造器是可以继承的。详情请参阅 <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID222" target="_blank" rel="noopener">自动构造器的继承</a> 。</p></div><p>如果你想要自定义派生类有一个或多个与其父类相同的构造器，你可以在子类中提供这些自定义构造器的实现。</p><p>当你在写一个与父类 指定 构造器相匹配的派生类构造器时，你是在有效的重写指定构造器。因此，你必须在派生类构造器的定义前写上修饰符 <code>override</code> 。就像 默认构造器 中描述的那样，即使你重写的是一个自动提供的默认构造器，也要写上 <code>override</code> 。</p><p>重写属性，方法或是下标，修饰符 <code>override</code> 的存在提示着 Swift 去检查父类是否有匹配的指定构造器用于重写，并验证重写构造器的参数是否已按预期指定。</p><div class="note warning"><p>注意<br>重写父类指定构造器时总是要写修饰符 <code>override</code> 的，即使你实现的是派生类的便利构造器。</p></div><p>相反的，如果你写一个与父类 便利 构造器相匹配的派生类构造器，根据 类的构造器代理 规则，派生类是不能直接调用父类便利构造器的。因此，你的派生类（严格来说）没有重写父类构造器。所以，在提供与父类便利构造器相匹配的实现时，无需编写 修饰符 <code>override</code>。</p><p>下面的例子定义了一个名为 <code>Vehicle</code> 的基类。这个基类声明了一个名为 <code>numberOfWheels</code> 的存储属性，其默认值为 <code>Int</code> 类型的 <code>0</code>。名为 <code>description</code> 的计算属性用 <code>numberOfWheels</code> 属性创建一个表示交通工具特性的 <code>String</code> 类型描述。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(numberOfWheels) wheel(s)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Vehicle</code> 类为它仅有的存储属性提供了一个默认值，并且没有提供任何自定义构造器。因此，它自动接收了一个默认构造器，就如同 默认构造器 中描述的那样。默认构造器（在可用时）总是类中的指定构造器，并且可以用于创建一个 <code>numberOfWheels</code> 为 <code>0</code> 的新 <code>Vehicle</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vehicle = <span class="type">Vehicle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: \(vehicle.description)"</span>)</span><br><span class="line"><span class="comment">// Vehicle: 0 wheel(s)</span></span><br></pre></td></tr></table></figure></p><p>下面的例子定义了 Vehicle 的派生类 <code>Bicycle</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>派生类 <code>Bicycle</code> 定义了一个自定义构造器<code>init()</code>。这个指定构造器匹配于 <code>Bicycle</code> 父类的指定构造器，所以这个 <code>Bicycle</code> 版本的构造器使用修饰符 <code>override</code> 标记。</p><p><code>Bicycle</code> 的构造器 <code>init()</code> 首先调用 <code>super.init()</code>，它调用了 <code>Bicycle</code> 父类 <code>Vehicle</code> 的默认构造器。这确保在 <code>Bicycle</code> 有机会修改属性前 <code>Vehicle</code> 完成继承属性 <code>numberOfWheels</code> 的初始化。调用 <code>super.init()</code> 后，将 <code>numberOfWheels</code> 的原始值替换为新值 <code>2</code>。</p><p>如果你创建一个 <code>Bicycle</code> 的实例，你可以调用它的计算继承属性 <code>description</code> 以查看<code>numberOfWheels</code> 属性是如何更新的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: \(bicycle.description)"</span>)</span><br><span class="line"><span class="comment">// Bicycle: 2 wheel(s)</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>派生类可在构造过程期间可修改变量继承属性，但不能修改常量继承属性。</p></div><h2 id="自动构造器的继承"><a href="#自动构造器的继承" class="headerlink" title="自动构造器的继承"></a>自动构造器的继承</h2><p>如上所述，派生类默认不继承其父类构造器。然而，如果满足某些特定条件，父类构造器 是 可以被自动继承的。实际上，这意味着很多常见场景中你不需要重写构造器，并且可以安全的以最小代价继承父类构造器。</p><p>假设你为派生类引入的所有属性提供了默认值，请应用以下两条规则以达到自动继承的目的：</p><p><strong>规则 1</strong></p><p>如果你的派生类没有定义任何指定构造器，它会自动继承其父类的所有指定构造器。</p><p><strong>规则 2</strong></p><p>如果你的派生类为其父类的 所有 指定构造器都提供了实现 — 无论是按照规则 1 继承而来，或是定义时提供了自定义实现 — 它都会自动继承父类的所有便利构造器。</p><p>甚至在派生类进一步添加便利构造器时，这些规则仍然适用。</p><div class="note warning"><p>注意<br>派生类可以用便利构造器实现父类的指定构造器以作为满足规则 2 的一部分。</p></div><h2 id="实践指定构造器和便利构造器"><a href="#实践指定构造器和便利构造器" class="headerlink" title="实践指定构造器和便利构造器"></a>实践指定构造器和便利构造器</h2><p>下例在实践中展示了指定构造器，便利构造器和自动构造器的继承。该例定义了关于 <code>Food</code>，<code>RecipeIngredient</code> 和 <code>ShoppingListItem</code> 的层级关系，并演示了它们的构造器是如何相互作用的。</p><p>层级结构中的基类名为 <code>Food</code>，它是一个包装食品名称的简单类。<code>Food</code> 引入了一个名为 <code>name</code> 的 <code>String</code> 类型属性，并且提供了两个构造器以创建 <code>Food</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下图展示了构造链中的 <code>Food</code> 类：<br><img src="/2018/10/18/Swift构造过程/构造过程05.png"><br>类没有默认成员构造器，所以 <code>Food</code> 类提供了一个带有单个参数  <code>name</code> 的指定构造器。这个构造器可以使用一个指定的 <code>name</code> 属性值创建新的 <code>Food</code> 实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> namedMeat = <span class="type">Food</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="comment">// namedMeat 的 name 是 "Bacon"</span></span><br></pre></td></tr></table></figure></p><p><code>Food</code> 类的构造器 <code>init(name: String)</code> 是一个 指定 构造器，因为它确保了 <code>Food</code> 实例的所有存储属性被完全初始化。<code>Food</code> 类没有父类，所以构造器 <code>init(name: String)</code> 不需要调用 <code>super.init()</code> 完成其构造过程。</p><p><code>Food</code> 类也提供了一个没有参数的 便利 构造器 <code>init()</code>。便利构造器 <code>init()</code> 横向代理 <code>Food</code> 类的指定构造器 <code>init(name: String)</code>，并为其构造参数 <code>name</code> 传值 <code>[Unnamed]</code> 以为新食物提供一个默认占位名。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mysteryMeat = <span class="type">Food</span>()</span><br><span class="line"><span class="comment">// mysteryMeat 的 name 是 "[Unnamed]"</span></span><br></pre></td></tr></table></figure></p><p>层级结构中的第二个类是 <code>Food</code> 的派生类 <code>RecipeIngredient</code>。<code>RecipeIngredient</code> 类模型是食谱中的一种配料。它引入了一个 <code>Int</code> 类型的属性 <code>quantity</code>（以及从父类 <code>Food</code> 继承而来的 <code>name</code> 属性）并定义了两个创建 <code>RecipeIngredient</code> 实例的构造器：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面展示了构造链中的 <code>RecipeIngredient</code> 类：<br><img src="/2018/10/18/Swift构造过程/构造过程06.png"><br><code>RecipeIngredient</code> 类有一个指定构造器，<code>init(name: String, quantity: Int)</code>，用于填充 <code>RecipeIngredient</code> 实例的所有属性。该构造器首先将传递而来的构造参数 <code>quantity</code> 的值赋给<code>RecipeIngredient</code> 唯一引入的新属性 <code>quantity</code>。然后，构造器向上代理 <code>Food</code>类的构造器 <code>init(name: String)</code>。这个过程符合上述 两段式构造过程 中的安全检查 1。</p><p><code>RecipeIngredient</code> 也定义了一个便利构造器，<code>init(name: String)</code>，用于单独使用 <code>name</code> 来创建一个 <code>RecipeIngredient</code> 实例。这个便利构造器假设任何 <code>RecipeIngredient</code>实例的 <code>quantity</code> 为 1，所以不需要显示指定 <code>quantity</code>  即可创建实例。便利构造器的定义可以更快捷，方便的创建 <code>RecipeIngredient</code> 实例，并在创建多个 <code>quantity</code> 为 1 的 <code>RecipeIngredient</code> 实例时避免重复代码。这个便利构造器只是简单的横向代理了类的指定构造器，并为 <code>quantity</code> 传值 1。</p><p><code>RecipeIngredient</code> 类的便利构造器 <code>init(name: String)</code> 使用与 <code>Food</code> 类的 指定 构造器 <code>init(name: String)</code> 相同的参数。因为这个便利构造器就是重写了父类的指定构造器，所以必须使用修饰符 <code>override</code> 标记（详情请见 构造器的继承与重写）。</p><p>即使 <code>RecipeIngredient</code> 提供了一个便利构造器 <code>init(name: String)</code>，但是由于 <code>RecipeIngredient</code> 为父类所有指定构造器提供了实现。因此，<code>RecipeIngredient</code> 也自动继承了父类的所有便利构造器。</p><p>这个例子中，<code>RecipeIngredient</code> 的父类是 <code>Food</code>，它有一个便利构造器 <code>init()</code>。因此这个构造器由 <code>RecipeIngredient</code> 继承。继承版本的 <code>init()</code> 方法与 <code>Food</code> 版本的相同，除了它代理了 <code>RecipeIngredient</code> 版本的 <code>init(name: String)</code>，而不是 <code>Food</code> 的。</p><p>这三个构造器都可以用于创建新的 <code>RecipeIngredient</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMysteryItem = <span class="type">RecipeIngredient</span>()</span><br><span class="line"><span class="keyword">let</span> oneBacon = <span class="type">RecipeIngredient</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="keyword">let</span> sixEggs = <span class="type">RecipeIngredient</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p>层级结构中的第三个也是最后一个类是 <code>RecipeIngredient</code> 的派生类 <code>ShoppingListItem</code>。ShoppingListItem 类模型是购物清单中出现的一种食谱配料。</p><p>购物清单中的每项物品开始时都是『<code>未购买状态</code>』。为了表示这一事实，<code>ShoppingListItem</code>引入 <code>Boolean</code> 类型属性 <code>purchased</code>，其默认值是false。<code>ShoppingListItem</code> 也添加了一个计算属性 <code>description</code>，用于为 <code>ShoppingListItem</code> 实例提供文本描述：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="string">"\(quantity) x \(name)"</span></span><br><span class="line">        output += purchased ? <span class="string">" ✔"</span> : <span class="string">" ✘"</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br><code>ShoppingListItem</code> 没有定义为 <code>purchased</code> 提供初始值的构造器，因为添加到购物清单中的物品（如同模型中那样）总是未购买的。</p></div><p>因为它为所有属性提供了一个默认值并且没有定义任何构造器，所以<code>ShoppingListItem</code> 自动继承了它父类的 所有 指定构造器和便利构造器。</p><p>下图展示了三个类的整体构造链：<br><img src="/2018/10/18/Swift构造过程/构造过程07.png"></p><p>三个继承构造器都可以用于创建新的 <code>ShoppingListItem</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> breakfastList = [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Bacon"</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name = <span class="string">"Orange juice"</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x Orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x Bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x Eggs ✘</span></span><br></pre></td></tr></table></figure></p><p>上面使用数组字面量的形式创建了一个包含三个 <code>ShoppingListItem</code> 实例的新数组 <code>breakfastList</code>。数组的类型被推断为 <code>[ShoppingListItem]</code>。数组创建后，数组中的第一个元素  <code>ShoppingListItem</code> 实例的名字从 <code>&quot;[Unnamed]&quot;</code> 修改为 <code>&quot;Orange juice&quot;</code> 并被标记为已购买。打印数组中每项物品的描述会显示它们的默认状态已按预期设置。</p><h2 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h2><p>有时定义类，结构体或是枚举，构造过程可以失败是很有帮助的。无效的构造参数值可能会触发这种失败，或是缺失某种需要的外部资源，又或是未能满足某种条件。</p><p>为了应对可能失败的构造过程，你可以为类，结构体，或是枚举定义一个或是多个可失败构造器。编写可失败构造器的语法就是在 init 关键字后面添加问号（<code>init?</code>）。</p><div class="note warning"><p>注意<br>你不能使用相同的参数类型或参数名定义一个可失败构造器后又定义一个非失败构造器。</p></div><p>可失败构造器会创建一个关联值类型是自身构造类型的 可选 类型。在可失败构造器中编写 <code>return nil</code> 以表示可以在任何情况下触发失败。</p><div class="note warning"><p>注意<br>严格来说，构造器没有返回值。它们的作用是确保构造过程结束时 self 可以完全并正确的初始化。虽然你写 <code>return nil</code> 是用于触发构造器失败，但表示构造成功是不会使用 <code>return</code> 关键字的。</p></div><p>例如，为数字类型转换实现可失败构造器。使用构造器 <code>init(exactly:)</code> 以确保数字类型之间的转换可以保持精准值。如果类型转换不能保持值不变，则构造失败。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wholeNumber: <span class="type">Double</span> = <span class="number">12345.0</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> valueMaintained = <span class="type">Int</span>(exactly: wholeNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(wholeNumber) conversion to Int maintains value of \(valueMaintained)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "12345.0 conversion to Int maintains value of 12345"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> valueChanged = <span class="type">Int</span>(exactly: pi)</span><br><span class="line"><span class="comment">// valueChanged 的类型是 Int?，不是 Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valueChanged == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(pi) conversion to Int does not maintain value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "3.14159 conversion to Int does not maintain value"</span></span><br></pre></td></tr></table></figure><p>下面的例子定义了结构体 <code>Animal</code>，它有一个 <code>String</code> 类型的常量属性 <code>species</code>。<code>Animal</code> 结构体也定义了一个只有一个构造参数 <code>species</code> 的可失败构造器。该构造器检查传递给构造器的 <code>species</code> 参数值是否为空字符串。如果是空字符串，则触发构造失败。否则，将其赋值给 <code>species</code> 属性，构造过程成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用可失败构造器尝试初始化一个 <code>Animal</code> 实例，并且检查是否构造成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCreature = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>)</span><br><span class="line"><span class="comment">// someCreature 的类型是 Animal?，不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = someCreature &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An animal was initialized with a species of \(giraffe.species)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "An animal was initialized with a species of Giraffe"</span></span><br></pre></td></tr></table></figure></p><p>如果你给可失败构造器的 <code>species</code> 参数传了一个空字符串，构造器就会触发构造失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anonymousCreature = <span class="type">Animal</span>(species: <span class="string">""</span>)</span><br><span class="line"><span class="comment">// anonymousCreature 的类型是 Animal?，不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anonymousCreature == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The anonymous creature could not be initialized"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The anonymous creature could not be initialized"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>检查空字符串值（例如 <code>&quot;&quot;</code> 而不是 <code>&quot;Giraffe&quot;</code>）和检查值为 <code>nil</code> 的关联值类型是 <code>String</code> 的 可选 类型是完全不同的概念。在上面的例子中，一个 <code>String</code> 类型的空字符串（<code>&quot;&quot;</code>）是有效的。然而，空字符串作为 <code>animal</code> 的 <code>species</code> 属性值明显不合适。因此要限制模型，如果是空字符串可失败构造器应该触发构造失败。</p></div><h3 id="枚举的可失败构造器"><a href="#枚举的可失败构造器" class="headerlink" title="枚举的可失败构造器"></a>枚举的可失败构造器</h3><p>你可以使用可失败构造器选择基于一个或多个参数的枚举成员。如果提供的参数不符合任何一个枚举成员，则构造失败。</p><p>下例定义了枚举 <code>TemperatureUnit</code>，以及三种可能有的状态<br>(<code>kelvin</code>，<code>celsius</code> 和 <code>fahrenheit</code>）。可失败构造器用于找到一个与代表温度符号的 <code>Character</code> 类型的值相符合的枚举成员：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin, celsius, fahrenheit</span><br><span class="line">    <span class="keyword">init</span>?(symbol: <span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"K"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .kelvin</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .celsius</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"F"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .fahrenheit</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用可失败构造器在三种可能的状态中选择一个合适的枚举成员，如果参数与三个状态中的任何一个都不匹配就会引起构造失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure></p><h3 id="带有原始值枚举的可失败构造器"><a href="#带有原始值枚举的可失败构造器" class="headerlink" title="带有原始值枚举的可失败构造器"></a>带有原始值枚举的可失败构造器</h3><p>带原始值的枚举会自动接收一个可失败构造器 <code>init?(rawValue:)</code>，它有一个名为 <code>rawValue</code> 的参数，其类型是相应的原始值类型，如果找到了相匹配的枚举成员，就构造该枚举成员，否则构造失败。</p><p>你可以使用 <code>Character</code> 类型的原始值重写上例的 <code>TemperatureUnit</code> 以更好的利用构造器 <code>init?(rawValue:)</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin = <span class="string">"K"</span>, celsius = <span class="string">"C"</span>, fahrenheit = <span class="string">"F"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure></p><h3 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h3><p>类、结构体或枚举的可失败构造器可以横向代理同一类型中的其他可失败构造器。类似的，派生类的可失败构造器可以向上代理其父类的可失败构造器。</p><p>任意情况下，如果你代理了其他构造器而导致构造失败。整个构造过程立即失败，不再进一步执行构造代码。</p><div class="note warning"><p>注意<br>一个可失败构造可以代理一个非失败构造器。如果你需要添加一个可能失败的状态到现有构造过程，请使用这个办法，否则将会构造失败。</p></div><p>下例定义了 <code>Product</code> 的派生类 <code>CartItem</code>。<code>CartItem</code> 类模型是一个在线购物车中的物品。<code>CartItem</code> 引入了一个常量存储属性 <code>quantity</code> 并确保这个属性值起码为 <code>1</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CartItem</code> 的可失败构造器首先验证是否接收到了值为 <code>1</code> 或更大的 <code>quantity</code>。如果 <code>quantity</code> 是无效的，整个构造过程立即失败，构造代码不再执行。同样，<code>Product</code> 检查可失败构造器的 <code>name</code> 值，如果 <code>name</code> 是空字符串构造会立即失败。</p><p>如果你使用非空的 <code>name</code>，值为 <code>1</code> 或是更大值的 <code>quantity</code> 创建了一个 <code>CartItem</code> 实例，那么构造成功：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks = <span class="type">CartItem</span>(name: <span class="string">"sock"</span>, quantity: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: \(twoSocks.name), quantity: \(twoSocks.quantity)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Item: sock, quantity: 2"</span></span><br></pre></td></tr></table></figure></p><p>如果你尝试使用值为 <code>0</code> 的 <code>quantity</code> 创建一个 <code>CartItem</code> 实例，<code>CartItem</code> 构造器则会引发构造过程失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts = <span class="type">CartItem</span>(name: <span class="string">"shirt"</span>, quantity: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize zero shirts"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize zero shirts"</span></span><br></pre></td></tr></table></figure></p><p>相似的，如果你尝试使用空 <code>name</code> 值去创建一个 <code>CartItem</code> 实例，其父类 <code>Product</code> 的构造器也会引发构造过程失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed = <span class="type">CartItem</span>(name: <span class="string">""</span>, quantity: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize one unnamed product"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize one unnamed product"</span></span><br></pre></td></tr></table></figure></p><h3 id="重写可失败构造器"><a href="#重写可失败构造器" class="headerlink" title="重写可失败构造器"></a>重写可失败构造器</h3><p>你可以在派生来中重写父类的可失败构造器，就像其他构造器那样。或是你可以用派生类的 非失败 构造器重写父类的可失败构造器。这允许你定义一个不会构造失败的派生类，即使父类的构造过程允许失败。</p><p>注意如果你使用非失败的派生类构造器重写了可失败的父类构造器，向上代理父类构造器的唯一的方法就是强制解包（<code>force-unwrap</code>）可失败父类构造器的结果。</p><div class="note warning"><p>注意<br>你可以使用非失败构造器重写可失败构造器，但是反过来不行。</p></div><p>下例定义了一个类 <code>Document</code>。这个类模型是一个文档，它可以使用属性值为非空字符串或是 <code>nil</code> 的 <code>name</code> 初始化，但不能是空字符串：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 该构造器使用值为 nil 的 name 创建文档</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 该构造器使用非空值的 name 创建文档</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的例子定义了 <code>Document</code> 的子类 <code>AutomaticallyNamedDocument</code>，派生类 <code>AutomaticallyNamedDocument</code> 重写了继承自 <code>Document</code> 的两个指定构造器。如果实例没有使用 <code>name</code> 初始化，或是传递给构造器 <code>init(name:)</code> 的参数值是空字符串，重写构造器确保了 <code>AutomaticallyNamedDocument</code> 实例的 <code>name</code> 属性有一个初始值<code>&quot;[Untitled]&quot;</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AutomaticallyNamedDocument</code> 使用非失败构造器 <code>init(name:)</code> 重写了父类的可失败构造器 <code>init?(name:)</code>。因为 <code>AutomaticallyNamedDocument</code> 使用与父类不同的方式处理了空字符串，所以不在需要可失败构造器，因此提供了一个非失败版本的构造器代替继承而来的可失败构造器。</p><p>作为实现派生类非失败构造器实现的一部分，你可以在构造器中强制解包以调用父类的可失败构造器。例如，下面的派生类 <code>UntitledDocument</code> 的 <code>name</code> 总是 <code>&quot;[Untitled]&quot;</code>，并且它在构造器期间使用了父类的可失败构造器 <code>init(name:)</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UntitledDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"[Untitled]"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中，如果调用父类的构造器 <code>init(name:)</code> 时传入空字符串作为 <code>name</code> 的值，强制解包操作将会导致运行时错误。然而，由于它使用的是常量字符串，你可以看见构造器并不会失败，所以这个例子中也不会发生运行时错误。</p><h3 id="init-可失败构造器"><a href="#init-可失败构造器" class="headerlink" title="init! 可失败构造器"></a>init! 可失败构造器</h3><p>通常使用在关键字 <code>init</code> 后面放置问号（<code>init?</code>）的方式来定义一个可失败构造器，用于创建一个适当的可选类型实例。你也可以定义一个可失败构造器，将其用于创建一个适当的隐式解包可选类型的实例。为了定义这个可失败构造器，在关键字 <code>init</code> 后面用叹号来替代问号（<code>init!</code>）。</p><p>你可以从 <code>init?</code> 代理到 <code>init!</code> 反之亦然，并且可以使用 <code>init!</code> 重写 <code>init?</code> 反之亦然。你也可以从 <code>init</code> 代理到 <code>init!</code>，不过在 <code>init!</code> 构造失败时会触发断言。</p><h2 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h2><p>在类构造器的定义前写修饰符 <code>required</code> 以指明该类的每个派生类必须实现此构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 在这实现构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每个派生类实现必要构造器时也必须在构造器前面写修饰符  <code>required</code>，以指明构造器要求应用于继承链中所有派生类。重写一个必要指定构造器时无需写修饰符 <code>override</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 在这实现派生类的必要构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>如果派生类符合继承构造器的要求，则无需在派生类中为必要构造器提供显式实现。</p></div><h2 id="使用闭包或函数设置默认属性值"><a href="#使用闭包或函数设置默认属性值" class="headerlink" title="使用闭包或函数设置默认属性值"></a>使用闭包或函数设置默认属性值</h2><p>如果一个存储属性的默认值需要某些自定义或设置，你可以使用闭包或是全局函数为该属性提供自定义默认值。每当该属性所属类型的新实例被初始化时，闭包或函数就会被调用，其返回值就会作为该属性的默认值。</p><p>这种函数或闭包通常会创建一个与属性类型相同类型的临时值，为满足预期的初始状态而处理其值，然后返回该临时值作为属性的默认值。</p><p>以下是如何使用闭包作为属性默认值的大致轮廓：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> = &#123;</span><br><span class="line">        <span class="comment">// 在闭包中创建一个带有默认值的 someProperty</span></span><br><span class="line">        <span class="comment">// someValue 的类型必须是 SomeType</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意那个闭包的结束是在大括号后面尾随一对空括号。这告诉 Swift 立即执行闭包。如果你忽略了这对括号，则为试图将闭包本身赋值给属性，而不是闭包的返回值。</p><div class="note warning"><p>注意<br>如果你使用闭包初始化属性，记住在闭包执行时其他实例还未初始化。这意味着无法在闭包中访问其他属性值，即使那些属性有默认值。你也不能隐式使用 <code>self</code> 属性，或是调用实例方法。</p></div><p>下例定义了一个结构体 <code>Chessboard</code>，其模型是国际象棋的棋盘。国际象棋是 8 x 8 黑白格交替的棋盘。<br><img src="/2018/10/18/Swift构造过程/构造过程08.png"><br>为了表示这个棋盘，结构体 <code>Chessboard</code> 有一个属性 <code>boardColors</code>，它是一个存储 <code>64</code> 个 <code>Bool</code> 类型值的数组。在数组中，值为 <code>true</code> 代表黑格，值为 <code>false</code> 代表白格。数组中的第一个值表示棋盘左上角的格子，数组中最后一个元素代表棋盘右下角的格子。</p><p>使用闭包设置颜色值并初始化数组 <code>boardColors</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chessboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard = [<span class="type">Bool</span>]()</span><br><span class="line">        <span class="keyword">var</span> isBlack = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">8</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack = !isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack = !isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">squareIsBlackAt</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row * <span class="number">8</span>) + column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每当一个新的 <code>Chessboard</code> 实例创建时，都会执行闭包，并且会返回已计算的 <code>boardColors</code> 默认值。上例中的闭包为棋盘上的每一格计算合适的颜色并将其值保存在临时数组 <code>temporaryBoard</code> 中，一旦完成设置就将 <code>temporary</code> 数组作为闭包的返回值返回。返回的数组保存在 <code>boardColors</code> 中并可以使用效用函数 <code>squareIsBlackAt(row:column:)</code> 查询：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> board = <span class="type">Chessboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 打印 "true"</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">7</span>, column: <span class="number">7</span>))</span><br><span class="line"><span class="comment">// 打印 "false"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;实例的准备过程，这个过程包含了设置实例每个存储属性的初始值并在实例使用之前执行全部所需的其他设置或初始化。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="构造过程" scheme="https://hadesxiye.github.io/tags/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 继承</title>
    <link href="https://hadesxiye.github.io/2018/10/17/Swift%E7%BB%A7%E6%89%BF/"/>
    <id>https://hadesxiye.github.io/2018/10/17/Swift继承/</id>
    <published>2018-10-17T11:50:39.000Z</published>
    <updated>2018-12-06T07:20:21.760Z</updated>
    
    <content type="html"><![CDATA[<p><center>一个类可以 <strong>继承</strong> 另一个类的方法，属性以及其他特性。当一个类继承另一个类时，继承类称为 <strong>子类</strong>，被继承类称为 <strong>父类</strong>。在 Swift 中，继承是类类型区别于其他类型的基本特性。</center><br><a id="more"></a><br>Swift 中的子类可以调用和访问父类的方法，属性和下标，还可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会通过检查重写的定义和父类的定义是否匹配来帮助确保重写是正确的。</p><p>子类还可以给继承的属性添加属性观察器，以便在属性值发生变化时得到通知。属性观察器可以被添加到任何属性，不管它原始定义是储存属性还是计算属性</p><h2 id="定义一个基类"><a href="#定义一个基类" class="headerlink" title="定义一个基类"></a>定义一个基类</h2><p>不继承任何类的类被称为 <strong>基类</strong> 。</p><div class="note warning"><p>注意<br>Swift 中的类并不继承自一个统一的类。定义类时如果不指定父类那么该类自动成为基类。</p></div><p>下面的代码样例定义了一个基类 <code>Vehicle</code>。这个基类定义了一个存储属性 <code>currentSpeed</code>，其默认值为 <code>0.0</code>（推断该属性类型为 <code>Double</code> ）。和一个只读的 <code>String</code> 类型的计算属性 <code>description</code>，<code>description</code> 使用 <code>currentSpeed</code> 的值来创建车辆的描述。</p><p>基类 <code>Vehicle</code> 还定义了一个空方法 <code>makeNoise</code>。这个方法之后会被 <code>Vehicle</code> 的子类重写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"traveling at \(currentSpeed) miles per hour"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 空方法，不是所有车辆都发出噪音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用 初始化语法 来创建一个 <code>Vehicle</code> 的实例，用类型名并紧跟小括号来表示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someVehicle = <span class="type">Vehicle</span>()</span><br></pre></td></tr></table></figure></p><p>你可以访问已经创建的 <code>Vehicle</code> 实例的 <code>description</code> 属性来打印人类可读的车辆当前速度的描述：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: \(someVehicle.description)"</span>)</span><br><span class="line"><span class="comment">// Vehicle: traveling at 0.0 miles per hour</span></span><br></pre></td></tr></table></figure></p><p><code>Vehicle</code> 类定义了车辆共有的特性，但其本身并没有太大作用。为了使其更加有用，你需要优化它来描述更具体的车辆类型。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>子类化 是在已有类的基础上创建新类的行为。 子类可以继承父类的特性，然后对其进行更改。你还可以为子类添加新的特性。</p><p>为了表示一个类拥有父类，声明子类时要在后面写上父类的类名，使用冒号分割：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeSuperclass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类在这里定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的例子中定义了一个叫 <code>Bicycle</code> 的类，它继承于父类 <code>Vehicle</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个新的类 <code>Bicycle</code> 会自动获取 <code>Vehicle</code> 类的所有特性，如 <code>currentSpeed</code> 、 <code>description</code> 属性和它的方法 <code>makeNoise()</code> 。</p><p>除了继承的特性外， <code>Bicycle</code> 类中还定义了一个新的存储属性 <code>hasBasket</code> ，它的初始值是 <code>false</code> （ 推断出该属性为 <code>Bool</code> 类型 ).</p><p>默认情况下，你新创建的任何 <code>Bicycle</code> 实例（自行车）都没有<code>basket</code>（篮子）。 <code>Bicycle</code> 实例创建之后，你可以将 <code>hasBasket</code> 属性修改为 <code>true</code> 来表示是否有 <code>basket</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line">bicycle.hasBasket = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>你也可以修改 <code>Bicycle</code> 实例继承的  <code>currentSpeed</code> 属性，还可以查询继承的 <code>description</code> 属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycle.currentSpeed = <span class="number">15.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: \(bicycle.description)"</span>)</span><br><span class="line"><span class="comment">// Bicycle: traveling at 15.0 miles per hour</span></span><br></pre></td></tr></table></figure></p><p>子类本身也是可以被继承的，下面的例子为 <code>Bicycle</code> 创建了一个名为「<code>tandem</code>」的双座自行车子类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tandem</span>: <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentNumberOfPassengers = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Tandem</code> 类继承了 <code>Bicycle</code> 类中所有的属性和方法，同时 <code>Bicycle</code> 类继承了 <code>Vehicle</code> 类中所有的属性和方法。<code>Tandem</code> 类还添加了一个新的存储属性 <code>currentNumberOfPassengers</code>，初始值为 <code>0</code> 。</p><p>如果你创建了一个 <code>Tandem</code> 类的实例， 则可以使用任何新创建的属性和继承的属性， 还可以查询从 <code>Vehicle</code> 类继承的只读属性 <code>description</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tandem = <span class="type">Tandem</span>()</span><br><span class="line">tandem.hasBasket = <span class="literal">true</span></span><br><span class="line">tandem.currentNumberOfPassengers = <span class="number">2</span></span><br><span class="line">tandem.currentSpeed = <span class="number">22.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Tandem: \(tandem.description)"</span>)</span><br><span class="line"><span class="comment">// Tandem: traveling at 22.0 miles per hour</span></span><br></pre></td></tr></table></figure></p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>一个子类可以对实例方法、类方法、实例属性、类属性或下标进行自定义实现，如果没有自定义则会从超类继承，这就是所谓的 重写 。</p><p>重写从父类继承的特性，你需要在定义重写时添加 <code>override</code> 前缀。这表明你打算重写一个特性并且没有使用错误的匹配定义。意外的重写会导致不可预料的行为，且任何没有使用 <code>override</code> 关键词修饰的重写声明在编译代码时会被标记为错误。</p><p><code>override</code> 关键词也提醒 Swift 编译器去检查你重写的这个类的超类（或它的某个父类）是否有匹配重写版本的声明。这个检查确保你的重写定义是正确无误的。</p><h3 id="访问父类的方法、属性和下标"><a href="#访问父类的方法、属性和下标" class="headerlink" title="访问父类的方法、属性和下标"></a>访问父类的方法、属性和下标</h3><p>当你在子类中重写方法、属性或下标时，有时把父类的实现作为重写的一部分是很有用的。例如，你可以优化现有的实现，或将修改后的值存储在现有的继承变量中。</p><p>在适当的情况下，应该用 <code>super</code> 前缀访问父类的方法、属性或下标：</p><p>一个名为  <code>someMethod()</code> 的重写方法可以在实现中通过 <code>super.someMethod()</code> 来调用父类的 <code>someMethod()</code> 方法。<br>一个名为 <code>someProperty</code> 的属性可以在重写 <code>getter</code> 或 <code>setter</code> 的实现中通过 <code>super.someProperty</code> 访问父类的 <code>someProperty</code> 属性。<br>一个 <code>someIndex</code> 的重写下标可以在重写下标的实现中通过 <code>super[someIndex]</code> 访问父类的相同下标。</p><h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>你可以通过在子类中重写继承的实例或类型方法来对方法的实现进行修改。</p><p>下面的例子定义了一个 <code>Vehicle</code> 的新子类 <code>Train</code>，在 <code>Train</code> 中重写了继承自 <code>Vehicle</code> 的 <code>makeNoise()</code> 方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Choo Choo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你创建一个 <code>Train</code> 的新实例并调用它的 <code>makeNoise()</code> 方法，你可以看到调用的是子类 <code>Train</code> 中的该方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> train = <span class="type">Train</span>()</span><br><span class="line">train.makeNoise()</span><br><span class="line"><span class="comment">// 输出 "Choo Choo"</span></span><br></pre></td></tr></table></figure></p><h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>可以重写继承的实例或类型属性，以便为该属性提供自己定义的 <code>getter</code> 和 <code>setter</code>，或给重写的属性添加属性观察器观测先前属性值的改变。</p><h3 id="重写属性的-Getters-和-Setters"><a href="#重写属性的-Getters-和-Setters" class="headerlink" title="重写属性的 Getters 和 Setters"></a>重写属性的 Getters 和 Setters</h3><p>无论继承的属性原来是存储属性还是计算属性，都可以提供自定义的 <code>getter</code>（如果 <code>setter</code> 适用，也包括 <code>setter</code>）来重写任何继承属性。子类不知道继承的属性是存储属性还是计算属性，子类只知道继承的属性具有特定的名称和类型。你必须始终声明要重写的属性的名称和类型，以使编译器能够检查你重写的属性是否与具有相同名称和类型的父类属性匹配。</p><p>通过在子类属性中重写 <code>getter</code> 和 <code>setter</code>，可以将继承的只读属性重写为读写属性，但是，你不能将继承的读写属性重写为只读属性。</p><div class="note warning"><p>注意<br>如果你重写属性的 <code>setter</code> 就必须同时重写属性的 <code>getter</code>。如果你不想在重写 <code>getter</code> 中修改继承属性的值，你可以简单地在 <code>getter</code> 中返回 <code>super.someProperty</code>，其中 <code>someProperty</code> 是你想要重写的属性名称。</p></div><p>下面的例子中定义了一个新的类 <code>Car</code> ，它是 <code>Vehicle</code> 的子类。<code>Car</code> 类声明了一个存储属性 <code>gear</code>，默认值为 <code>1</code> 。<code>Car</code> 还重写了从 <code>Vehicle</code> 中继承的 <code>description</code> 属性，用来提供包括当前档位的自定义描述：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gear = <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description + <span class="string">" in gear \(gear)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写的 <code>description</code> 属性首先调用了 <code>super.description</code> ，它返回的是 <code>Vehicle</code> 类中的 <code>description</code> 属性。然后， <code>Car</code> 类中重写的 <code>description</code> 版本在末尾添加了一些额外的文本，用来描述当前的档位：</p><p>如果你创建了一个 <code>Car</code> 类的实例并且设置了 <code>gear</code>  和 <code>currentSpeed</code> 属性，你就能看到它的 <code>description</code>  属性返回了 <code>Car</code> 类中重写过的描述：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line">car.currentSpeed = <span class="number">25.0</span></span><br><span class="line">car.gear = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Car: \(car.description)"</span>)</span><br><span class="line"><span class="comment">// Car: traveling at 25.0 miles per hour in gear 3</span></span><br></pre></td></tr></table></figure></p><h3 id="重写属性观察者"><a href="#重写属性观察者" class="headerlink" title="重写属性观察者"></a>重写属性观察者</h3><p>你可以用属性重写特性给一个继承属性增加属性观察者。 无论这个属性的初始值是多少，当它的值改变时你将会收到通知。</p><div class="note warning"><p>注意<br>你不能给常量存储属性或只读属性增加属性观察者。 因为这些属性值不能被修改，所以它是不能提供 <code>willSet</code> 或 <code>didSet</code> 的重写实现。<br><br>当然，你不能为同一个属性同时提供 <code>setter</code> 重写和 <code>didSet</code> 观察者。 如果你想观察这个属性值的改变，并且你已经为这个属性提供了一个重写的 <code>setter</code> 方法，那么你能在这个自定义 <code>setter</code> 方法里观察到它任何值的改变。</p></div><p>下面定义了一个叫 <code>AutomaticCar</code> 的新类， 它是 <code>Car</code> 的子类。<code>AutomaticCar</code> 表示一个能自动变速的汽车类，它能基于当前速度自动选择一个合适的档位：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear = <span class="type">Int</span>(currentSpeed / <span class="number">10.0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你更改 <code>AutomaticCar</code> 实例的 <code>currentSpeed</code> 属性值时，这个属性的 <code>didSet</code> 观察者将会观察到值的改变并根据新速度给 <code>gear</code> 属性设置一个合适的档位。按照换算规则，档位是新 <code>currentSpeed</code> 值除以 <code>10</code> 后四舍五入取整再 <code>+ 1</code> 的值。 例如，速度 <code>35.0</code> 将代表 <code>4</code> 档位：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> automatic = <span class="type">AutomaticCar</span>()</span><br><span class="line">automatic.currentSpeed = <span class="number">35.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"AutomaticCar: \(automatic.description)"</span>)</span><br><span class="line"><span class="comment">// 自动汽车： 当前行驶的速度是 35.0 mph， 档位为 4</span></span><br></pre></td></tr></table></figure></p><h3 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h3><p>你可以通过标记方法、属性或下标为 <code>final</code> 来防止它被重写。通过在方法、属性或下标前添加关键字 <code>final</code> （比如 <code>final var</code>、 <code>final func</code>、 <code>final class func</code> 和  <code>final subscript</code>）来完成此操作。</p><p>任何重写子类中的 <code>final</code> 方法、属性或下标的尝试都会在编译时报错。添加到类扩展中的方法、属性或下标页可以在扩展中标记为 <code>final</code>。</p><p>你可以通过在类的定义中 <code>class</code> 关键字前添加 <code>final</code> 修饰符将整个类标记为 <code>final</code>，比如 <code>final class</code>。任何对标记为 <code>final</code> 的类进行继承的子类都会在编译时报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;一个类可以 &lt;strong&gt;继承&lt;/strong&gt; 另一个类的方法，属性以及其他特性。当一个类继承另一个类时，继承类称为 &lt;strong&gt;子类&lt;/strong&gt;，被继承类称为 &lt;strong&gt;父类&lt;/strong&gt;。在 Swift 中，继承是类类型区别于其他类型的基本特性。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="继承" scheme="https://hadesxiye.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 下标</title>
    <link href="https://hadesxiye.github.io/2018/10/16/Swift%E4%B8%8B%E6%A0%87/"/>
    <id>https://hadesxiye.github.io/2018/10/16/Swift下标/</id>
    <published>2018-10-16T10:46:16.000Z</published>
    <updated>2018-12-10T09:48:17.444Z</updated>
    
    <content type="html"><![CDATA[<p><center>类、结构体和枚举可以定义 下标 ，它是用于访问集合，列表或序列的成员元素的快捷方式。 你可以直接使用下标来对值进行读写，而无需设置单独的读写方法。</center><br><a id="more"></a><br> 例如，你可以将 <code>Array</code> 实例中的元素作为 <code>someArray [index]</code> 访问，将 <code>Dictionary</code> 实例中的元素作为 <code>someDictionary [key]</code> 访问。</p><p>你可以为单个类型定义多个下标，并根据传递给下标的索引值的类型，选择要使用的相应下标进行重载。 下标不限于单个维度，你可以定义具有多个输入参数的下标以满足你自定义类型的需求。</p><h2 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h2><p>使用下标, 让你可以通过在实例名称后面的方括号中写入一个或多个值来查询类的实例。它们的语法类似于实例方法和计算属性语法。使用 <code>subscript</code> 关键字定义下标，并且和实例方法类似，可以指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或只读。和计算属性类似, 读写是由 <code>getter</code> 和 <code>setter</code> 方法实现的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里返回一个对应下标的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="comment">// 在这里执行对应的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>newValue</code> 的类型与下标的返回值相同。与计算属性一样，你可以选择不指定 <code>setter</code> 的 (<code>newValue</code>) 参数。但是如果你没有指定参数，那么 <code>newValue</code> 会成为你 <code>setter</code> 的默认参数。</p><p>与只读计算属性一样，你可以通过删除 <code>get</code> 关键字以及大括号来简化只读下标的声明：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里返回一个对应下标的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个只读下标实现的例子，它定义了一个 <code>TimesTable</code> 结构体来表示一个 <code>n</code> 倍整数表：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier * index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable = <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"six times three is \(threeTimesTable[6])"</span>)</span><br><span class="line"><span class="comment">// 输出 "six times three is 18"</span></span><br></pre></td></tr></table></figure></p><p>在这个例子中，创建了一个新的 <code>TimesTable</code> 实例来表示三倍表。通过将值 <code>3</code> 作为实例的 <code>multiplier</code> 参数值来初始化结构体。</p><p>你能够通过下标来调用 <code>threeTimesTable</code> 实例，比如调用 <code>threeTimesTable[6]</code>。这请求了三倍表中的第六项，返回 <code>18</code> ，也就是 <code>6</code> 的 <code>3</code> 倍。</p><div class="note warning"><p>注意<br><code>n</code> 倍表是基于固定的数学规则定义的。给 <code>threeTimesTable[someIndex]</code> 赋新值是不合适的，因此 <code>TimesTable</code> 的下标倍定义为只读下标。</p></div><h2 id="下标的用法"><a href="#下标的用法" class="headerlink" title="下标的用法"></a>下标的用法</h2><p>下标的准确含义依赖于使用它的上下文。下标通常被用来作为访问集合、列表或序列中的元素的快捷方式。你可以用最合适的方式来为你的特定类或结构体函数实现下标。</p><p>例如，Swift 中的 <code>Dictionary</code> 类型实现了一个下标来设置和检索存储在 <code>Dictionary</code> 实例中的值。你可以通过在下标括号中提供一个符合字典键类型的键来设置字典的值，并且把符合字典值类型的值赋给下标：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line">numberOfLegs[<span class="string">"bird"</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>上面的例子定义了一个名为 <code>numberOfLegs</code> 的变量并使用含有三个键值对的字典初始化它。字典 <code>numberOfLegs</code> 的类型被推断为 <code>[String: Int]</code>。创建字典后，通过下标将一个 <code>String</code> 类型的键 <code>「bird」</code> 和一个 <code>Int</code> 类型的值 <code>2</code> 添加到了字典。</p><div class="note warning"><p>注意<br>Swift 的 <code>Dictionary</code> 类型将其键值作为下标实现并返回一个可选类型。对于上面的 <code>numberOfLegs</code> 字典，键值下标存取的值类型为 <code>Int?</code>，表示<code>「可选的整数」</code>。<code>Dictionary</code> 类型用可选的下标类型来模拟不是每个键都有值的事实，可以通过为该键指定一个 <code>nil</code> 值来删除该键值。</p></div><h2 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h2><p>下标可以设置任意数量的输入参数，这些输入参数也可以是任意类型。 同时，下标也可以返回任何类型。 下标可以使用可变参数，但它们不能使用输入输出参数或是提供默认参数值。</p><p>类或结构体可以提供尽可能多的下标实现，并且能够基于当前下标括号内的值或者值的类型来推断合适的下标。定义多个下标被称为<strong>下标重载</strong>。</p><p>虽然下标采用单参数是最常见的，但在合适的情况下也可以定义带多个参数的下标。下面的例子定义了一个 <code>Matrix</code> 结构体，这个结构体表示一个类型为 <code>Double</code> 的二维矩阵。<code>Matrix</code> 结构体的下标有两个整型参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows = rows</span><br><span class="line">        <span class="keyword">self</span>.columns = columns</span><br><span class="line">        grid = <span class="type">Array</span>(repeating: <span class="number">0.0</span>, <span class="built_in">count</span>: rows * columns)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexIsValid</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row * columns) + column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            grid[(row * columns) + column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Matrix</code> 提供了一个带有两个名为 <code>rows</code> 和 <code>columns</code> 参数的构造器，并构造一个足够大的数组来存储 <code>Double</code> 类型的 <code>rows * columns</code> 值。矩阵中的每个值初始化为 <code>0.0</code> 。为实现此目的，把数组的大小和初始单元格值 <code>0.0</code> 传递给数组构造器，该构造器会构造并初始化一个正确大小的新数组。</p><p>你可以通过传递合适的行数和列数给构造器来构造新的 <code>Matrix</code> 实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>上面的示例创建了一个新的带有两行两列的  <code>Matrix</code> 实例。<code>Matrix</code> 实例的 <code>grid</code> 数组实际上是矩阵从左上角到右下角的展开：<br><img src="/2018/10/16/Swift下标/下标01.png"><br>可以通过传递行和列的值到下标来给矩阵赋值，行和列用逗号隔开：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">3.2</span></span><br></pre></td></tr></table></figure></p><p>这两行代码调用下标的 <code>setter</code> 方法给矩阵的右上角（<code>row</code> 为 <code>0</code> 且 <code>column</code> 为 <code>1</code>）赋值 <code>1.5</code> 和左下角（<code>row</code> 为 <code>1</code> 且 <code>column</code> 为 <code>0</code>）赋值 <code>3.2</code>。<br><img src="/2018/10/16/Swift下标/下标02.png"><br><code>Matrix</code> 下标的 <code>getter</code> 方法和 <code>setter</code> 方法都包含一个断言来检查下标的 <code>row</code> 和 <code>column</code> 是否有效。为了辅助这些断言，<code>Matrix</code> 包含一个名为 <code>indexIsValid(row:column:)</code> 的便捷方法，该方法检查请求的 <code>row</code> 和 <code>column</code> 是否超出矩阵的边界：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexIsValid</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果尝试访问矩阵边距之外的下标就会触发断言：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue = matrix[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 这里触发了断言，因为下标 [2, 2] 超出了矩阵的边界</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;类、结构体和枚举可以定义 下标 ，它是用于访问集合，列表或序列的成员元素的快捷方式。 你可以直接使用下标来对值进行读写，而无需设置单独的读写方法。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="下标" scheme="https://hadesxiye.github.io/tags/%E4%B8%8B%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 方法</title>
    <link href="https://hadesxiye.github.io/2018/10/15/Swift%E6%96%B9%E6%B3%95/"/>
    <id>https://hadesxiye.github.io/2018/10/15/Swift方法/</id>
    <published>2018-10-15T10:45:59.000Z</published>
    <updated>2018-12-05T11:25:53.227Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>方法</strong> 是与特定类型相关联的函数。类、结构体和枚举都可以定义实例方法，这些方法会封装特定的任务和功能用于处理给定类型的实例。类、结构体和枚举还可以定义类型方法。类型方法类似于 Objective-C 中的类方法。</center><br><a id="more"></a></p><p><strong>可以在结构体和枚举中定义方法，是 Swift 与 C 和 Objective-C 的主要区别。在 Objective-C 中，类是唯一可以定义方法的类型。但在 Swift 中，由于类、结构体和枚举都支持定义方法，所以在选择定义类型时你有更多的选择。</strong></p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><strong>实例方法</strong> 是属于特定类、结构或枚举实例的函数。它们的功能是提供访问和修改实例属性的方法，或提供与实例目的相关的功能。实例方法与函数具有完全相同的语法，如 函数 中所述。</p><p>你在其所属类型的开始和结束括号内编写实例方法。实例方法可以隐式访问该类型的所有其它实例方法和属性。实例方法只能被它所属类型的实例调用。如果没有实例，不能单独调用它。</p><p>下面是一个简单 <code>Counter</code> 类的示例，可用于计算操作发生的次数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(by amount: Int)</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <code>Counter</code> 类中定义了三个实例方法</p><p><code>increment()</code> 将计数器增加 <code>1</code> 。<br><code>increment(by: Int)</code> 将计数器增加指定的值。<br><code>reset()</code> 将计数器重置为 <code>0</code>。<br> <code>Counter</code> 类中还声明了一个可变的属性  <code>count</code> ，用来记录计数器当前的值。</p><p>和调用属性一样，你可以使用点语法来调用实例方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</span><br><span class="line"><span class="comment">// 计数器初始值为 0</span></span><br><span class="line">counter.increment()</span><br><span class="line"><span class="comment">// 计数器的值现在为 1</span></span><br><span class="line">counter.increment(by: <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 计数器的值现在为 6</span></span><br><span class="line">counter.reset()</span><br><span class="line"><span class="comment">// 计数器的值现在为 0</span></span><br></pre></td></tr></table></figure></p><p>方法的参数可以同时拥有一个参数名称（在方法内使用）和一个参数标签（在调用方法时使用），和 函数的参数标签和参数名 中描述的一样。方法的参数也是如此，因为方法也是函数只不过它和类相关联。</p><h2 id="self-属性"><a href="#self-属性" class="headerlink" title="self 属性"></a>self 属性</h2><p>类型的每个实例都有一个名为 <code>self</code> 的隐式属性，它与实例本身完全等效。你可以使用 <code>self</code> 属性来调用自己的实例方法。</p><p>上面例子中的 <code>increment()</code> 方法也可以这样实现的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，你并不需要经常在代码中书写 <code>self</code> 。如果没有显式地书写 <code>self</code> ，那么只要在方法中使用了该类的属性或方法名称，Swift 就会假定你调用了当前实例的属性或方法。在 <code>Counter</code> 的三个实例方法中使用 <code>count</code> （而不是 <code>self.count</code> ）证明了这个假设。</p><p>当实例方法的参数名称与该实例的属性名称相同时，这时候就会发生命名冲突问题。在这种情况下，会使用参数名称优先原则，这时候你就需要以更严格的方式调用属性。即你需要用书写 <code>self</code> 的方式来调用属性以区分参数名称和属性名称。</p><p>这里， <code>self</code> 消除了一个名为 <code>x</code> 的方法参数和一个也被称为 <code>x</code> 的实例属性之间名称相同的歧义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isToTheRightOf</span><span class="params">(x: Double)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> somePoint = <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">if</span> somePoint.isToTheRightOf(x: <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This point is to the right of the line where x == 1.0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This point is to the right of the line where x == 1.0"</span></span><br></pre></td></tr></table></figure></p><p>如果没有 <code>self</code> 前缀，Swift 会假设 <code>x</code> 的两个用法都调用了名为 <code>x</code> 的方法参数。</p><h2 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h2><p>结构体和枚举是 值类型 。默认情况下，无法在其实例方法中修改值类型的属性。</p><p>但是，如果需要在特定方法中修改结构体或枚举的属性，可以选择将这个方法 <strong>异变</strong> 。然后，该方法就可以异变（即更改）其属性，并且当方法结束时，它所做的任何更改都将写回原始的结构体中。该方法还可以为隐式的 <code>self</code> 属性分配一个全新的实例，并且该新实例将在方法结束时替换现有实例。</p><p>你可以通过在方法的 <code>func</code> 关键字前放置 <code>mutating</code> 关键字来选择开启此行为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint = <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The point is now at (\(somePoint.x), \(somePoint.y))"</span>)</span><br><span class="line"><span class="comment">// 打印 "The point is now at (3.0, 4.0)"</span></span><br></pre></td></tr></table></figure></p><p>上面的 <code>Point</code> 结构体定义了一个异变方法 <code>moveBy(x:y:)</code> ，它会基于特定的数值移动 <code>Point</code> 实例。此方法实际上修改了调用它的那个点，而不是返回一个新点。 <code>mutating</code> 关键字被添加到其定义中，以使其能够修改其属性。</p><p>请注意，你不能在常量结构体类型上调用异变方法，因为它的属性不能更改，即使它们是变量属性，如 常量结构体实例的存储属性 中所述：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fixedPoint = <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 编译器会报错</span></span><br></pre></td></tr></table></figure></p><h2 id="在可变方法中给-self-赋值"><a href="#在可变方法中给-self-赋值" class="headerlink" title="在可变方法中给 self 赋值"></a>在可变方法中给 self 赋值</h2><p>可变方法能给隐性的 <code>self</code> 属性赋以一个全新的实例。上面以 <code>Point</code> 为例的代码也可以用下面这种方式来实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个版本的可变方法 <code>moveBy(x:y:)</code> 创建了一个新的结构体，且该结构体的 <code>x</code> 与 <code>y</code> 值都被设定为目标位置。调用这个可变版本的方法与上个版本的方法最终结果一样。</p><p>枚举的可变方法可以将隐性的 <code>self</code> 参数设置成同一枚举类型中的不同成员。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> = .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> = .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .off</span></span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们定义了一个枚举，它拥有三种状态的开关。当 <code>next()</code> 方法被调用时，这个开关将在三种不同的电源状态（<code>off</code>，<code>low</code> 和 <code>high</code>）之间循环切换。</p><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>就像上面所描述的，实例方法是在类型的实例上被调用的方法。你也可以直接在类型本身上定义方法，这样的方法被称作 类型方法 。为了明确一个方法是类型方法，你可以在这个方法的 <code>func</code> 关键词前加上 <code>static</code> 关键词。在类中，也可以使用 <code>class</code> 关键词来声明一个类型方法。与 <code>static</code> 关键词不同的是，<strong>用 <code>class</code> 关键词声明的类型方法允许它的子类重写其父类对类型方法的实现</strong>。</p><div class="note warning"><p>注意<br>在 Objective-C 中，你只能为 Objective-C 的类定义类型方法。而在 Swift 中，你可以为所有的类、结构体或枚举定义类型方法。每一个类型方法可被调用的作用域都被其所支持的类型明确划分。</p></div><p>就像实例方法那样，类型方法可以通过点语法来调用。不同的是，你将直接在类上调用类型方法，而不是在类型的实例上调用。你可以像下面这样在一个被叫做 <code>SomeClass</code> 的类上调用其类型方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">someTypeMethod</span>() </span>&#123;</span><br><span class="line">            <span class="comment">// 这里是类型方法的实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure></p><p>在一个方法的函数体中，隐性属性 <code>self</code> 指代其类型本身，而非指代类型的实例。就像你对实例属性与实例方法的参数之间做的那样，这意味着你可以使用 <code>self</code> 来消除类属性与类型方法的参数之间的歧义。</p><p>一般来说，你在类型方法函数体内使用的任何非完全标准的方法和属性名称将会引用对应的类型级别的方法和属性。类型方法可以直接使用方法的名称来调用另一个类型方法，而无需使用类型名称作为前缀。同样的，结构体和枚举上的类型方法可以通过使用不带类型名称前缀的类型属性名称来访问该类型属性。</p><p>下面的示例定义了一个名为 <code>LevelTracker</code> 的结构体，它用来追踪玩家在游戏的不同级别或阶段的进度。这是一款单人游戏，但可以在一台设备上存储多个玩家的信息。</p><p>首次玩游戏时，所有的游戏等级（除了第一级）都会被锁定。每当玩家完成一个等级时，该等级就会被设备上的所有玩家解锁。 <code>LevelTracker</code> 结构体使用类型属性和方法来追踪游戏的哪些级别已被解锁。它还追踪单个玩家的当前级别。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">(<span class="number">_</span> level: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">isUnlocked</span><span class="params">(<span class="number">_</span> level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level &lt;= highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">advance</span><span class="params">(to level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel = level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LevelTracker</code> 结构体追踪任何玩家解锁的最高级别。该值存储在名为 <code>highestUnlockedLevel</code> 的类型属性中。</p><p><code>LevelTracker</code> 还定义了两个类型函数来处理 <code>highestUnlockedLevel</code> 属性。第一个是名为 <code>unlock(_:)</code> 的类型函数，每当解锁一个新级别时它会更新 <code>highestUnlockedLevel</code> 的值。第二个是一个名为 <code>isUnlocked(_:)</code> 的便捷类型函数，如果某个特定的级别号已被解锁，则返回 <code>true</code> 。（请注意，这些类型方法可以直接使用 <code>highestUnlockedLevel</code> 类型属性，而无需将其写为 <code>LevelTracker.highestUnlockedLevel</code> 。）</p><p>除了类型属性和类型方法之外，<code>LevelTracker</code> 还追踪单个玩家在游戏中的进度。它使用一个名为 <code>currentLevel</code> 的实例属性来跟踪玩家当前的游戏等级。</p><p>为了帮助管理 <code>currentLevel</code> 属性， <code>LevelTracker</code> 定义了一个名为 <code>advance(to:)</code> 的实例方法。在更新 <code>currentLevel</code> 之前，此方法先检查所请求的新级别是否已解锁。 <code>advance(to:)</code> 方法返回一个布尔值，表示它是否实际上能够设置 <code>currentLevel</code> 。因为调用 <code>advance(to:)</code> 方法时我们有时候可能会需要忽略返回值，所以这个函数用 <code>@ discardableResult</code> 特性标记。</p><p><code>@ discardableResult</code>表示取消不使用返回值的警告</p><p><code>LevelTracker</code> 结构体与 <code>Player</code> 类一起使用，如下所示，用于追踪和更新单个玩家的进度：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tracker = <span class="type">LevelTracker</span>()</span><br><span class="line">    <span class="keyword">let</span> playerName: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">complete</span><span class="params">(level: Int)</span></span> &#123;</span><br><span class="line">        <span class="type">LevelTracker</span>.unlock(level + <span class="number">1</span>)</span><br><span class="line">        tracker.<span class="built_in">advance</span>(to: level + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        playerName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Player</code> 类创建一个 <code>LevelTracker</code> 实例来跟追踪该玩家的进度。它还提供了一个名为 <code>complete(level:)</code> 的方法，只要玩家完成特定级别就会调用它。此方法会为所有玩家解锁下一关，并更新当前玩家的进度到下一关。（忽略 <code>advance(to:)</code> 的布尔性返回值，是因为已经知道通过调用前一行的 <code>LevelTracker.unlock(_:)</code> 来解锁该级别。）</p><p>你可以为新玩家创建一个 <code>Player</code> 类的实例，看看当玩家完成第一级时会发生什么：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="type">Player</span>(name: <span class="string">"Argyrios"</span>)</span><br><span class="line">player.complete(level: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"highest unlocked level is now \(LevelTracker.highestUnlockedLevel)"</span>)</span><br><span class="line"><span class="comment">// 打印 "highest unlocked level is now 2"</span></span><br></pre></td></tr></table></figure></p><p>如果你创建了第二个玩家，并尝试将其移动到游戏中任何玩家都尚未解锁的等级，则设置玩家当前等级的尝试会失败：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="type">Player</span>(name: <span class="string">"Beto"</span>)</span><br><span class="line"><span class="keyword">if</span> player.tracker.<span class="built_in">advance</span>(to: <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"player is now on level 6"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"level 6 has not yet been unlocked"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "level 6 has not yet been unlocked"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;方法&lt;/strong&gt; 是与特定类型相关联的函数。类、结构体和枚举都可以定义实例方法，这些方法会封装特定的任务和功能用于处理给定类型的实例。类、结构体和枚举还可以定义类型方法。类型方法类似于 Objective-C 中的类方法。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="方法" scheme="https://hadesxiye.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 属性</title>
    <link href="https://hadesxiye.github.io/2018/10/14/Swift%E5%B1%9E%E6%80%A7/"/>
    <id>https://hadesxiye.github.io/2018/10/14/Swift属性/</id>
    <published>2018-10-14T02:38:23.000Z</published>
    <updated>2018-12-05T10:44:28.028Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>属性</strong> 可以将值与特定类、结构体或者枚举类型相关联。存储属性将常量和变量值存储为实例的一部分，而计算属性则是通过计算得到一个值（而不是存储值）。计算属性适用于类、结构体和枚举类型，而存储属性只适用于类和结构体类型。</center><br><a id="more"></a></p><p>存储和计算属性通常都与特定类型的实例相关联。但是，属性也可以与类型本身相关联，这种属性称为类型属性。</p><p>此外，你还可以定义属性观察器以监视属性值的更改，并使用自定义的操作对其进行响应。你既可以将属性观察器添加到自己定义的存储属性中，也可以添加到从父类继承来的属性中。</p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>简单来说，存储属性是一个存储在特定的类或结构体中的常量或变量。存储属性可以是 变量存储属性 （由 <code>var</code> 关键字定义）或 常量存储属性 （由 <code>let</code> 关键字定义）。</p><p>你可以为存储属性提供默认值作为其定义的一部分，如 默认属性值 中所述。你还可以在初始化期间设置和修改存储属性的初始值。即使对于常量存储属性也是如此，如 在初始化期间给常量属性赋值 中所述。</p><p>下面的示例定义了一个名为 <code>FixedLengthRange</code> 的结构体，该结构体描述了一个整数范围，其范围长度在创建后无法更改：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 该整数范围表示整数值 0、1 和 2</span></span><br><span class="line">rangeOfThreeItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 该整数范围现在表示整数值 6、7 和 8</span></span><br></pre></td></tr></table></figure></p><p><code>FixedLengthRange</code> 的实例有一个名为 <code>firstValue</code> 的变量存储属性和一个名为 <code>length</code> 的常量存储属性。在上面的示例中，<code>length</code> 在创建新实例时被初始化，之后无法更改，因为它是常量属性。</p><h3 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h3><p>如果创建结构体实例并将该实例声明为常量，则无法修改实例的属性，即使它们被声明为变量属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 此整数范围表示整数值 0、1、2 和 3</span></span><br><span class="line">rangeOfFourItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 这行代码会报错，即使 firstValue 是一个变量属性</span></span><br></pre></td></tr></table></figure></p><p>因为 <code>rangeOfFourItems</code> 被声明为常量（使用 <code>let</code> 关键字），所以即使 <code>firstValue</code> 是一个变量属性，也不可以改变它的值。</p><p>这种行为是由于结构体是 值类型 。当值类型的实例声明为常量时，其所有属性也都会被标记为常量。</p><p>类的行为却并非如此，这是因为类是 引用类型 。如果将引用类型的实例声明为常量时，你仍可以修改该实例的变量属性。</p><h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><p><strong>延迟存储属性</strong> 的初始值直到第一次使用时才进行计算。你可以通过在其声明之前标注 <code>lazy</code> 修饰符来表示一个延迟存储属性。</p><div class="note info"><p>注释<br>你必须始终将延迟属性声明为变量（使用 <code>var</code> 关键字），因为延迟属性的初始值可能在实例初始化完成之后，仍然没有被赋值。而常量属性必须在实例初始化完成 之前 就获得一个值，因此不能声明为延迟。</p></div><p>当属性的初始值依赖于外部因素时，延迟属性就非常有用了，因为这些外部因素的值可能在实例初始化完成之后才知道。当属性的初始值需要执行复杂或代价高昂的计算时，你应该只在需要的时候才执行，这时候延迟属性也很有用。</p><p>下面的示例，使用延迟存储属性来避免复杂类的不必要的初始化。这个例子定义了两个名为 <code>DataImporter</code> 和 <code>DataManager</code> 的类，它们的代码都没有全部列出：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter 是一个从外部文件导入数据的类。</span></span><br><span class="line"><span class="comment">     假设该类需要花费大量时间来初始化。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> filename = <span class="string">"data.txt"</span></span><br><span class="line">    <span class="comment">// DataImporter 类将在此处提供数据导入功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// DataManager 类将在此处提供数据管理功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">"Some data"</span>)</span><br><span class="line">manager.data.append(<span class="string">"Some more data"</span>)</span><br><span class="line"><span class="comment">// 类型为 DataImporter 的 importer 属性实例尚未创建</span></span><br></pre></td></tr></table></figure></p><p><code>DataManager</code> 类有一个名为 <code>data</code> 的存储属性，它使用一个空的 <code>String</code> 数组进行初始化。尽管它的其余功能没有展示出来，但我们仍然可以猜到这个 <code>DataManager</code> 类的目的是管理并提供访问 <code>String</code> 数组的方法。</p><p><code>DataManager</code> 类同时还具有从文件导入数据的功能。这个功能由 <code>DataImporter</code> 类提供，我们同时假定初始化 <code>DataImporter</code> 类需要大量时间。这可能是因为初始化 <code>DataImporter</code> 实例时，需要打开文件并将其内容读入内存。</p><p>因为 <code>DataManager</code> 实例管理数据的功能，并不依赖从文件导入数据的功能，因此在创建 <code>DataManager</code> 实例时，我们不应该立刻创建 <code>DataImporter</code> 实例。相反，在 <code>DataImporter</code> 第一次被使用时再创建它才更有意义。</p><p>因为 <code>importer</code> 属性被 <code>lazy</code> 修饰符所标记，因此它在第一次被访问时 <code>DataImporter</code> 实例才会被创建，例如当查询其 <code>filename</code> 属性时：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.filename)</span><br><span class="line"><span class="comment">// 现在 DataImporter 的实例 importer 已经被创建了</span></span><br><span class="line"><span class="comment">// 打印 "data.txt"</span></span><br></pre></td></tr></table></figure></p><div class="note info"><p>注释<br>如果被 <code>lazy</code> 修饰符所标记的属性，同时被多个线程访问，并且该属性尚未被初始化，则无法保证该属性仅被初始化一次。</p></div><h3 id="存储属性和实例变量"><a href="#存储属性和实例变量" class="headerlink" title="存储属性和实例变量"></a>存储属性和实例变量</h3><p>如果你有使用 <code>Objective-C</code> 的经验，你可能知道它提供了 <strong>两种</strong> 方法来存储值和引用。除了属性之外，你还可以使用实例变量来作为属性的底层存储。</p><p>Swift 将这些概念统一到一个属性声明中。Swift 属性没有相应的实例变量，并且属性的底层存储不能被直接访问。这种方式避免了在不同的上下文中如何访问值的混淆，并将属性的声明简化为单个明确的语句。有关属性的所有信息（包括其名称、类型和内存管理特征）都在单个位置定义，作为类型定义的一部分。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性之外，类、结构体和枚举还可以定义 计算属性 ，它们实际上并不存储值。相反，它们会提供了一个 <code>getter</code> 方法和一个可选的 <code>setter</code> 方法来间接读取和设置其他属性和值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">                  size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter = square.center</span><br><span class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (\(square.origin.x), \(square.origin.y))"</span>)</span><br><span class="line"><span class="comment">// 打印 "square.origin is now at (10.0, 10.0)"</span></span><br></pre></td></tr></table></figure></p><p>此示例定义了三种用于处理几何形状的结构体：</p><ul><li><code>Point</code> 封装了一个点的 <code>x</code> 坐标和 <code>y</code> 坐标。</li><li><code>Size</code> 封装了 <code>width</code> 和 <code>height</code> 。</li><li><code>Rect</code> 用原点和大小定义一个矩形。</li></ul><p><code>Rect</code> 结构体还提供了一个名为 <code>center</code> 的计算属性。<code>Rect</code> 的当前中心位置始终可以从其 <code>origin</code> 和 <code>size</code> 来唯一确定，因此你并不需要将中心点存储为一个 <code>Point</code> 类型的存储属性。相反，我们应该在 <code>Rect</code> 中定义一个名为 <code>center</code> 的计算变量，并自定义它的 <code>getter</code> 和 <code>setter</code> 方法，这样我们就可以使用矩形的 <code>center</code> 属性，就像它是一个真正的存储属性一样。</p><p>上面的例子创建了一个名为 <code>square</code> 的 <code>Rect</code> 变量。 <code>square</code> 变量原点初始化为 <code>(0, 0)</code>，宽度和高度初始化为 <code>10</code>。该正方形由下图中的蓝色方块表示。</p><p>然后通过点语法（ <code>square.center</code> ）访问 <code>square</code> 变量的 <code>center</code> 属性，这会导致调用 <code>center</code> 的 <code>getter</code> 方法来读取当前属性值。 <code>Getter</code> 方法实际上会计算并返回一个新的 <code>Point</code> 来表示正方形的中心，而不是返回一个现有的值。从上面代码可以看出，<code>getter</code> 方法正确地返回了一个中心点 <code>(5, 5)</code> 。</p><p>接下来我们将 <code>center</code> 属性设置为新的值 <code>(15, 15)</code> ，它会将方块向上和向右移动到下图中橙色方块所示的新位置。设置 <code>center</code> 属性会调用 <code>center</code> 的 <code>setter</code> 方法，它将会修改 <code>origin</code> 存储属性的 <code>x</code> 和 <code>y</code> 值，并将方块移动到新的位置。</p><img src="/2018/10/14/Swift属性/属性01.png"><h3 id="Setter-声明的速记符号"><a href="#Setter-声明的速记符号" class="headerlink" title="Setter 声明的速记符号"></a>Setter 声明的速记符号</h3><p>如果计算属性的 <code>setter</code> 方法没有为要设置的新值定义名称，则使用默认名称 <code>newValue</code> 。这是 <code>Rect</code> 结构体的替代版本，它使用了这种速记符号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlternativeRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x = newValue.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newValue.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>只有 <code>getter</code> 方法但没有 <code>setter</code> 方法的计算属性称为 <strong>只读计算属性</strong> 。只读计算属性始终返回一个值，可以通过点语法访问，但不能给它赋值。</p><div class="note warning"><p>注意<br>你必须使用 <code>var</code> 关键字来声明计算属性（包括只读计算属性），这是因为它们的值是不固定。<code>let</code> 关键字仅用于常量属性，这种属性一旦被初始化以后，就不能再更改它们的值。</p></div><p>你还可以通过删除 <code>get</code> 关键字及其大括号来简化只读计算属性的声明：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)"</span>)</span><br><span class="line"><span class="comment">// 打印 "the volume of fourByFiveByTwo is 40.0"</span></span><br></pre></td></tr></table></figure></p><p>这个例子定义了一个名为 <code>Cuboid</code> 的新结构体，它代表一个具有 <code>width</code> ， <code>height</code> 和 <code>depth</code> 属性的3D矩形框。这个结构体还有一个名为 <code>volume</code> 的只读计算属性，它计算并返回长方体的当前体积。 <code>volume</code> 可以被设置是没有意义的，因为对于特定的 <code>volume</code> 值，对应的 <code>width</code> ， <code>height</code> 和 <code>depth</code> 是不能唯一确定的。所以在这种情况下， <code>Cuboid</code> 提供只读计算属性以使外部用户能够获取当前计算体积是很有用的。</p><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器会观察并对属性值的变化做出反应。每次设置属性值时都会调用属性观察器，即使新值与属性的当前值相同。</p><p>你可以将属性观察器添加到你定义的任何存储属性上，但延迟存储属性除外。你还可以通过在子类中重写属性来为任何继承的属性（无论是存储还是计算）添加属性观察器。你并不需要为非重写的计算属性定义属性观察器，因为你可以在计算属性的 <code>setter</code> 方法中观察并响应其值的更改。属性重写将在 <a href="https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html#ID196" target="_blank" rel="noopener">重写</a> 中有详细描述。</p><p>你可以选择在属性上定义一个或两个观察器：</p><ul><li>在存储值之前调用 <code>willSet</code> 。</li><li>存储新值后立即调用 <code>didSet</code> 。</li></ul><p>如果实现 <code>willSet</code> 观察器，它会将新属性值作为常量参数传递。你可以在 <code>willSet</code> 实现中指定此参数的名称。如果不在实现中指定参数名称，则使用默认参数名称 <code>newValue</code> 。</p><p>类似地，如果你实现一个 <code>didSet</code> 观察器，它会传递一个包含旧属性值的常量参数。你可以指定参数名称或使用默认参数名称 <code>oldValue</code> 。如果你在自己的 <code>didSet</code> 属性观察器里给自己赋值，那么你赋值的新值将会替代刚刚设置的值。</p><div class="note warning"><p>注意<br>在调用父类初始化方法之后，在子类中给父类属性赋值时，将会调用父类属性的 willSet 和 didSet 观察器。如果在调用父类初始化方法之前，在子类中给父类属性赋值，则不会调用父类的观察器。</p></div><p>下面是一个 <code>willSet</code> 和 <code>didSet</code> 的例子。示例中定义了一个名为 <code>StepCounter</code> 的类，它记录了一个人行走的总步数。该类可用于导入来自计步器或其它计步装置的数据，以追踪人们的日常运动情况。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"将要设置 totalSteps 为 \(newTotalSteps)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"增加了 \(totalSteps - oldValue) 步"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps = <span class="number">200</span></span><br><span class="line"><span class="comment">// 将要设置 totalSteps 为 200</span></span><br><span class="line"><span class="comment">// 增加了 200 步</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">360</span></span><br><span class="line"><span class="comment">// 将要设置 totalSteps 为 360</span></span><br><span class="line"><span class="comment">// 增加了 160 步</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">896</span></span><br><span class="line"><span class="comment">// 将要设置 totalSteps 为 896</span></span><br><span class="line"><span class="comment">// 增加了 536 步</span></span><br></pre></td></tr></table></figure></p><p><code>StepCounter</code> 类声明了 <code>Int</code> 类型的 <code>totalSteps</code> 属性。这是一个带有 <code>willSet</code> 和 <code>didSet</code> 观察器的存储属性。</p><p>只要为属性赋了新值，就会调用 <code>totalSteps</code> 的 <code>willSet</code> 和 <code>didSet</code> 观察器。即使新值与当前值相同，也是如此。</p><p>这个例子的 <code>willSet</code> 观察器使用了自定义参数名称 <code>newTotalSteps</code> 来表示即将到来的新值。在此示例中，它只是打印出即将设置的值。</p><p>在更新 <code>totalSteps</code> 的值之后调用 <code>didSet</code> 观察器。它将 <code>totalSteps</code> 的新值与旧值进行比较。如果步骤总数增加，则会打印一条消息，显示增加了多少步数。 <code>didSet</code> 观察器不会为旧值提供自定义参数名称，而是使用默认名称 <code>oldValue</code> 。</p><div class="note warning"><p>注意<br>如果将具有观察器的属性作为 <code>in-out</code> 参数传递给函数，则 <code>willSet</code> 和 <code>didSet</code> 观察器一定会被调用。这是因为 <code>in-out</code> 参数是 <code>copy-in</code> <code>copy-out</code> 内存模型：值一定会在函数结束后写回属性。</p></div><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><p>上面描述的用于计算和观察属性的功能也可用于 <strong>全局变量</strong> 和 <strong>局部变量</strong> 。全局变量是指在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是指在函数、方法或闭包上下文中定义的变量。</p><p>你在前面章节中遇到的全局和局部变量都是 <strong>存储变量</strong> 。 存储变量（如存储属性）为特定类型的值提供存储，并允许设置和检索该值。</p><p>总之，你可以在全局或局部范围内定义 <strong>计算变量</strong> 和给存储变量设置观察器。计算变量只会计算它们的值，而不存储它们，编写方式与计算属性相同。</p><div class="note warning"><p>注意<br>全局常量和变量总是被延迟计算，与 <strong>延迟存储属性</strong> 类似。与延迟存储属性不同的是，全局常量和变量不需要使用 <code>lazy</code> 修饰符进行标记。<br><br>局部常量和变量永远不会被延迟计算。</p></div><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>实例属性是属于特定类型的实例的属性。每次创建该类型的新实例时，它都有自己的一组属性值，与任何其他实例不同。</p><p>你还可以定义属于该类型本身的属性，而不是类型的实例属性。无论你创建的该类型的实例有多少，这些属性都只会有一个副本。这些属性称为 类型属性 。</p><p>类型属性用于定义一个对某个类型的 所有 实例都可见的值，例如所有实例都可以使用的常量属性（如 C 中的静态常量），或者所有实例都可以访问的全局变量属性（如 C 中的静态变量）。</p><p>存储类型属性可以是变量或常量。计算类型属性始终是变量属性，与声明计算实例属性的方式相同。</p><div class="note warning"><p>注意<br>与存储实例属性不同，你必须始终为存储类型属性提供默认值。这是因为类型本身没有初始化方法来给存储类型属性赋值。<br><br>存储类型属性在首次访问时被初始化。它们会被保证只初始化一次，即使同时由多个线程访问。请注意你并不需要用 lazy 修饰符标记它们。</p></div><h3 id="类型属性的语法"><a href="#类型属性的语法" class="headerlink" title="类型属性的语法"></a>类型属性的语法</h3><p>在 <code>C</code> 和 <code>Objective-C</code> 中，你使用 <strong>全局</strong> 静态变量来定义与类型关联的静态常量和变量。但是，在 <code>Swift</code> 中，类型属性是写在类型定义的花括号内，作为类型定义的一部分，并且每个类型属性都明确地显示它支持的类型。</p><p>你可以使用 <code>static</code> 关键字定义类型属性。对于类类型的计算类型属性，可以使用 <code>class</code> 关键字来允许子类覆盖超类的实现。下面的示例显示了存储和计算类型属性的语法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>上面的计算类型属性是只读计算类型属性，但你也可以使用与计算实例属性相同的语法定义读写计算类型属性。</p></div><h2 id="检索和设置类型属性"><a href="#检索和设置类型属性" class="headerlink" title="检索和设置类型属性"></a>检索和设置类型属性</h2><p>类型属性可以使用点语法来进行检索和设置，就像实例属性一样。但是，类型属性是基于 类型 来进行检索和设置，而不是基于该类型的实例。 例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印 "Some value."</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印 "Another value."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印 "6"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印 "27"</span></span><br></pre></td></tr></table></figure></p><p>以下示例使用两个存储类型属性作为建模一个数字音频信道音频测量表的结构体的一部分。每个通道的整数音频电平在 <code>0</code> 和 <code>10</code> 之间。</p><p>下边的图例展示了这个音频频道如何组合建模一个立体声音频测量表。当通道的音频电平为 <code>0</code> 时，该通道的任何灯都不会亮起。当音频电平为 <code>10</code> 时，该通道的所有灯都会亮起。在该图中，左声道的当前电平为 <code>9</code> ，右声道的当前电平为 <code>7</code> ：<br><img src="/2018/10/14/Swift属性/属性02.png"></p><p>上面描述的音频通道由 <code>AudioChannel</code> 结构体实例表示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel = <span class="number">10</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.thresholdLevel &#123;</span><br><span class="line">                <span class="comment">// 将新音频电平值限制在阈值之内</span></span><br><span class="line">                currentLevel = <span class="type">AudioChannel</span>.thresholdLevel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</span><br><span class="line">                <span class="comment">// 将此存储为新的目前最大的电平值</span></span><br><span class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels = currentLevel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AudioChannel</code> 结构体定义了两个存储类型属性以支持其功能。第一个， <code>thresholdLevel</code> ，定义音频电平值可以采用的最大阈值。对于所有 <code>AudioChannel</code> 实例，这是一个常量值 <code>10</code> 。（如下面描述的那样）如果音频信号电平值高于 <code>10</code> ，我们仍然只能把它设置为 <code>10</code> 。</p><p>第二个类型属性是名为 <code>maxInputLevelForAllChannels</code> 的变量存储属性。这个变量保存 所有 <code>AudioChannel</code> 实例接收的最大输入值。它的初始值为 <code>0</code> 。</p><p><code>AudioChannel</code> 结构体还定义了一个名为 <code>currentLevel</code> 的存储实例属性，它表示通道的当前音频电平值，范围为 <code>0</code> 到 <code>10</code> 。</p><p><code>currentLevel</code> 属性有一个 <code>didSet</code> 属性观察器，可以在赋值时检查 <code>currentLevel</code> 的值。该观察器执行两项检查：</p><p>如果 <code>currentLevel</code> 的新值大于允许的 <code>thresholdLevel</code> ，则属性观察器将 <code>currentLevel</code> 限制为 <code>thresholdLevel</code> 。<br>如果 <code>currentLevel</code> 的新值（在阈值之内）高于 所有 <code>AudioChannel</code> 实例先前接收的电平值，则属性观察器将新的 <code>currentLevel</code> 值存储在 <code>maxInputLevelForAllChannels</code> 类型属性中。</p><div class="note warning"><p>注意<br>在第一个检查中，即使 <code>didSet</code> 观察器将 <code>currentLevel</code> 设置为不同的值，也不会导致再次调用观察器。</p></div><p>你可以使用 <code>AudioChannel</code> 结构体创建两个名为 <code>leftChannel</code> 和 <code>rightChannel</code> 的音频通道，以表示立体声音响系统的音频等级：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftChannel = <span class="type">AudioChannel</span>()</span><br><span class="line"><span class="keyword">var</span> rightChannel = <span class="type">AudioChannel</span>()</span><br></pre></td></tr></table></figure></p><p>如果将 左 通道的 <code>currentLevel</code> 设置为 <code>7</code> ，则可以看到 <code>maxInputLevelForAllChannels</code> 类型属性更新为 <code>7</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leftChannel.currentLevel = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</span><br><span class="line"><span class="comment">// 打印 "7"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 打印 "7"</span></span><br></pre></td></tr></table></figure></p><p>如果你试图将 右 通道的 <code>currentLevel</code> 设置为 <code>11</code> ，你可以看到右通道的 <code>currentLevel</code> 属性的值是阈值 <code>10</code> ，而 <code>maxInputLevelForAllChannels</code> 类型属性的值也更新为 <code>10</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rightChannel.currentLevel = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</span><br><span class="line"><span class="comment">// 打印 "10"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 打印 "10"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;属性&lt;/strong&gt; 可以将值与特定类、结构体或者枚举类型相关联。存储属性将常量和变量值存储为实例的一部分，而计算属性则是通过计算得到一个值（而不是存储值）。计算属性适用于类、结构体和枚举类型，而存储属性只适用于类和结构体类型。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="类和结构体" scheme="https://hadesxiye.github.io/tags/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 类和结构体</title>
    <link href="https://hadesxiye.github.io/2018/10/13/Swift%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://hadesxiye.github.io/2018/10/13/Swift类和结构体/</id>
    <published>2018-10-13T02:38:12.000Z</published>
    <updated>2018-12-10T09:44:24.461Z</updated>
    
    <content type="html"><![CDATA[<p><center>结构体和类是通用，灵活的设计，是你程序代码的结构基础。使用与你定义常量，变量和函数相同的语法来定义属性和方法以此为你的结构体和类添加功能。</center><br><a id="more"></a></p><p>并不像其他语言，Swift 不需要你为自定义结构体和类创建单独的接口与实现文件，Swift 中定义结构体和类在一个文件里，并且该类或结构体对其他代码会自动创建外部接口。</p><h2 id="比较结构体和类"><a href="#比较结构体和类" class="headerlink" title="比较结构体和类"></a>比较结构体和类</h2><p>Swift 中结构体和类有很多共同点，二者皆可：</p><ul><li>定义属性以存储值</li><li>定义方法以提供功能</li><li>定义下标以提供下标语法访问其值</li><li>定义构造器以设置其初始化状态</li><li>通过扩展以增加默认实现功能</li><li>遵循协议以提供某种标准功能</li></ul><p>类有有一些结构体没有的额外功能：</p><ul><li>继承让一个类可以继承另一个类的特征</li><li>类型转换让你在运行时可以检查和解释一个类实例</li><li>析构器让一个类的实例可以释放任何被其所分配的资源</li><li>引用计数允许对一个类实例进行多次引用</li></ul><p>使用类的额外功能其代价就是增加了复杂性。一般来说，更推荐结构体和枚举，因为他们更加容易进行推断，并且适当或必要时使用类。实际上，这意味着将会使用结构体和枚举来定义大多数自定义数据类型。更多比较详情请参阅 <a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" target="_blank" rel="noopener">抉择在结构体和类之间</a>。</p><h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><p>结构体和类有相似的定义语法。使用 <code>struct</code> 关键字定义结构体、使用 <code>class</code> 关键字定义类。二者都在大括号中定义其具体内容：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>每当你定义一个新的结构体或类都是定义一个全新的 Swift 类型。请使用 <code>UpperCamelCase</code> 命名法（例如 <code>SomeStructure</code> 和 <code>SomeClass</code>）以符合大写命名风格的标准 Swift 类型（例如 <code>String</code>，<code>Int</code> 和 <code>Bool</code>）。对于属性和方法使用 <code>lowerCamelCase</code> 命名法（例如 <code>frameRate</code> 和 <code>incrementCount</code>）以此和类名区分。</p></div><p>以下是定义结构体和类的示例:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子定义了一个名为 <code>Resolution</code> 的结构体，用于描述基于像素的显示分辨率。这个结构体有两个存储属性分别名为 <code>width</code> 和 <code>height</code>。 存储属性是与结构体或类绑定并存储为其一部分的常量或变量。由于设置这两个属性的初始值为 <code>0</code> 所以其类型被推断为  <code>Int</code> 。</p><p>上面的例子还定义了一个名为 <code>VideoMode</code> 的类，用于描述视频的指定显示模式，这个类有四个为存储属性的变量。第一个，<code>resolution</code>，是 <code>Resolution</code> 结构体初始化的一个实例，其类型被推断为 <code>Resolution</code>。至于其他三个属性，新的 <code>VideoMode</code> 实例会把 <code>interlaced</code> 设置为 <code>false</code>（逐行扫描视频），播放帧数 <code>frameRate</code> 设置为 <code>0.0</code>，和一个名为 <code>name</code> 关联值类型是 <code>String</code> 的 可选类型。由于是可选类型，<code>name</code> 默认值自动为 <code>nil</code>，或说『无 <code>name</code> 值』。</p><h2 id="结构体与类实例"><a href="#结构体与类实例" class="headerlink" title="结构体与类实例"></a>结构体与类实例</h2><p><code>Resolution</code> 结构体和 <code>VideoMode</code> 类的定义只描述了 <code>Resolution</code> 和 <code>VideoMode</code> 是什么样的。他们并没有描述一个特定的分辨率或视频模式。为此，我们需要创建其实例来指定分辨率或视频模式。</p><p>结构体和类创建实例的语法非常相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure></p><p>结构体和类都可以使用构造语法创建新的实例，最简单形式的构造语法就是类或结构体的类型名称之后尾随空括号，例如 <code>Resolution()</code> 或 <code>VideoMode()</code>。这样就创建了一个类或结构体的实例，并且所有属性全部初始化为默认值。</p><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><p>你可以使用点语法来访问一个实例的属性。点语法中，在实例名的后面直接写属性名，用（<code>.</code>）来分割。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is \(someResolution.width)"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure></p><p>这个例子中，<code>someResolution.width</code> 就是 <code>someResolution</code> 中的 <code>width</code>， 返回其默认值 <code>0</code>。<br>你也可深入访问子属性，例如 <code>VideoMode</code> 的 <code>resolution</code> 属性的 <code>width</code> 的属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is \(someVideoMode.resolution.width)"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure></p><p>你也可以使用点语法给变量属性赋值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now \(someVideoMode.resolution.width)"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure></p><h2 id="结构体类型的成员构造器"><a href="#结构体类型的成员构造器" class="headerlink" title="结构体类型的成员构造器"></a>结构体类型的成员构造器</h2><p>所有结构体都有一个用于初始化结构体实例的成员属性，并且是自动生成的成员构造器。实例属性的初始化值通过属性名称传递到成员构造器中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure></p><p>与结构体不同，类没有默认的成员构造器</p><h2 id="值类型的结构体和枚举"><a href="#值类型的结构体和枚举" class="headerlink" title="值类型的结构体和枚举"></a>值类型的结构体和枚举</h2><p>值类型是一种赋值给变量或常量，或传递给函数时，值会被拷贝的类型。</p><p>其实你在之前的章节中已广泛的使用了值类型。其实 Swift 中的所有基本类型 — 整数，浮点数，布尔，字符串，数组和字典 — 它们都是值类型，其底层也是以结构体实现的。</p><p>Swift 中所有的结构体和枚举都是值类型。这意味着在代码中你创建的任何结构体或枚举的实例 — 及其任何值类型的属性 — 都会在传递时被拷贝。</p><div class="note warning"><p>注意<br>标准库所定义的集合例如数组，字典和字符串都进行了优化以减少拷贝时的性能开销。这些集合不是直接复制，而是在原始实例和所有副本之间共享内存。如果集合的任意一个副本被修改，则会在修改之前复制该元素。代码中这种行为看似好像立即发生。</p></div><p>这个示例用了上面的 Resolution 结构体：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="keyword">var</span> cinema = hd</span><br></pre></td></tr></table></figure></p><p>声明了一个名为 <code>hd</code> 的常量并使用全高清视频的宽高（ 1920 像素宽，1080 像素高 ）将其初始化为 <code>Resolution</code> 的实例。</p><p>还声明了一个名为 <code>cinema</code> 的变量并使用当前 <code>hd</code> 的值为其赋值。 因为 <code>Resolution</code> 是一个结构体，所以会制作一个当前实例的副本赋值给 <code>cinema</code> 。虽然 <code>hd</code> 和 <code>cinema</code> 现在有同样的宽高，但是他们在底层是完全不同的两个实例。</p><p>接下来，将 <code>cinema</code> 的属性 <code>width</code> 修改为略宽一点的数字影院放映的 2 K 标准宽度（ 2048 像素宽和 1080 像素高 ）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cinema.width = <span class="number">2048</span></span><br></pre></td></tr></table></figure></p><p>查看 <code>cinema</code> 的属性 <code>width</code> 会发现已经改成了 <code>2048</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"cinema is now \(cinema.width) pixels wide"</span>)</span><br><span class="line"><span class="comment">// 打印 "cinema is now 2048 pixels wide"</span></span><br></pre></td></tr></table></figure></p><p>而原始 <code>hd</code> 实例的 <code>width</code> 属性还是之前的值 <code>1920</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hd is still \(hd.width) pixels wide"</span>)</span><br><span class="line"><span class="comment">// 打印 "hd is still 1920 pixels wide"</span></span><br></pre></td></tr></table></figure></p><p>当 <code>hd</code> 赋值给 <code>cinema</code> 时，存储在 <code>hd</code> 中的值就拷贝给了新的 <code>cinema</code> 实例。最终结果就是相同数值但完全独立的两个实例。由于他们完全独立，所以设置 <code>cinema</code> 的宽度为 <code>2048</code> 并不会影响 <code>hd</code> 中的存储，如下图所示：</p><img src="/2018/10/13/Swift类和结构体/类和结构体01.png"><p>枚举也适用于同样的行为准则：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">turnNorth</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = .north</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection = <span class="type">CompassPoint</span>.west</span><br><span class="line"><span class="keyword">let</span> rememberedDirection = currentDirection</span><br><span class="line">currentDirection.turnNorth()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The current direction is \(currentDirection)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The remembered direction is \(rememberedDirection)"</span>)</span><br><span class="line"><span class="comment">// 打印 "The current direction is north"</span></span><br><span class="line"><span class="comment">// 打印 "The remembered direction is west"</span></span><br></pre></td></tr></table></figure></p><p>当 <code>currentDirection</code> 的值赋值给 <code>rememberedDirection</code>，实际上也是值拷贝。因此改变 <code>currentDirection</code> 的值并不会影响存储在 <code>rememberedDirection</code> 中原始值的副本。</p><h2 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h2><p>与值类型不同，赋值给变量或常量，或是传递给函数时，引用类型并不会拷贝。引用的不是副本而是已经存在的实例。</p><p>下面这个例子使用了之前定义的 <code>VideoMode</code> 类。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenEighty = <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution = hd</span><br><span class="line">tenEighty.interlaced = <span class="literal">true</span></span><br><span class="line">tenEighty.name = <span class="string">"1080i"</span></span><br><span class="line">tenEighty.frameRate = <span class="number">25.0</span></span><br></pre></td></tr></table></figure></p><p>这个例子声明了一个名为 <code>tenEighty</code> 的常量并将其设置为引用 <code>VideoMode</code> 类的实例。用之前的 <code>1920</code> * <code>1080</code> 的高清分辨率的副本赋给视频模式。将其命名为”<code>1080i</code>“ 并设置为隔行扫描。最后设置帧率为每秒 <code>25.0</code> 帧。</p><p>然后将 <code>tenEighty</code> 赋值给一个名为 <code>alsoTenEighty</code> 的新常量，同时修改其帧率：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoTenEighty = tenEighty</span><br><span class="line">alsoTenEighty.frameRate = <span class="number">30.0</span></span><br></pre></td></tr></table></figure></p><p>因为类是引用类型，所以其实 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 引用了同一个 <code>VideoMode</code> 的实例。实际上，他们只是两个不同名字的相同实例，如下图所示：</p><p>查看 <code>frameRate</code> 的属性 <code>tenEighty</code> ，会发现它正确的引用了 <code>VideoMode</code> 实例的新帧率 <code>30.0</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The frameRate property of tenEighty is now \(tenEighty.frameRate)"</span>)</span><br><span class="line"><span class="comment">// 打印 "The frameRate property of tenEighty is now 30.0"</span></span><br></pre></td></tr></table></figure></p><p>以上的例子还显示了引用类型推断有多费劲。如果 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 在你的代码中相距甚远，那么可能很难找到改变视频模式的所有地方。无论你在哪里使用 <code>tenEighty</code>，都需要考虑用到 <code>alsoTenEighty</code> 的代码，反之亦然。相反，值类型就很好推断，因为在你的源文件中相同值相互作用的所有代码是紧密相连的。</p><div class="note warning"><p>注意<br> <code>tenEighty</code> 和 <code>alsoTenEighty</code> 声明的是常量而不是变量。但是你仍然可以改变 <code>tenEighty.frameRate</code> 和 <code>alsoTenEighty.frameRate</code>，因为常量 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 的值自身实际上没有改变。<code>tenEighty</code> 和 <code>alsoTenEighty</code> 本身并不存储 <code>VideoMode</code> 的实例，他们都只是在底层引用了 <code>VideoMode</code> 的实例。改变的是 <code>VideoMode</code> 的属性 <code>frameRate</code> ，而不是引用 <code>VideoMode</code> 的常量的值。</p></div><h2 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h2><p>因为类是引用类型，在底层可能多个常量和变量引用同一个类的实例。（ 同样的理论对结构体和枚举来说并不有效，因为当它们赋值给常量或变量，或是传递给函数时，总是拷贝的。）</p><p>有时找出两个常量或变量是否引用同一个类的实例很有帮助。为此，Swift 提供了恒等运算符：</p><ul><li>等价于 (<code>===</code>)</li><li>非等价 (<code>!==</code>)</li></ul><p>使用他们来检查两个常量或变量是否引用同一个实例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same VideoMode instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "tenEighty and alsoTenEighty refer to the same VideoMode instance."</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>等价于（ 用三个等号表示 <code>===</code> ）和等于（ 用两个等号表示<code>==</code>）完全不是一回事。等价于意思是两个常量或变量完全引用相同的类实例。等于的意思是两个实例某种意义上的值相等或相同，就像类型设计者定义的那样。</p></div><p>当你自定义结构体或类时，你有责任决定两个实例相等的标准。在 等价运算符中介绍了实现自定义『 等于 』和『 非等于 』的流程。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>如果你有过 <code>C</code>，<code>C++</code>，或 <code>Objective-C</code> 的经验，你或许知道这些语言使用指针来指向内存中的地址。指向某种引用类型实例的 <code>Swift</code> 常量或变量和 <code>C</code> 中的指针类似，但是并不直接指向内存地址，你也不需要写星号（<code>*</code>）来表示创建了一个引用。定义引用和 <code>Swift</code> 中的其他常量或变量一样。如果你需要直接与指针交互标准库提供了指针和 <code>buffer</code> 类型 — 请参阅 <a href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management" target="_blank" rel="noopener">手动内存管理</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;结构体和类是通用，灵活的设计，是你程序代码的结构基础。使用与你定义常量，变量和函数相同的语法来定义属性和方法以此为你的结构体和类添加功能。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="类和结构体" scheme="https://hadesxiye.github.io/tags/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 枚举</title>
    <link href="https://hadesxiye.github.io/2018/10/12/Swift%E6%9E%9A%E4%B8%BE/"/>
    <id>https://hadesxiye.github.io/2018/10/12/Swift枚举/</id>
    <published>2018-10-12T02:37:44.000Z</published>
    <updated>2018-12-04T11:57:26.691Z</updated>
    
    <content type="html"><![CDATA[<p><center><strong>枚举</strong> 为一组相互关联的值定义一种通用类型，它能确保我们在代码中类型安全地使用这些值。 </center><br><a id="more"></a><br>假如你熟悉 C 语言，你应该知道 C 语言中的枚举会为一系列整形值分配相关联的名称。Swift 中的枚举更加灵活，我们不必给每个 case 都提供一个值。如果给枚举的每个 case 分配一个值（被称作“原始”值），这个值可以是字符串或字符类型，也可以是整形或者浮点数。</p><p>此外，枚举中的 case 能够被指定为 任意 不同类型的<strong>关联值</strong>，类似于其它语言中的关联体（unions）和变形体（variants）。我们用枚举定义了一系列相关的情形值时，每个情况的关联值都可以是不同类型。</p><p>枚举在 Swift 中是一等类型，它采用了许多传统语言中只能被类支持的特性，例如计算属性（用来提供枚举值的附加信息）和实例方法（用来提供与枚举值相关联的一些方法）。枚举也可以定义构造函数，用来提供初始值；可以在原有实现的基础上进行功能上的扩展；还可以通过遵守协议来提供标准功能。</p><h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><p>使用 <code>enum</code> 关键词来声明枚举并把它们的全部定义放在一对大括号内：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 枚举的定义放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的例子是使用枚举表示指南针的四个方向：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举中定义的值 (比如 <code>north</code>, <code>south</code>, <code>east</code>, 和 <code>west</code>) 是枚举的成员。使用  case关键字来定义一个新的枚举成员。</p><div class="note warning"><p>注意<br>不像 <code>C</code> 和 <code>Objective-C</code>，<code>Swift</code> 的枚举成员在创建时不会被赋予一个默认的整型值。在上述<code>CompassPoint</code> 一例中，<code>north</code>, <code>south</code>, <code>east</code> 和 <code>west</code> 不会被隐式赋值为 <code>0</code>, <code>1</code>, <code>2</code> 和 <code>3</code>。相反，这些不同的枚举成员本身就是完备的值，并且是明确定义的<code>CompassPoint</code>类型。</p></div><p>多个成员可以出现在同一行，并以逗号来隔开：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个枚举都定义了一个全新的类型。像 Swift 中其他的类型一样，它们的名字（例如 <code>CompassPoint</code> 和 <code>Planet</code> ）应该以大写字母开头。为了阅读起来更简洁明了，以单数形式命名枚举，而不是复数形式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.west</span><br></pre></td></tr></table></figure></p><p> <code>directionToHead</code> 的类型在被 <code>CompassPoint</code> 的一个值初始化时可以推断出来。一旦 <code>directionToHead</code> 被声明为 <code>CompassPoint</code>类型，你可以使用更简短的点语法来设置其为一个不同的 <code>CompassPoint</code> 值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .east</span><br></pre></td></tr></table></figure></p><p>因为 <code>directionToHead</code> 的类型已知，所以你可以在赋值阶段省略类型名。在使用显示类型的枚举值时，这种写法让代码具有更高的可读性。</p><h2 id="用-Switch-语句来匹配枚举值"><a href="#用-Switch-语句来匹配枚举值" class="headerlink" title="用 Switch 语句来匹配枚举值"></a>用 Switch 语句来匹配枚举值</h2><p>在 <code>switch</code> 语句中你可以对每个枚举值进行匹配:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .south</span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line"><span class="keyword">case</span> .north:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line"><span class="keyword">case</span> .south:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</span><br><span class="line"><span class="keyword">case</span> .east:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Where the sun rises"</span>)</span><br><span class="line"><span class="keyword">case</span> .west:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Where the skies are blue"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Watch out for penguins"</span></span><br></pre></td></tr></table></figure></p><p>这段代码可以理解为:</p><blockquote><p>「就 <code>directionToHead</code> 这个值而言，当它等于 <code>.north</code> 时，输出 <code>Lots of planets have a north</code>，当它是 <code>.south</code> 时则会输出 <code>Watch out for penguins</code>」。</p></blockquote><p>以此类推。<br>在 控制流 中提到, 一个 <code>switch</code> 语句必须列举出枚举中的所有值。 如果漏掉了 <code>.west</code> 这个 <code>case</code>，这段代码就会因为没有考虑到 <code>CompassPoint</code> 这个枚举中的所有情况而不会被编译。 需要穷举所有的情况来确保不会有遗漏。</p><p>当不需要给每一个枚举中的情况都写一个 <code>case</code> 时，你可以用 <code>default</code> 来代替其他所有没有被声明的情况：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePlanet = <span class="type">Planet</span>.earth</span><br><span class="line"><span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line"><span class="keyword">case</span> .earth:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Mostly harmless"</span></span><br></pre></td></tr></table></figure></p><h2 id="遍历枚举的情况"><a href="#遍历枚举的情况" class="headerlink" title="遍历枚举的情况"></a>遍历枚举的情况</h2><p>定义一个所有枚举情况的集合在某些枚举中是很有用的。你通过在枚举的名字后面写 : <code>CaseIterable</code>  来使用它。<code>Swift</code> 用 <code>allCases</code> 这个属性来暴露出这个枚举中所有 <code>case</code> 的集合。例子如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Beverage</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices = <span class="type">Beverage</span>.allCases.<span class="built_in">count</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(numberOfChoices) beverages available"</span>)</span><br><span class="line"><span class="comment">// 打印 "3 beverages available"</span></span><br></pre></td></tr></table></figure></p><p>在上面的例子中，通过 <code>Beverage.allCases</code> 可以得到 <code>Beverage</code> 这个枚举包含的所有 <code>case</code> 的集合。你可以想其他集合一样使用 <code>allCases</code> – 集合中的元素为这个枚举的值，在这个例子中也就是 <code>Beverage</code> 的值。上面的例子中得到了枚举中 <code>case</code> 的个数，而下面的例子中则用 <code>for</code> 循环遍历了所有的 <code>case</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure></p><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><p>上一节的示例演示了枚举本身是如何被定义（和分类）的。你可以为 <code>Planet.earth</code> 设置一个常量或变量，并在稍后查看此值。但是，如果能够在这些成员值旁边存储其他类型的 关联值 就更方便了。这能让你存储成员值之外的其他自定义信息，并且每次在代码中使用该成员值时允许这个信息发生变化。</p><p>你可以定义 Swift 枚举以存储任何给定类型的关联值，并且如果需要，每种枚举的值类型可以不同。这种枚举在其他编程语言中称为 区分联合 ， 标记的联合 或 变体。</p><p>例如，假设库存跟踪系统需要通过两种不同类型的条形码跟踪产品。有些产品使用标有数字 <code>0</code> 到 <code>9</code> 的 <code>UPC</code> 格式的 1D 条形码。每个条形码都有一个「数字系统」码，后面跟着五个「制造商代码」码和五个「产品代码」码。然后是「检查」码，以验证条形码是否被正确扫描：</p><img src="/2018/10/12/Swift枚举/枚举01.png"><p>其他产品使用 QR 格式的二维条码进行标记，可以使用任何ISO 8859-1字符，并且可以编码长达 2953 个字符的字符串：</p><img src="/2018/10/12/Swift枚举/枚举02.png"><p>对于库存跟踪系统来说，如果能将 UPC 条形码存储为四个整数的元组，同时将 QR 条形码存储为任意长度的字符串，会是最方便的。</p><p>在 Swift 中，定义这两种类型的产品条形码的枚举如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这可以理解为：<br>「定义一个名为 <code>Barcode</code> 的枚举类型，它可以是一个 <code>upc</code> 的值，带有（ <code>Int</code> ， <code>Int</code> ， <code>Int</code> ， <code>Int</code> ）类型的关联值，或者是一个 <code>qrCode</code>的值，带有 <code>String</code> 类型的关联值。」</p><p>这个定义没有提供任何实际的 <code>Int</code> 或 <code>String</code> 值 — 它只定义了，当一个 <code>Barcode</code> 类型的常量或变量在等于 <code>Barcode.upc</code> 或 <code>Barcode.qrCode</code> 时，可以存储的相关值的 类型 。</p><p>可以使用以下任一类型创建新的条形码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>这个例子创建了一个名为 <code>productBarcode</code> 的新变量，并为它赋值 <code>Barcode.upc</code> ，其关联值为 <code>(8, 85909, 51226, 3)</code> 。</p><p>可以为同一产品分配不同类型的条形码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode = .qrCode(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</span><br></pre></td></tr></table></figure></p><p>这时，原始的 <code>Barcode.upc</code> 和其整形数值被新的 <code>Barcode.qrCode</code> 和其字符串值所替代。条形码的常量和变量可以存储为一个 <code>.upc</code> 或者一个 <code>.qrCode</code> （连同它的关联值），但是在任何指定时间只能存储其中之一。</p><p>像以前一样，不同的条形码可以使用一个 <code>switch</code> 语句来检查。然而这次关联值可以被提取作为 <code>switch</code> 语句的一部分。你可以在 <code>switch</code> 的<code>case</code> 分支代码中提取每个关联值作为一个常量（用 <code>let</code> 前缀）或者一个变量（用 <code>var</code> 前缀）来使用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC: \(numberSystem), \(manufacturer), \(product), \(check)."</span>)</span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: \(productCode)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure></p><p>如果一个枚举成员的所有关联值都被提取作为常量，或者全被提取作为变量，为了简洁，你可以放置一个 <code>var</code> 或者 <code>let</code> 标注在成员名称的前面：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC : \(numberSystem), \(manufacturer), \(product), \(check)."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: \(productCode)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure></p><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><p>在 关联值 小节的条形码例子中演示了一个枚举成员如何声明它们存储着不同类型的关联值。作为关联值的替代，枚举成员可以被默认值（称为 原始值 ）预先填充，其中这些原始值具有相同的类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> tab = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，称为 <code>ASCIIControlCharacter</code> 的枚举的原始值被定义为字符型 <code>Character</code> ，并被设置了一些比较常见的 ASCII 控制字符。字符 值的描述请详见 字符串和字符。</p><p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p><div class="note warning"><p>注意<br>原始值和关联值是 不相同 的。当你开始在你的代码中定义枚举的时候原始值是被预先填充的值，向上述的三个 ASCII 值。对于一个特定的枚举成员，它的原始值始终是相同的。关联值是你在创建一个基于枚举成员的新常量或者变量时才会被设置的，并且每次当你这么做的时候，它的值可以不同。</p></div><h3 id="原始值的隐形赋值"><a href="#原始值的隐形赋值" class="headerlink" title="原始值的隐形赋值"></a>原始值的隐形赋值</h3><p>在使用原始值为整型值或者字符串类型的枚举时，不需要显式的给每一个枚举成员设置原始值，Swift 会自动赋值。</p><p>例如，如果使用整型值作为原始值，隐式赋值的值会依次递增1.如果第一个枚举成员没有设置原始值，那么它的原始值就是 <code>0</code>。</p><p>下面的枚举是对之前的 Planet 这个枚举的一个细化，利用原始整型值来代表每个 <code>planet</code> 在太阳系中的顺序：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury = <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述例子中, <code>Planet.mercury</code> 有一个显式值  <code>1</code> , <code>Planet.venus</code> 有一个隐式值 <code>2</code> , 依次类推。</p><p>当使用字符串作为原始值时，每个枚举成员的隐式初值是该成员的名称。</p><p>下面的枚举是对之前 <code>CompassPoint</code> 枚举的改进，其中使用字符串原始值表示每个方向的名称：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中， <code>CompassPoint.south</code> 有一个隐含的原始值 <code>「south」</code> ，依此类推。</p><p>你可以使用其 <code>rawValue</code> 属性访问枚举的原始值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder = <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection = <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 的值为 "west"</span></span><br></pre></td></tr></table></figure></p><h3 id="使用原始值初始化"><a href="#使用原始值初始化" class="headerlink" title="使用原始值初始化"></a>使用原始值初始化</h3><p>如果使用原始值类型定义枚举，该枚举会自动获得一个初始化方法，该初始化方法接受原始值类型的值（作为名为 <code>rawValue</code> 的参数）并返回枚举成员或 <code>nil</code> 。你可以使用此初始化方法尝试创建枚举的新实例。</p><p>这个例子从原始值 7 中识别出天王星：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 是 Planet? 类型，并且等于 Planet.uranus</span></span><br></pre></td></tr></table></figure></p><p>然而，并非所有 <code>Int</code> 值都会找到匹配的行星。因此，原始值初始化方法始终返回 可选 枚举成员。在上面的例子中， <code>possiblePlanet</code> 的类型是 <code>Planet?</code> ，或<code>「可选的 Planet 」</code>。</p><div class="note warning"><p>注意<br>原始值构造器是一个可失败构造器，因为并非每个原始值都能返回对应的枚举成员。有关更多信息，请参阅 <a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID376" target="_blank" rel="noopener">可失败构造器</a> 。</p></div><p>如果你试图找到一个位置为 <code>11</code> 的行星，那么原始值初始化方法返回的可选 <code>Planet</code> 值将为 <code>nil</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .earth:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There isn't a planet at position \(positionToFind)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "There isn't a planet at position 11"</span></span><br></pre></td></tr></table></figure></p><p>此示例使用可选绑定来尝试访问原始值为 <code>11</code> 的行星。 语句 <code>if let somePlanet = Planet(rawValue: 11)</code> 创建了一个可选的 <code>Planet</code> ，并且当可选 <code>Planet</code> 有返回值时，将 <code>Planet</code> 的值赋给 <code>somePlanet</code> 。 在这个例子中，不可能找到位置为 <code>11</code> 的行星，因此执行 <code>else</code> 分支。</p><h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><p><strong>递归枚举</strong> 是枚举的一种，它允许将该枚举的其他实例，作为自己一个或多个枚举成员的关联值。 你可以通过在枚举成员之前加上 indirect 来表示枚举成员是递归的，它将告诉编译器插入必要的间接层。</p><p>例如，这是一个存储简单算术表达式的枚举：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你还可以在枚举的开头加入 <code>indirect</code> ，以将所有具有关联值的枚举成员标示为可递归的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此枚举可以存储三种算术表达式：普通数字、两个表达式的相加以及两个表达式的相乘。 <code>addition</code> 和 <code>multiplication</code> 枚举成员的相关值同时也是算术表达式 — 这使得嵌套表达式成为可能。 例如，表达式 <code>(5 + 4) * 2</code> 在乘法的右侧有一个数字，在乘法的左侧有另一个表达式。 因为数据是嵌套的，用于存储数据的枚举也需要支持嵌套 — 这意味着枚举需要是可递归的。 下面的代码展示了为 <code>(5 + 4) * 2</code> 创建的 <code>ArithmeticExpression</code> 递归枚举：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>递归函数是一种处理递归结构数据的简单方法。 例如，这是一个计算算术表达式的函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .addition(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br></pre></td></tr></table></figure></p><p>当此函数遇到纯数字，直接返回相关值即可。 当此函数遇到加法或乘法，则分别计算符号左侧和右侧的表达式，然后将它们相加或相乘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;strong&gt;枚举&lt;/strong&gt; 为一组相互关联的值定义一种通用类型，它能确保我们在代码中类型安全地使用这些值。 &lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="枚举" scheme="https://hadesxiye.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 闭包</title>
    <link href="https://hadesxiye.github.io/2018/10/11/Swift%E9%97%AD%E5%8C%85/"/>
    <id>https://hadesxiye.github.io/2018/10/11/Swift闭包/</id>
    <published>2018-10-11T08:54:24.000Z</published>
    <updated>2018-12-04T02:35:36.287Z</updated>
    
    <content type="html"><![CDATA[<p><center>『闭包』是独立的代码块, 可以在你代码中随意传递和使用 。Swift 中的闭包与 Objective-C/C 中的 Block、其他编程语言中的匿名函数相似。</center><br><a id="more"></a></p><p>闭包可以从定义它们的代码的上下文中捕获和存储任何变量。这也被称为这些变量和常量被暂时关闭使用。并且 Swift 负责处理你所捕获的内存进行管理。</p><p>闭包采取如下三种形式之一：</p><ul><li>全局函数是一个有名字但不会捕获任何值的闭包。</li><li>嵌套函数是一个有名字并且可以捕获其封闭函数域内值的闭包。</li><li>闭包表达式是一个用轻量语法所写的可以捕获其上下文中变量或常量值的匿名闭包。</li></ul><p>Swift 的闭包表达式具有干净、清晰的风格，并鼓励在常见场景中进行语法优化使其简明、不杂乱。这些优化主要包括：</p><ul><li>利用上下文推断参数和返回值类型</li><li>单语句表达式的闭包可以隐式返回结果</li><li>参数名称缩写</li><li>尾随闭包语法</li></ul><h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><p>闭包表达式 是一种用简短、集中的语法构建内联闭包的方式。闭包表达式提供了几种语法优化的方式，使其能够写出简短的闭包而又不失去闭包函数的可读性。下面的闭包表达式示例，通过在几次迭代中不断改善 <code>sorted(by:)</code> 方法的方式来说明这些优化，每一次迭代都用更简洁的方式描述了相同的功能。</p><h3 id="方法排序"><a href="#方法排序" class="headerlink" title="方法排序"></a>方法排序</h3><p>Swift的基础库提供了一个名字叫做 <code>sorted(by:)</code> API，它通过你编写的一个闭包来进行对数组进行排序。 当完成所有排序代码,  <code>sorted(by:)</code> 方法会返回一个与旧数组相同规格和相同类型的新数组, 并且每个元素都会在正确的位置。 最开始的数组也不会通过 <code>sorted(by:)</code> 被修改。</p><p>下面的闭包示例使用了 <code>sorted(by:)</code> 方法进行了对于 <code>String</code> 类型进行反向排序。这是最开始将要被排序的数组：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br></pre></td></tr></table></figure></p><p><code>sorted(by:)</code> 方法接受一个闭包表达式，闭包表达式接受两个相同类型的数组元素，并且返回 <code>Bool</code> 布尔值来告诉是否第一个值应该在第二个值的前面还是后面。如果这个第一个值应该在第二个值 前面 则返回 <code>true</code>, 反之返回 <code>false</code>。</p><p>这个例子是对 <code>String</code> 类型的数组进行排序，因此这个闭包需要是  <code>(String, String) -&gt; Bool</code> 类型的函数。</p><p>提供该排序闭包的一种方法是写正确类型的函数，并且作为参数传入 <code>sorted(by:)</code> 方法中。 如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backward</span><span class="params">(<span class="number">_</span> s1: String, <span class="number">_</span> s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames = names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 会等于 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></span><br></pre></td></tr></table></figure></p><p>如果第一个字符串「s1」大与第二个字符串「s2」，<code>backward(_:_:)</code> 函数将返回 <code>true</code> ，指示 <code>s1</code> 在这个排序数组中位置应该在 <code>s2</code> 的前面。对于字符串来说，“大于”的意思就是“在字母表中出现较后”。这意思是说字母 <code>&quot;B&quot;</code> 是大于字母 <code>&quot;A&quot;</code> 的，也就是说字符串 <code>&quot;Tom&quot;</code> 是大于 <code>&quot;Tim&quot;</code> 的。这是一个反向排序的例子  <code>&quot;Barry&quot;</code> 将出现在 <code>&quot;Alex&quot;</code> 前面，依此类推。</p><p>然而，使用单一表达式的函数「a&gt;b」是一种相当冗长的方式。在本例中最好写法是使用闭包表达式内联的方式编写一个排序闭包。</p><h2 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h2><p>闭包表达式语法基本组成如下:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>parameters</code> 在闭包表达式中当作入参，但它们没有默认值。如果你参数类型为入参，则可以在闭包中使用可变类型的方法。元组也可以当做参数和返回值。</p><p>下面的例子展示了上面  <code>backward(_:_:)</code> 函数的闭包表达式版本：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注意这个内联闭包与  <code>backward(_:_:)</code> 函数的入参和返回值是相同的。在这两种情况下，它被写成  <code>(s1: String, s2: String) -&gt; Bool</code> 。然而，对于内联闭包表达式，参数和返回值被写在花括号‘内部’，而不是外部。</p><p>闭包表达式主体部分开始于关键字 <code>in</code> 。这个关键字也代表这个闭包的入参和返回值已经声明结束，主体部分将要开始。</p><p>因为上面闭包表达式的主体部分比较短，甚至可以写成一行。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p><p>这也说明了 <code>sorted(by:)</code> 方法总体调用保持不变。一对括号仍然包含该方法的入参。然而，现在参数却是一个内联闭包了。</p><h3 id="通过上下文推测类型"><a href="#通过上下文推测类型" class="headerlink" title="通过上下文推测类型"></a>通过上下文推测类型</h3><p>因为这个排序闭包是作为一个方法的参数，Swift 能够推断出这个闭包的参数和返回值。 <code>sorted(by:)</code> 方法将被一个字符串数组调用，以至于方法参数的函数的类型一定是 <code>(String, String) -&gt; Bool</code> 。这也意味  <code>(String, String)</code> 和  <code>Bool</code>类型可以不需要作为闭包定义的一部分。也正因为推断出了所有入参和返回值，返回的符号 (<code>-&gt;</code>) 和入参周围的括号也可以被省略。简写后如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p><p>当闭包以内联的形式作为一个函数或者方法的参数传入时，始终可以被推断出入参和返回值的类型。因此，当内联闭包被方法或函数当作参数使用时，你也不需要以完整形式去写这个内联闭包。</p><p>尽管如此，你也按照个人意愿将参数类型显示出来。如果这样的做法可以让你的读者对你的代码不保持模凌两可，显示参数类型也是被鼓励使用的。在 sorted(by:) 方法的调用情况下，闭包的目的是帮助一个数组进行排序，也正因为这个闭包在字符串数组中被使用，可以让读者轻松推断出这个闭包正在使用 <code>String</code> 类型的值。</p><h3 id="单一闭包表达式隐式返回"><a href="#单一闭包表达式隐式返回" class="headerlink" title="单一闭包表达式隐式返回"></a>单一闭包表达式隐式返回</h3><p>单一闭包表达式可以省略声明 <code>return</code> 关键字来返回单一表达式的结果，上一个事例省略后如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p><p>这里，这个 <code>sorted(by:)</code> 方法函数类型清晰的表明闭包必须返回一个 <code>Bool</code> 类型的值。也因为这个闭包内部包含一个单一表达式 (<code>s1 &gt; s2</code>) 并且返回一个明确的 <code>Bool</code> 类型的值，因此关键字 <code>return</code> 可以被省略。</p><h3 id="缩写参数名"><a href="#缩写参数名" class="headerlink" title="缩写参数名"></a>缩写参数名</h3><p>Swift 自动为内联闭包提供了参数名缩写写法，这里可以使用<code>$0</code>, <code>$1</code>, <code>$2</code> 等来代替闭包的参数。</p><p>如果你在闭包表达式中使用了缩写写法，你就可以省略闭包中的参数声明部分，并且这个缩写参数的值和类型也会通过函数预期类型推断出来。<code>in</code> 关键字也可以被省略，因为这个闭包表达式已经通过主体完全构建出来了。缩写后如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><p>这里，<code>$0</code> 和 <code>$1</code> 的值指的是第一个和第二个 <code>String</code> 的参数</p><h3 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h3><p>实际上还有一种 更简短 的方式来编写上面例子中的闭包表达式。Swift 的 <code>String</code> 类型将其大于运算符（<code>&gt;</code>）的字符串特定实现为具有两个 <code>String</code> 类型参数的方法，并返回一个 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by: )</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于运算符，Swift 可以自动推断出你想使用其特定于字符串的实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure></p><h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将闭包表达式作为函数的最后一个参数传入函数，并且这个闭包非常长，这样的情况下使用 “尾随闭包” 这种写法会很有效。尾随闭包通常在函数调用的括号之后，即使他仍是一个参数。当你使用尾随闭包语法，你可以不用填写函数入参为闭包那部分的参数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里被调用函数没用后置闭包的写法:</span></span><br><span class="line"></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里被调用函数使用后置闭包的写法:</span></span><br><span class="line"></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 尾随闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的字符串排序闭包 闭包表达式语法 作为尾随闭包被写在 <code>sorted(by:)</code>  方法的括号外部，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted() &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>如果函数只有一个闭包类型入参，并且使用了尾随闭包的写法，当你调用这个函数的时候可以省略函数名称后面写 <code>()</code> ，写法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>如果一个闭包代码很长以至于不能把它写在同一行上，这时使用后置闭包写法就比较有用了。例如，Swift 的 <code>Array</code> 类型的 <code>map(_:)</code> 方法就把闭包表达式作为唯一的参数传入。对数组中每个元素调用一次闭包，并为该元素返回一个映射值（可能是其他类型）。映射的值和类型由调用的闭包制定。</p><p>将提供的闭包应用到数组中的每个元素之后，<code>map(_:)</code> 方法会返回一个包含所有新映射值的新数组，并与原数组保持相同顺序。</p><p>下面介绍如何调用 <code>map(_:)</code> 方法并使用后置闭包的写法，来对一个 <code>Int</code> 类型的数组转换成 String 类型的数组。<code>[16, 58, 510]</code> 数组用于创建新数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames = [</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Zero"</span>, <span class="number">1</span>: <span class="string">"One"</span>, <span class="number">2</span>: <span class="string">"Two"</span>,   <span class="number">3</span>: <span class="string">"Three"</span>, <span class="number">4</span>: <span class="string">"Four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"Five"</span>, <span class="number">6</span>: <span class="string">"Six"</span>, <span class="number">7</span>: <span class="string">"Seven"</span>, <span class="number">8</span>: <span class="string">"Eight"</span>, <span class="number">9</span>: <span class="string">"Nine"</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br></pre></td></tr></table></figure></p><p>这段代码上边创建了一个映射字典，整数数字作为键，以整数数字转换的英文作为值。并定义了一个整形数组，准备去转换成字符串数组。</p><p>你可以调用数组的  <code>map(_:)</code> 方法并传入一个后置闭包表达式，将 <code>numbers</code> 类型的数组转换为一个 <code>String</code> 类型的数组：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = numbers.<span class="built_in">map</span> &#123; (numbers) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> number = numbers</span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        output = digitNames[number % <span class="number">10</span>]! + output</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">while</span> number &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 被推测成 [String] 类型的数组</span></span><br><span class="line"><span class="comment">// 它的值为 ["OneSix", "FiveEight", "FiveOneZero"]</span></span><br></pre></td></tr></table></figure></p><p> <code>map(_:)</code> 方法传入的闭包表达式会调用数组中每一个元素。你将不需要指定闭包的入参 <code>number</code> 类型，因为这个类型在数组映射的时候可以被推断出来。</p><p>这个例子中，局部变量 <code>number</code> 是在闭包主体中初始化并赋予闭包入参  <code>number</code> 的值，因此可以在闭包体内修改它的值。(函数或闭包的参数是常量)。闭包表达式也指定了一个 <code>String</code> 类型的返回值，指明了映射数组的返回值类型。</p><p>闭包表达式每次被调用时都会构建一个名为 <code>output</code> 的字符串。它通过取余操作 <code>(number % 10)</code> 获取 <code>number</code> 最末位数字并通过这个数组去字典  <code>digitNames</code>  找到对应的字符串。闭包可以使用字典找到所有大于等于 <code>0</code> 的字符串。</p><div class="note warning"><p>注意<br>字典 <code>digitNames</code> 下标形式的调用之后是感叹号 (<code>!</code>) ，因为字典下标形式调用返回一个可选类型的值，表示对应键值不存可能查找失败的情况。上边的例子中 <code>number % 10</code> 获得的值一定作为  <code>digitNames</code> 字典的有效下标，因此使用感叹号强制解包字典索引下的 <code>String</code> 类型的值。 </p></div><p>通过  <code>digitNames</code>  字典检索出得字符串会被存储在 <code>output</code> 字符串的前面，通过这种反向操作有效的构建了一个与原始值每个数字位置相同的字符串。( 取余表达式  <code>number % 10</code> ,在 <code>16</code> 值是 <code>6</code> ，在 <code>58</code> 值是<code>8</code> ，在 <code>510</code> 值是 <code>0</code> ) 。</p><p>然后这个 <code>number</code> 的值除以 <code>10</code> 。因为是整形在除法时会被四舍五入，然后 <code>16</code> 变成 <code>1</code> , <code>58</code> 变成 <code>5</code> , <code>510</code> 变成 <code>51</code>。</p><p>这个过程被一直被重复直到 <code>number</code> 值为 <code>0</code> 。 <code>output</code> 字符串在闭包中被返回，并且添加到了 <code>map(_:)</code> 方法的输出数组中。</p><p>上边的例子中使用了后置闭包的写法让这个闭包被调用后代码立即巧妙的封装函数的功能，不需要在 <code>map(_:)</code> 方法的括号里包装闭包体。</p><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><p>闭包可以 捕获 它所定义的上下文环境中的常量和变量。在闭包体内可以使用和修改这些常量和变量的值， 即使这些常量、变量的作用域已经不存在了。</p><p>在 Swift 中，闭包捕获值的最简单的形式是嵌套函数–写在另一个函数的函数体内。嵌套函数可以捕获外部函数中的任意参数，也可以捕获定义在函数外部的任意常量、变量。</p><p>这是一个例子，一个叫做 <code>makeIncrementer</code> 的函数内部包含了一个嵌套函数 <code>incrementer</code> 。嵌套函数  <code>incrementer()</code> 从它所在的上下文环境中，捕获了两个值，<code>runningTotal</code> 和 <code>amount</code> 。捕获这些值之后 <code>incrementer</code> 作为一个每调用一次就会让 <code>runningTotal</code> 和 <code>amount</code> 的值进行相加的闭包被 <code>makeIncrementer</code> 函数返回。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>makeIncrementer</code> 的返回值类型是  <code>() -&gt; Int</code>。这意味着它返回的是一个 函数，而不是一个简单的值。 这个函数没有参数，每次被调用后会返回一个 <code>Int</code> 类型的值。想了解一个函数如何返回其他函数，请参考 函数类型和返回值类型.</p><p><code>makeIncrementer(forIncrement:)</code> 这个函数定义了一个整型变量 <code>runningTotal</code>，用来存储将被返回的计算后的总和。这个变量的初始值是 <code>0</code> 。</p><p><code>makeIncrementer(forIncrement:)</code>  函数有一个 <code>Int</code> 型的参数，参数标签是 <code>forIncrement</code> ，参数名是 <code>amount</code> 。传递给这个参数的参数值用来指定每一次增加函数被调用后  <code>runningTotal</code> 的值增加多少。 <code>makeIncrementer</code> 函数定义了一个名为 <code>incrementer</code> 的嵌套函数，这个函数用来执行具体的增加操作。这个函数只进行简单的相加，并将结果返回。</p><p>当单独来看 <code>incrementer()</code> 这个嵌套函数时，会觉得有点不可思议：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    runningTotal += amount</span><br><span class="line">    <span class="keyword">return</span> runningTotal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>incrementer()</code>  是一个无参数的函数，但是在它的函数体内却使用了  <code>runningTotal</code> 和 <code>amount</code> 这两个变量。<br>通过从它周围的函数中将 <code>runningTotal</code>、 <code>amount</code> 这两个变量进行捕获，并在自己的函数内使用。 通过引用进行捕获来确保 <code>makeIncrementer</code> 函数调用结束后 <code>runningTotal</code> 和 <code>amount</code> 这两个变量不消失，同时也可以确保在下一次调用 <code>incrementer</code> 函数时 <code>runningTotal</code> 是可用的。</p><div class="note warning"><p>注意<br>作为优化，如果一个值在闭包内没被修改，或闭包创建后该值没被修改，Swift 可能会替换捕获而是存储这个值的一个 拷贝。<br>Swift 还会处理所有不再被使用的变量的内存管理问题。</p></div><p>这是一个 <code>makeIncrementer</code> 的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementer(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>这里定义了一个常量 <code>incrementByTen</code>，每次调用加数器函数都会将 <code>10</code> 和 <code>runningTotal</code> 变量的值相加，最后将函数的返回值赋值给常量 <code>incrementByTen</code>。多次调用这个函数的打印结果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回值是 10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回值是 20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回值是 30</span></span><br></pre></td></tr></table></figure></p><p>如果你创建第二个加数器，它会存储一个新的、单独的 <code>runningTotal</code> 变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回值是  7</span></span><br></pre></td></tr></table></figure></p><p>继续调用原来的加数器（<code>incrementByTen</code>）会继续让它自己的 <code>runningTotal</code> 变量增加，不会影响到 <code>incrementBySeven</code> 捕获到的变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回值是 40</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>如果你将闭包作为一个类实例的属性，闭包通过引用该实例或其他成员来捕获该实例，在闭包和实例之间可能会导致循环引用。Swift 使用 捕获列表 来打断循环引用。更多信息请参考 <a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56" target="_blank" rel="noopener">闭包的循环引用</a> 。</p></div><h2 id="闭包引用类型"><a href="#闭包引用类型" class="headerlink" title="闭包引用类型"></a>闭包引用类型</h2><p>在上面的例子中，<code>incrementBySeven</code>  和 <code>incrementByTen</code> 是常量，但是这些常量闭包仍然能够增加它们捕获到的 <code>runningTotal</code> 变量。这因为闭包和函数是 引用类型。</p><p>无论你分配变量还是常量给函数或闭包，实际上你是设置闭包或者函数引用该常量或变量。在上面的例子中，闭包 <code>incrementByTen</code> 选择 引用 的是常量，而不是闭包本身内容。</p><p>这也意味这如果你分配一个闭包两个不同的变量或常量, 这些常量和变量引用相同的闭包：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen = incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回值为 50</span></span><br></pre></td></tr></table></figure></p><h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><p>当一个闭包作为参数传递给函数时，闭包被称为 逃逸 了函数，但是会在函数返回后才调用。当您声明将闭包作为参数之一的函数时，可以在参数的类型之前写入 <code>@ escape</code>，用来表示允许闭包逃逸。</p><p>有一种闭包可以逃逸的方式是存储在函数外定义的变量中。比如，许多有异步操作的函数以闭包参数作为 <code>completion handler</code>。函数在启动操作之后就已经返回，但在操作完成之后才调用闭包——这种闭包就需要需要逃逸，以便函数返回后调用。例如:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <code>someFunctionWithEscapingClosure(_:)</code> 函数将闭包作为它的参数，并且添加到函数之外的数组中。如果你不将函数中的这个参数标记为 <code>@escaping</code>，将为得到一个编译时的错误。<br> 用 <code>@escaping</code> 标记闭包意味着你会在闭包中显式地使用 <code>self</code>。在刚才的例子中，传递给 <code>someFunctionWithEscapingClosure(_:)</code> 的是一个逃逸闭包，意味着需要显式地使用 <code>self</code>。相对来说，传给 <code>someFunctionWithNonescapingClosure(_:)</code> 的是一个非逃逸闭包，就意味着可以隐式地使用 <code>self</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印 "200"</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印 "100"</span></span><br></pre></td></tr></table></figure></p><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><p><strong>自动闭包</strong> 自动包装书写的表达式，并将表达式作为一个闭包传入的函数。自动闭包不包含任何参数，当它被调用时会返回一个内部表达式包装的值。这种写法让你使用正常表达式而不是闭包的语法使你可以省略函数旁边的大括号。</p><p>调用 类型函数采用自动闭包是常见的，实现 该类型的函数并不常见。例如， <code>assert(condition:message:file:line:)</code> 方法为 <code>condition</code> 和 <code>message</code> 参数采用了自动闭包的写法，参数  <code>condition</code> 只在编译时取值，并且 <code>message</code> 参数只在 <code>condition</code> 参数为 <code>false</code> 时取值。</p><p>一个自动闭包能让我们延时取值，因为内部代码没有运行，直到你调用这个闭包。延时取值对于较大计算量和具有副作用的代码是非常有效的，因为这样能够让你去控制何时计算该代码，下面的代码展示了闭包如何延时计算：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// 打印 "5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// 打印 "5"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line"><span class="comment">// 打印 "Now serving Chris!"</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// 打印 "4"</span></span><br></pre></td></tr></table></figure></p><p>尽管在闭包内部 <code>customersInLine</code> 的第一个元素被移除了，但是在闭包被调用之前，该元素是不会被移除。如果这个闭包永远不会被调用，那么这个闭包内部的表达式将永远不会执行，这意味着这个数组中的元素永远不会被移除。注意 <code>customerProvider</code> 不是一个 字符串 类型而是 <code>() -&gt; String</code> — 一个没有参数且返回值是字符串的函数。</p><p>当你将闭包作为参数传递给函数时，你能获得同样的延时求值行为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine 数组是 ["Alex", "Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// 输出 "Now serving Alex!"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中的 <code>serve(customer:)</code> 函数接受一个返回顾客姓名的显示闭包。下面这个版本的 <code>serve(customer:)</code> 完成同样的功能，不过它并没有接受一个显示闭包，而是接受一个自动闭包，使用 <code>@autoclosure</code> 关键字标记参数。现在你可以将这个函数当作一个接受 <code>String</code> 类型的参数的函数而不是一个闭包一样调用。这个参数会自动转换成一个闭包，因为参数 <code>customerProvider</code> 的类型被标记成 <code>@autoclosure</code> 属性。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  customersInLine 数组是 ["Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 输出 "Now serving Ewa!"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>自动闭包使用过多会让你的代码很难阅读。 函数和上下文应该明确表明代码被延迟执行。</p></div><p>如果你想一个自动闭包也允许逃逸闭包的功能，你需要同时标记 <code>@autoclosure</code> 和 <code>@escaping</code> 关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine 数组值为 ["Barry", "Daniella"]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(<span class="number">_</span> customerProvider: @autoclosure @escaping <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Collected \(customerProviders.count) closures."</span>)</span><br><span class="line"><span class="comment">// 打印 "Collected 2 closures."</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Now serving Barry!"</span></span><br><span class="line"><span class="comment">// 打印 "Now serving Daniella!"</span></span><br></pre></td></tr></table></figure></p><p>在上边代码中，闭包作为 <code>customerProvider</code> 参数传入方法， <code>collectCustomerProviders(_:)</code> 函数为 <code>customerProviders</code> 数组拼接传入的闭包。数组 <code>customerProviders</code> 在函数外部定义，这意味着数组中的闭包允许在函数返回之后执行。综上所述，函数使用范围内必须允许 <code>customerProvider</code> 参数逃逸。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;『闭包』是独立的代码块, 可以在你代码中随意传递和使用 。Swift 中的闭包与 Objective-C/C 中的 Block、其他编程语言中的匿名函数相似。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="闭包" scheme="https://hadesxiye.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 函数</title>
    <link href="https://hadesxiye.github.io/2018/10/10/Swift%E5%87%BD%E6%95%B0/"/>
    <id>https://hadesxiye.github.io/2018/10/10/Swift函数/</id>
    <published>2018-10-10T05:00:57.000Z</published>
    <updated>2018-12-01T08:52:20.521Z</updated>
    
    <content type="html"><![CDATA[<p><center><br><strong>函数</strong> 是执行一个具体任务的一段独立代码块，你可以通过为函数命名来标识其任务功能，当需要执行这个任务时，函数名就可以用来「调用」该函数。</center><br><a id="more"></a></p><p><code>Swift</code> 的统一的函数语法非常灵活，以致于从一个简单、无参数名的 <code>C</code> 风格函数，到一个复杂、多参数名的 <code>Objective-C</code> 风格方法都可以灵活表达。参数可以通过设置一个默认值，以简化函数的调用。 也可以传递可修改参数，一旦函数完成执行，传递的参数值就会被修改。</p><p><code>Swift</code> 中的函数类型由参数值类型和返回值类型共同组成。你可以像其它类型一样来使用这个类型，这样把一个函数做为参数传递给另一个函数就会非常容易，并且可以从其它函数来返回函数。另外，一个封装了具体功能的函数能直接嵌套在另一个函数的代码块中。</p><h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><p>在定义一个函数时，你可以可选地提供一个或多个输入值作为参数。当函数执行完成时，你也能可选地提供一个值作为返回值。</p><p>每一个函数的 函数名 描述了这个这个函数需要做的事情。你可以通过这个函数名去调用它并为它提供符合参数类型的参数值。 函数的实参值必须按形参的参数列表顺序依次传入。</p><p>下面我们定义一个 <code>greet(person:)</code> 方法 , 它表示向一个人打招呼， 它接受一个 <code>String</code> 类型的值做为输入并返回一个 <code>String</code> 类型的值 。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + person + <span class="string">"!"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数名的定义应该清晰地指明这个函数的功能，函数的函数名前面必须要加 <code>func</code> 关键字。函数 <code>-&gt;</code> (向右的箭头) 后面是返回值，<code>-&gt;</code> 后面跟返回值的类型。</p><p>上面方法的方法名描述了这个方法要做的事情、需要的参数值和当执行完成时返回的值。在其他地方调用时，这个方法清晰的表达了它的作用<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// Prints "Hello, Anna!"</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"Brian"</span>))</span><br><span class="line"><span class="comment">// Prints "Hello, Brian!"</span></span><br></pre></td></tr></table></figure></p><p>为了简化函数体书写，我们可以把消息的创建和返回合并在一条语句中:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetAgain</span><span class="params">(person: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + person + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// Prints "Hello again, Anna!"</span></span><br></pre></td></tr></table></figure></p><h3 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h3><p>在 <code>Swift</code> 中，函数的参数和返回值是非常灵活的。你能定义任何事 无论是一个单一参数的简单函数 还是有着多个参数和不同参数选项的复杂函数。</p><h4 id="无参函数"><a href="#无参函数" class="headerlink" title="无参函数"></a>无参函数</h4><p>函数可以没有参数。 下面是一个没有参数的函数，当调用时，它总是返回同一个 <code>String</code> 类型的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloWorld())</span><br><span class="line"><span class="comment">// Prints "hello, world"</span></span><br></pre></td></tr></table></figure></p><h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><p>函数也可以有多个参数，这些参数写在函数名后面的 <code>()</code> 内，参数之间通过 , 逗号分隔。</p><p>下面方法接受一个 <code>String</code> 类型的人名值和是否已经打过招呼的 <code>Bool</code> 值作为输入，返回一个给这个人打招呼的信息：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> greetAgain(person: person)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> greet(person: person)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Prints "Hello again, Tim!"</span></span><br></pre></td></tr></table></figure></p><h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><p>函数也可以没有返回值。这个 <code>greet(person:)</code> 函数版本就没有返回值，而是将结果直接打印出来：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, \(person)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">"Dave"</span>)</span><br><span class="line"><span class="comment">// Prints "Hello, Dave!"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>严格意义来说,  <code>greet(person:)</code> 函数 仍然 返回一个值，只是这个返回值没有被定义。函数返回值没有定义时，默认是返回 <code>Void</code> 类型。它是一个简单的空元祖，可以被写做 <code>()</code> 。</p></div><p>调用函数时，它的返回值可以被忽略：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAndCount</span><span class="params">(string: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line">    <span class="keyword">return</span> string.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printWithoutCounting</span><span class="params">(string: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = printAndCount(string: string)</span><br><span class="line">&#125;</span><br><span class="line">printAndCount(string: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" and returns a value of 12</span></span><br><span class="line">printWithoutCounting(string: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" but does not return a value</span></span><br></pre></td></tr></table></figure></p><p>第一个函数 <code>printAndCount(string:)</code> 打印一个字符串，然后返回这个字符串的字符集数量。 第二个函数 <code>printWithoutCounting(string:)</code> 调用第一个函数，忽略了第一个函数的返回值。 所以当调用第二个函数时， 信息仍然被第一个函数打印了，但第一个函数的返回值确没被使用。</p><div class="note warning"><p>注意<br>返回值可以被忽略， 但函数的返回值还是需要接收。 一个有返回值的函数的返回值不允许直接丢弃不接收，如果你尝试这样做，编译器将给你抛出错误。</p></div><h4 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h4><p>你可以用一个元祖类型包装多个值来作为一个函数的返回值。</p><p>下面这个 <code>minMax(array:)</code> 函数，它找出参数数组中的最大整数和最小整数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个 <code>minMax(array:)</code> 函数返回一个包含了两个整型 <code>Int</code> 的元祖。 它们的键名分别是 <code>Max</code> 和 <code>Min</code>，所以你可以通过这个键名来访问这两个值。</p><p><code>minMax(array:)</code> 方法先定义了两个变量 <code>currentMin</code> 和 <code>currentMax</code> ，分别存储这数组中第一个元素。 然后迭代数组，检查每一个值是否比最小值小或比最大值大，如果是则分别记录这个值。 最后，找出的最小值和最大值被包装在一个元祖中返回。<br>因为这个元祖的成员值被作为函数返回值的一部分，最大值和最小值能通过点语法来直接被访问。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bounds = minMax(array: [<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min is \(bounds.min) and max is \(bounds.max)"</span>)</span><br><span class="line"><span class="comment">// Prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意这个从函数返回的元祖的成员不需要在被指定键名，因为它们的键名已经被作为函数返回类型的一部分而指定。</p></div><h4 id="可选元祖返回类型"><a href="#可选元祖返回类型" class="headerlink" title="可选元祖返回类型"></a>可选元祖返回类型</h4><p>如果从函数返回的元祖类型有可能为空， 你可以用一个可选元祖来指示这个返回值可能为 <code>nil</code> 。你可以在元祖返回类型后面加上一个 <code>?</code> 问号来表示返回值可能为空， 例如 <code>(Int, Int)?</code> 或 <code>(String, Int, Bool)?</code>。</p><div class="note warning"><p>注意<br>一个可选的元祖类型例如 <code>(Int, Int)?</code> 和元祖值可选例如 <code>(Int?, Int?)</code> 是不同的。 对于前者是整个元祖可能为空，而后者则是元祖内每一个独立的元素可能为空。</p></div><p>上面这个 <code>minMax(array:)</code> 函数返回了一个包含两个 <code>Int</code> 值的元祖。然而，这个函数没有对传递进来的数组进行任何安全性的检查。 如果这个数组为空， 这个 <code>minMax(array:)</code> 函数在尝试访问数组第一个元素时，将在运行时触发一个数组越界的错误。</p><p>为了处理空数组这种情况，将 <code>minMax(array:)</code> 方法的返回值标记为可选类型。如果数组为空，将返回 <code>nil</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你也能用可选值绑定的方法来检查 <code>minMax(array:)</code> 方法是否返回一个有效值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds = minMax(array: [<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"min is \(bounds.min) and max is \(bounds.max)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure></p><h2 id="函数的参数标签和参数名"><a href="#函数的参数标签和参数名" class="headerlink" title="函数的参数标签和参数名"></a>函数的参数标签和参数名</h2><p>每一个参数都由一个 <strong>参数标签</strong> 和一个 <strong>参数名</strong> 构成。 参数标签被用在调这个方法时； 每一个参数标签写在参数的前面。参数名被用在函数的具体实现中。 默认参数的参数标签可以不写，用参数名来作为参数标签。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数体内， 变量 firstParameterName 和 变量 secondParameterName 所对应的值分别是第一个和第二个参数传递进来的</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(firstParameterName: <span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>所有的参数必须有一个唯一的名称。 尽管多个参数可以有相同的参数标签， 但唯一的参数标签将使你的代码可读性更好。</p><h3 id="明确参数标签"><a href="#明确参数标签" class="headerlink" title="明确参数标签"></a>明确参数标签</h3><p>参数标签在参数名前面， 通过一个空格 <code></code> 来分隔：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(argumentLabel parameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数体内，变量 parameterName 的值对应是参数传递进来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数标签省略"><a href="#参数标签省略" class="headerlink" title="参数标签省略"></a>参数标签省略</h3><p>如果一个参数不需要参数标签，可以用下划线<code>_</code> 来代替之前的参数标签。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(<span class="number">_</span> firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数体中，变量 firstParameterName 和 secondParameterName 分别对应第一个和第二个参数的值</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>你可以给函数的任何参数提供一个默认值，通过写在参数类型后面。 如果提供了默认值，你就可以在调用时省略给这个参数传值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithoutDefault: Int, parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用时如果你没有给第二个参数传值，那么变量  parameterWithDefault 的值默认就是 12 。</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// 变量 parameterWithDefault 的值是 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// 变量 parameterWithDefault 的值是 12</span></span><br></pre></td></tr></table></figure></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数 接受 <code>0</code> 个或多个具体相同类型的值。调用时，你可以用一个可变参数来代表这些有着不确定数量的多个参数。在参数类型后面跟上 <code>3</code> 个点 <code>...</code> 来表示参数的数量可变。</p><p>传入函数体内的可变参数可以被当做一个数组类型来使用。 下面这个例子中，变量名 <code>numbers</code> 表示的一系列可变参数（每一个的类型为 <code>Double</code> ）被合并成更合适的数组类型 <code>[Double]</code> 。</p><p>函数 <code>arithmeticMean()</code> 为传入的一系列数字计算出平均值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(<span class="number">_</span> numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3，5 个数的平均值是 3</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0，3 个数的平均值是 10.0</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br>一个函数至多只能有一个可变参数。</p></div><h3 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h3><p>函数参数默认是常量，不能直接修改其值。编译器会报错如果你尝试在函数体内修改传入参数的值。 但如果你执意要修改这个参数值， 并希望在函数执行完成后修改的值仍然有效， 那么用 传入传出参数 来代替普通参数。</p><p>传入传出参数通过在参数类型前加上 <code>inout</code> 关键字来定义。传入传出参数可以有一个初始值， 传入函数后值将被修改，在函数执行完传出后，这个变量的初始值就会被替换完成。 更多有关传出传出参数的行为和编译器优化的详细讨论，请移步<br><a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" target="_blank" rel="noopener">In-Out Parameters</a>。</p><p>传入传出参数只支持变量。常量或字面量将不被允许做为参数传递，因为它们都不能被修改。 传值时，在参数名前面加上 <code>&amp;</code> 符号，来表示它能在函数体内被修改。</p><div class="note warning"><p>注意<br>传入传出参数不能有默认值，并且可变参数也不能被标记 <code>inout</code> 。</p></div><p>下面这个 <code>swapTwoInts(_:_:)</code> 函数，有两个参数名分别为 <code>a</code> 和 <code>b</code> 的传入传出参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>swapTwoInts(_:_:)</code> 函数简单地交换两个传入参数 <code>a</code> 和 <code>b</code> 的值。 首先将参数 <code>a</code> 的值存储于临时变量 <code>temporaryA</code>中，然后将 <code>b</code> 的值赋值给 <code>a</code> ， 最后将临时变量 <code>temporaryA</code> 的值再赋值给 b。</p><p>你可以通过传递两个<code>Int</code>类型的参数来调用<code>swapTwoInts(_:_:)</code>函数来交换彼此的值。 需要注意的是， 在调用 <code>swapTwoInts(_:_:)</code>方法时，变量 <code>someInt</code> 和 <code>anotherInt</code> 需要加上 <code>&amp;</code> 符号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now \(someInt), and anotherInt is now \(anotherInt)"</span>)</span><br><span class="line"><span class="comment">// 打印 "someInt is now 107, and anotherInt is now 3"</span></span><br></pre></td></tr></table></figure></p><p>上面这个例子中，即便变量 <code>someInt</code> 和 <code>anotherInt</code> 被定义在函数体外部，但通过参数传递，<code>swapTwoInts(_:_:)</code> 函数还是修改了彼此的初始值。</p><div class="note warning"><p>注意<br>在同一个函数中，传入传出参数和返回值不一定要同时存在。上面这个例子中， <code>swapTwoInts</code> 函数没有返回值， 但变量 <code>someInt</code> 和 <code>anotherInt</code> 的初始值仍然被修改了。 传入传出参数为函数影响函数体外部的作用域提供了一种可选的方式。</p></div><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>每个函数的具体 函数类型 由它的参数类型和返回类型共同决定。</p><p>举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h2><p><code>Swift</code> 中，函数类型的使用和其他类型一样。 举个例子， 你可以定义 一个函数类型的常量或变量，并给其赋一个函数类型的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br></pre></td></tr></table></figure></p><p>你可以理解为：</p><p>『 定义了一个函数类型的 <code>mathFunction</code> 变量，「 它接收两个 <code>Int</code> 类型的参数，并返回一个 <code>Int</code> 值。」并把 <code>addTwoInts</code> 函数关联给这个变量。』</p><p><code>mathFunction</code> 的类型和 <code>addTwoInts(_:_:)</code> 函数的类型相同，所以<code>Swift</code> 的类型检查器将允许这样的赋值。</p><p>现在，你就可以用 <code>mathFunction</code> 变量来调用 <code>addTwoInts(_:_:)</code> 函数了：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(2, 3))"</span>)</span><br><span class="line"><span class="comment">// 打印 "Result: 5"</span></span><br></pre></td></tr></table></figure></p><p>有着相同类型的不同方法可以赋值给同一个变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction = multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(2, 3))"</span>)</span><br><span class="line"><span class="comment">// 打印 "Result: 6"</span></span><br></pre></td></tr></table></figure></p><p>像其他类型一样，当然你给一个变量或常量赋一个函数类型的值时， Swift 将帮你自动推导出值的真实类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction = addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction 被会自动推导成 `(Int, Int) -&gt; Int` 类型</span></span><br></pre></td></tr></table></figure></p><h2 id="函数类型作为参数"><a href="#函数类型作为参数" class="headerlink" title="函数类型作为参数"></a>函数类型作为参数</h2><p>你可以把 <code>(Int, Int) -&gt; Int</code> 类型的函数作为一个参数传递给另一个函数。 当这个函数被调用时，这使得具体实现逻辑被当做一个函数传递给了这个函数的调用者。</p><p>下面这个例子，打印 <code>math functions</code> 函数相加后的结果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(<span class="number">_</span> mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Result: \(mathFunction(a, b))"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 打印 "Result: 8"</span></span><br></pre></td></tr></table></figure></p><p>这个例子中， 定义了一个 <code>printMathResult(_:_:_:)</code> 的函数，它接收三个参数。第一个参数是一个叫 <code>mathFunction</code>的函数，其类型是 <code>(Int, Int) -&gt; Int</code>。 你可以为第一个参数传递一个类型是 <code>(Int, Int) -&gt; Int</code> 的函数作为参数。 第二个和第三个参数 <code>a</code> 和 <code>b</code> 都是 <code>Int</code> 类型。这两个变量被当做第一个函数参数的输入值传入给了第一个参数。</p><p>当调用 <code>printMathResult(_:_:_:)</code> 时，分别传递 <code>addTwoInts(_:_:)</code> 函数 和另外两个值 <code>3</code> 和 <code>5</code>。 <code>3</code> 和 <code>5</code> 被当做第一个函数的参数传递给它做了相加，最终打印结果 <code>8</code>。</p><p>函数 <code>printMathResult(_:_:_:)</code> 的作用是打印 <code>addTwoInts(_:_:)</code> 函数的返回值。 它不关心传入函数的具体实现 — 只关心传入函数的正确类型。 这使得 <code>printMathResult(_:_:_:)</code> 函数把一些具体的功能逻辑实现推给了它的调用者。</p><h2 id="返回类型为函数类型"><a href="#返回类型为函数类型" class="headerlink" title="返回类型为函数类型"></a>返回类型为函数类型</h2><p>你可以把一个函数类型作为另一个函数的返回类型。在这个返回箭头后面 <code>(-&gt;)</code> 跟上你要返回的具体函数类型。</p><p>下面这个例子分别定义了两个 <code>stepForward(_:)</code> 和 <code>stepBackward(_:)</code> 简单的函数。 <code>stepForward(_:)</code> 函数返回一个在其输入值上 <code>+1</code> 后的值， <code>stepBackward(_:)</code> 方法返回一个在其输入值上<code>-1</code> 后的值，两个方法的函数类型都是 <code>(Int) -&gt; Int</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <code>chooseStepFunction(backward:)</code> 函数的返回类型是 <code>(Int) -&gt; Int</code>。  该函数根据一个 <code>Bool</code> 类型值来判断是返回 <code>stepForward(_:)</code> 还是 <code>stepBackward(_:)</code> 函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你可以通过调用 <code>chooseStepFunction(backward:)</code> 并为其输入一个 <code>Bool</code> 类型的值来获得一个递增或递减的函数:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 变量 moveNearerToZero 现在引用着 stepBackward() 函数</span></span><br></pre></td></tr></table></figure></p><p>在上面这个例子中，最终返回递增还是递减函数由 <code>currentValue</code> 变量的值来决定。 变量 <code>currentValue</code> 的初始值是 <code>3</code> ， <code>currentValue &gt; 0</code> 比较结果就为 <code>true</code>，所以调用 <code>chooseStepFunction(backward:)</code> 后返回 <code>stepBackward(_:)</code> 函数。 常量 <code>moveNearerToZero</code>存储着该函数的返回函数。</p><p>现在 <code>moveNearerToZero</code> 表示这个递减函数，从输入值递减至 <code>0</code> ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="comment">// Counting to zero:</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(currentValue)... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure></p><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>到目前为止，在本章中你遇到的这些函数例子都是 全局函数 ， 它们被定义在全局作用域上。 当然，你也可以在函数体内定义一个函数，来做为该函数的 嵌套函数 。</p><p>虽然嵌套函数默认对函数体外部是透明的，但仍然可以被该函数调用。 函数也可以通过返回其内部的嵌套函数来使这个被嵌套的函数在外部作用域可以被使用。</p><p>你可以重写上面的 <code>chooseStepFunction(backward:)</code> 函数，来返回和使用其内部的嵌套函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentValue = -<span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//  `moveNearerToZero` 变量引用着 `stepForward()` 函数</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(currentValue)... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;strong&gt;函数&lt;/strong&gt; 是执行一个具体任务的一段独立代码块，你可以通过为函数命名来标识其任务功能，当需要执行这个任务时，函数名就可以用来「调用」该函数。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="函数" scheme="https://hadesxiye.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2 控制流</title>
    <link href="https://hadesxiye.github.io/2018/10/09/Swift%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>https://hadesxiye.github.io/2018/10/09/Swift控制流/</id>
    <published>2018-10-09T09:53:57.000Z</published>
    <updated>2018-12-01T08:53:18.083Z</updated>
    
    <content type="html"><![CDATA[<p><center>Swift 提供了多种控制流结构。其中包含 <code>while</code> 循环来执行多次任务； <code>if</code>、 <code>guard</code> 和 <code>switch</code> 语句来执行特定条件下不同的代码分支； 还有 <code>break</code> 和 <code>continue</code> 语句使控制流跳转到你代码中的其他位置。</center><br><a id="more"></a></p><p>Swift 还提供了 <code>for</code>-<code>in</code> 循环用来更简便的遍历数组（arrays）， 字典（dictionaries），区间（ranges），字符串（strings），和其他序列类型。</p><p>Swift 的 <code>switch</code> 语句比其他的类 C 语言更加强大。<code>case</code> 可以匹配多种不同的模式，包括间隔匹配（interval matches），元祖（tuples），和转换到特定类型。<code>switch</code> 语句的 case 体中匹配的值可以绑定临时常量或变量，在每个 case 中也可以使用  <code>where</code> 来实现更复杂的匹配情况。</p><h2 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h2><p>可以使用 <code>for-in</code> 循环来遍历序列中的所有元素，例如数组中的所有元素，数字的范围，或者字符串的字符。</p><p>你也可以通过遍历一个字典来访问它的键值对。遍历字典时其中的每个元素都会返回成 <code>(key, value)</code> 元组<code>（Tuple）</code>的形式， 你也可以在 <code>for-in</code> 循环中显式的命名常量来分解 <code>(key, value)</code>元组。 在下面的例子中，字典中的值<code>（Key）</code>被分解为 <code>animalName</code> 常量，字典中的值<code>（Value）</code>被分解为 <code>legCount</code> 常量。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(animalName)s have \(legCount) legs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ants have 6 legs</span></span><br><span class="line"><span class="comment">// cats have 4 legs</span></span><br><span class="line"><span class="comment">// spiders have 8 legs</span></span><br></pre></td></tr></table></figure></p><p>上面的例子中，常数 <code>index</code> 的值在每次循环开始时都会自动赋值。因此，<code>index</code> 不需要在使用前进行声明。只要声明循环时，包含了该常量，就会对其进行隐式声明，不需要使用声明关键词  <code>let</code> 。</p><p>如果你不需要使用区间中的所有值，你可以使用 <code>-</code> 替代变量名来忽略对应的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...power &#123;</span><br><span class="line">    answer *= base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(base) to the power of \(power) is \(answer)"</span>)</span><br><span class="line"><span class="comment">// Prints "3 to the power of 10 is 59049"</span></span><br></pre></td></tr></table></figure></p><p>在一些情况中你可能不想使用包含两个端点的闭区间。想象在手表表面上画每分钟的刻度标记。你想要从 <code>0</code> 分钟开始画 <code>60</code> 个刻度标记。可以使用半开区间操作符（<code>..&lt;</code>）来包含下界但不包含上界。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minutes = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="number">0</span>..&lt;minutes &#123;</span><br><span class="line">    <span class="comment">// 每分钟渲染一个刻度线（60 次）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些用户在他们的界面上可能想要更少的刻度标记。他们可能更喜欢每 <code>5</code> 分钟一个刻度。使用 <code>stride(from:to:by:)</code> 函数可以跳过不需要的标记。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minuteInterval = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// 每 5 分钟打一个标记（0, 5, 10, 15 ... 45, 50, 55）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 <code>stride(from:through:by:)</code> 使用闭区间也是可以的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hours = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> hourInterval = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</span><br><span class="line">    <span class="comment">// 每 3 小时打一个标记（3, 6, 9, 12）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h2><p>一个 <code>while</code> 循环会一直执行一组语句直到条件变为 <code>false</code> 。这类循环最适合第一次循环前不知道循环的次数的情况。Swift 提供两种类型的 <code>while</code> 循环：</p><ul><li><code>while</code> 在每次循环开始时判断条件。</li><li><code>repeat</code>-<code>while</code> 在每次循环结束时判断条件。</li></ul><p>下方是 <code>repeat</code>-<code>while</code> 循环的一般形式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Swift 提供两种条件语句：<code>if</code> 语句和 <code>switch</code> 语句。通常，使用 <code>if</code> 语句来执行结果可能性较少的简单条件；<code>switch</code> 语句则更适合于有较多组合的更复杂的条件，而且，当需要使用模式匹配来判断执行合适的代码段时，<code>switch</code> 语句会更有用。</p><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><p><code>if</code> 语句最简单的形式只有一个 <code>if</code> 条件，而且只有当这个条件为 <code>true</code> 时才会执行对应的代码。</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p><code>switch</code> 语句会将某一个值与其它几种可能匹配的模式进行比较，然后它会执行第一个匹配成功的模式下对应的代码块。当可能的情形非常多时，应该使用 <code>switch</code> 语句替代 <code>if</code> 语句。</p><p><code>switch</code> 语句最简单的形式是将一个值和另外一个或几个同类型的值进行比较。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>:</span><br><span class="line">    respond to value <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> value <span class="number">2</span>,</span><br><span class="line">     value <span class="number">3</span>:</span><br><span class="line">    respond to value <span class="number">2</span> or <span class="number">3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 <code>switch</code> 语句必须是 可穷尽的。 也就是说，判断的类型的每个可能的值都要有一个 <code>switch</code> 的分支（<code>case</code>）与之对应。为每个可能的值创建一个分支是不合理的，你可以定义一个默认分支来覆盖没有单独处理的其他所有值。这个默认分支使用 <code>default</code> 关键字声明，并且必须放在最后。</p><p>下面例子使用 <code>switch</code> 语句匹配名为 <code>someCharacter</code> 的单个小写字符：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"z"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first letter of the alphabet"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"z"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The last letter of the alphabet"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Some other character"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The last letter of the alphabet"</span></span><br></pre></td></tr></table></figure></p><h4 id="不存在隐式的贯穿"><a href="#不存在隐式的贯穿" class="headerlink" title="不存在隐式的贯穿"></a>不存在隐式的贯穿</h4><p>与 C 语言和 Objective-C 中的 <code>switch</code> 语句相反，Swift 中的 <code>switch</code> 语句在执行完一个分支后不会「贯穿」到下一个分支。相反，整个 <code>switch</code> 语句一旦完成第一个匹配的 <code>switch</code> 分支就会结束，而不需要明确的 <code>break</code> 语句。这使得 Swift 中的 switch 语句比 C 语言中的更加安全、易用，并且避免了错误地执行多个 <code>switch</code> 分支的情况。</p><div class="note warning"><p>注意<br>虽然在 Swift 中  <code>break</code> 不是必须的，你可以使用 <code>break</code> 语句来匹配和忽略特定的分支或者或者在分支全部执行前跳出。更多细节，查看  <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID139" target="_blank" rel="noopener">Switch 语句中的 Break</a>。<br></p></div><h4 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h4><p> <code>switch</code> 中分支匹配的值也可以是一个区间。这个例子使用数字区间来匹配任意数字对应的自然语言格式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount = <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings = <span class="string">"moons orbiting Saturn"</span></span><br><span class="line"><span class="keyword">let</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount = <span class="string">"no"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</span><br><span class="line">    naturalCount = <span class="string">"a few"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">12</span>:</span><br><span class="line">    naturalCount = <span class="string">"several"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>..&lt;<span class="number">100</span>:</span><br><span class="line">    naturalCount = <span class="string">"dozens of"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>..&lt;<span class="number">1000</span>:</span><br><span class="line">    naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount = <span class="string">"many"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are \(naturalCount) \(countedThings)."</span>)</span><br><span class="line"><span class="comment">// Prints "There are dozens of moons orbiting Saturn."</span></span><br></pre></td></tr></table></figure></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>你可以使用元组在同一个 <code>switch</code> 语句中测试多个值。可以针对不同的值或值的间隔来测试元组的每个元素。或者使用下划线（<code>_</code>）来匹配任何可能的值，这也被称为通配符模式。</p><p>下面的示例声明了一个 (x, y) 点，该变量是类型为 <code>(Int, Int)</code> 的元组，并将其显示在示例后面的图上。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(somePoint) is at the origin"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(somePoint) is on the x-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(somePoint) is on the y-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(somePoint) is inside the box"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(somePoint) is outside of the box"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "(1, 1) is inside the box"</span></span><br></pre></td></tr></table></figure></p><p>与 C 语言不同，Swift 允许同一个值符合多个 <code>switch</code> 分支。实际上，在这个例子中，点 (0, 0) 匹配所有四个分支。但是，如果匹配多个分支，则始终使用第一个匹配的分支。点 (0, 0) 首先匹配 <code>case (0, 0)</code>，因此所有其他的匹配分支都被忽略。</p><h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p><code>switch</code> 分支可以将其匹配的一个值或多个值赋值给临时的常量或变量，常量或变量可以在 <code>case</code> 主体中使用。这个行为被称为值绑定，因为值在 <code>case</code> 主体中被绑定给临时的常量或变量。</p><p>下面的示例声明了一个 (x, y) 点，其类型为 <code>(Int, Int)</code> 的元组，并且该点展示在示例后面的图上：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the x-axis with an x value of \(x)"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the y-axis with a y value of \(y)"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"somewhere else at (\(x), \(y))"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "on the x-axis with an x value of 2"</span></span><br></pre></td></tr></table></figure></p><p>三个 <code>switch</code> 分支声明了占位符常量 <code>x</code> 和 <code>y</code>，暂时从 <code>anotherPoint</code> 中获取一个或多个元组值。第一个分支 <code>case (let x, 0)</code> 匹配任何 <code>y</code> 值为 <code>0</code> 的点，并把 <code>x</code> 的值赋值给临时常量 <code>x</code>。同样地，第二个分支 <code>case (0, let y)</code> 匹配任何 <code>x</code> 值为 <code>0</code> 的点，并把 <code>y</code> 的值赋值给临时常量 <code>y</code>。</p><p>在声明临时常量之后，可以在 <code>case</code> 代码块中使用该常量。这里，它们用来打印点的分类。</p><p>这个 <code>switch</code> 语句没有 <code>default</code> 分支。在最后一个分支 <code>case let (x, y)</code> 中，声明了一个可以匹配任何值的有两个占位符常量的元组。因为 <code>anotherPoint</code> 是有两个值的元组，这个分支可以匹配剩余的任何值，并不需要 <code>default</code> 分支来使 <code>switch</code> 语句穷举。</p><h4 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h4><p><code>switch</code> 分支中可以使用 <code>where</code> 子句来检测额外的条件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(\(x), \(y)) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "(1, -1) is on the line x == -y"</span></span><br></pre></td></tr></table></figure></p><p>三个 <code>switch</code> 分支声明了占位符常量 <code>x</code> 和 <code>y</code>，它们从 <code>yetAnotherPoint</code> 中获取两个元组值。这些常量用作 <code>where</code> 子句的一部分，用来创建一个动态分类器。只有当 <code>where</code> 子句满足计算值为 <code>true</code> 时，<code>switch</code> 分支才匹配当前的 <code>point</code>。</p><p>与前一个示例一样，最后一个 <code>case</code> 匹配所有剩余的值，所以不需要 <code>default</code> 分支来使 <code>switch</code> 语句穷举。</p><h4 id="复合分支"><a href="#复合分支" class="headerlink" title="复合分支"></a>复合分支</h4><p>在 <code>case</code> 后面写多个模式可以把多个分支共享在同一个主体中，每个模式用逗号隔开。如果任何一个模式匹配，那么这个分支就是匹配的。如果模式太多，可以把模式写为多行。比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(someCharacter) is a vowel"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</span><br><span class="line">     <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(someCharacter) is a consonant"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(someCharacter) is not a vowel or a consonant"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "e is a vowel"</span></span><br></pre></td></tr></table></figure></p><p><code>switch</code> 语句的第一个分支匹配英语中的所有五个小写元音。同样，第二个分支匹配所有的小写辅音。最后，<code>default</code> 分支匹配其余字符。</p><p>复合分支也可以包含值绑定。复合分支的所有模式必须包含在同一组值绑定中，并且每个绑定必须从复合分支的所有模式中获取相同类型的值。这样确保无论复合分支中哪个部分匹配，分支主体的代码总是可以访问绑定的值，并且确保值总是有相同的类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stillAnotherPoint = (<span class="number">9</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> stillAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> <span class="built_in">distance</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="keyword">let</span> <span class="built_in">distance</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"On an axis, \(distance) from the origin"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not on an axis"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "On an axis, 9 from the origin"</span></span><br></pre></td></tr></table></figure></p><p>上面的 <code>case</code> 中有两个模式：<code>(let distance, 0)</code> 匹配 x 轴上的点，<code>(0, let distance)</code> 匹配 <code>y</code> 轴上的点。两种模式都包含 <code>distance</code> 的绑定，<code>distance</code> 在两种模式中是一个整数，这意味着 <code>case</code> 主体中的代码总是可以访问 <code>distance</code> 的值。</p><h2 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h2><p>控制转移语句通过将控制从一段代码转移到另一段代码来改变代码的执行顺序。Swift 中有五个控制转移语句：</p><ul><li><code>continue</code></li><li><code>break</code></li><li><code>fallthrough</code></li><li><code>return</code></li><li><code>throw</code></li></ul><h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><p><code>continue</code> 语句告诉循环停止正在做的事情，并在循环的下一次迭代开始时再启动。它仿佛在说「我完成了当前的循环迭代」而没有完全离开循环。</p><p>下面的示例从小写字符串中删除所有的元音和空格，并创建一个神秘的谜语：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> puzzleInput = <span class="string">"great minds think alike"</span></span><br><span class="line"><span class="keyword">var</span> puzzleOutput = <span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> charactersToRemove: [<span class="type">Character</span>] = [<span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>, <span class="string">" "</span>]</span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput &#123;</span><br><span class="line">    <span class="keyword">if</span> charactersToRemove.<span class="built_in">contains</span>(character) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        puzzleOutput.append(character)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(puzzleOutput)</span><br><span class="line"><span class="comment">// 打印 "grtmndsthnklk"</span></span><br></pre></td></tr></table></figure></p><p>上面的代码只要匹配到元音或空格时就调用 <code>continue</code> 关键字，使循环的本次迭代立即结束并跳到下一次迭代的开始。</p><h3 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h3><p><code>break</code> 语句立即结束整个控制流语句的执行，当你想在 <code>switch</code> 或循环中提前结束时，可以在 <code>switch</code> 或循环中使用 <code>break</code> 语句。</p><h4 id="在循环语句中使用-Break"><a href="#在循环语句中使用-Break" class="headerlink" title="在循环语句中使用 Break"></a>在循环语句中使用 Break</h4><p>在循环语句中使用时，<code>break</code> 立即结束循环的执行，并把控制转移到循环右括号（<code>}</code>）后面的代码上。不执行来自当前循环迭代的下一步代码，并且不再开始循环的迭代。</p><h4 id="在-Switch-语句中使用-Break"><a href="#在-Switch-语句中使用-Break" class="headerlink" title="在 Switch 语句中使用 Break"></a>在 Switch 语句中使用 Break</h4><p>在 <code>switch</code> 语句中使用时，<code>break</code> 会使 <code>switch</code> 语句立即结束执行，并把控制转移到 <code>switch</code> 语句的右括号（<code>}</code>）后面的代码上。</p><p>此行为可用于匹配和忽略 <code>switch</code> 语句中的一个或多个分支。 因为 <code>Swift</code> 的 <code>switch</code> 语句是穷举的并且不允许空分支，所以有时需要故意匹配并忽略一个分支使你的意图明确。 你可以将 <code>break</code> 语句作为要忽略的分支的整个主体来使用。当该分支与 <code>switch</code> 语句匹配时，分支中的 <code>break</code> 语句使 <code>switch</code> 语句立即结束执行。</p><div class="note warning"><p>注意<br>如果 <code>switch</code> 分支只包含注释会报编译时错误。 注释不是语句，不会使 <code>switch</code> 分支被忽略。总是使用 <code>break</code> 语句来忽略 <code>switch</code> 分支。</p></div><h3 id="贯穿"><a href="#贯穿" class="headerlink" title="贯穿"></a>贯穿</h3><p>在 Swift 中， <code>switch</code> 语句的每个分支在判断结束后不会「贯穿」到下一个分支。即，整个 <code>switch</code> 语句会在第一个匹配的分支语句执行完成后终止。相反地，<code>C</code> 语言明确要求在每个 <code>switch</code> 分支结束时手动添加 <code>break</code> 语句来防止贯穿。相对而言，默认没有贯穿使得 Swift 中的 <code>switch</code> 语句更加简洁，可读性更强，并可以因此避免错误地执行多个 <code>switch</code> 分支。</p><p>如果需要像 <code>C</code> 语言中那样的贯穿行为，你可以在分支中逐个添加 <code>fallthrough</code> 关键字。 下面这个例子就利用了贯穿 <code>fallthrough</code> 来给数字添加描述。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description = <span class="string">"The number \(integerToDescribe) is"</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description += <span class="string">" a prime number, and also"</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description += <span class="string">" an integer."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 打印 "The number 5 is a prime number, and also an integer."</span></span><br></pre></td></tr></table></figure></p><div class="note warning"><p>注意<br> <code>fallthrough</code> 关键字不会检查 <code>switch</code> 语句中下一个分支的条件，它只是让代码在执行的过程中直接进入下一个分支 (或 <code>default</code> 分支) 中的语句, 就像 <code>C</code> 语言中 <code>switch</code> 语句的标准行为。 </p></div><h3 id="带标签语句"><a href="#带标签语句" class="headerlink" title="带标签语句"></a>带标签语句</h3><p>在 Swift 中，你可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用 <code>break</code> 语句来提前结束整个代码块。因此，显式地指明 <code>break</code> 语句想要终止的是哪个循环体或者条件语句，会很有用。类似地，如果你有许多嵌套的循环体，显式指明 <code>continue</code> 语句想要影响哪一个循环体也会非常有用。</p><p>为了实现这个目的，你可以使用标签（ <code>statement label</code> ）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用 <code>break</code> 加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用  <code>break</code> 或者 <code>continue</code> 加标签，来结束或者继续这条被标记语句的执行。</p><p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键字（ <code>introducor keyword</code> ），并且该标签后面跟随一个冒号。下面是一个针对 <code>while</code> 循环体的标签语法，同样的规则适用于所有的循环体和条件语句。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="提前退出"><a href="#提前退出" class="headerlink" title="提前退出"></a>提前退出</h3><p><code>guard</code> 语句和 <code>if</code> 语句一样，根据表达式的布尔值执行语句。 使用 <code>guard</code> 语句要求条件必须为真才能执行 <code>guard</code> 语句之后的代码。 和 <code>if</code> 语句不同，<code>guard</code> 语句总是有一个 <code>else</code> 分支 — 如果条件不为真，则执行 <code>else</code> 分支中的代码。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: [String: String])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = person[<span class="string">"name"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello \(name)!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location = person[<span class="string">"location"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I hope the weather is nice near you."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I hope the weather is nice in \(location)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(person: [<span class="string">"name"</span>: <span class="string">"John"</span>])</span><br><span class="line"><span class="comment">// 打印 "Hello John!"</span></span><br><span class="line"><span class="comment">// 打印 "I hope the weather is nice near you."</span></span><br><span class="line">greet(person: [<span class="string">"name"</span>: <span class="string">"Jane"</span>, <span class="string">"location"</span>: <span class="string">"Cupertino"</span>])</span><br><span class="line"><span class="comment">// 打印 "Hello Jane!"</span></span><br><span class="line"><span class="comment">// 打印 "I hope the weather is nice in Cupertino."</span></span><br></pre></td></tr></table></figure></p><p>如果满足 <code>guard</code> 语句的条件，则在 <code>guard</code> 声明的结束括号后继续执行代码。 当任何变量或常量在使用可选绑定作为条件被赋值后，它的值都可用于 <code>guard</code> 语句后的其余代码块。</p><p>如果不满足该条件，则执行 <code>else</code> 分支内的代码。 该分支必须转移控制以退出 <code>guard</code> 语句后的代码块。 它可以通过控制转移语句来执行此操作，例如 <code>return</code> ， <code>break</code> ， <code>continue</code> 或 <code>throw</code> ，也可以调用一个无返回值的函数或方法，例如 <code>fatalError(_:file:line:)</code> 。</p><p>相比于使用 <code>if</code> 语句进行判断，使用 <code>guard</code> 语句可以提高代码的可读性。 它可以让你编写出连贯执行的代码，而不必将其包装在 <code>else</code> 块中，并且让你更加从容地处理异常代码。</p><h3 id="检测-API-可用性"><a href="#检测-API-可用性" class="headerlink" title="检测 API 可用性"></a>检测 API 可用性</h3><p>Swift 内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的 API。</p><p>编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。</p><p>我们在 <code>if</code> 或 <code>guard</code> 语句中使用 可用性条件（availability condition)去有条件的执行一段代码，来在运行时判断调用的 API 是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>, macOS <span class="number">10.12</span>, *) &#123;</span><br><span class="line">   <span class="comment">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 使用先前版本的 iOS 和 macOS 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上可用性条件指定， <code>if</code> 语句的代码块仅仅在 iOS 10 或 macOS 10.12 及更高版本才运行。最后一个参数，<code>*</code>，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本， <code>if</code> 语句的代码块将会运行。</p><p>在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是 <code>iOS</code> ,  <code>macOS</code> ,  <code>watchOS</code> , 和  <code>tvOS</code> —请访问声明属性来获取完整列表。 请参阅 <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID348" target="_blank" rel="noopener">Declaration Attributes</a>。除了指定像 iOS 8 或 macOS 10.10 的大版本号，也可以指定像 iOS 11.2.6 以及 macOS 10.13.3 的小版本号。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(platform name version, ..., *) &#123;</span><br><span class="line">     <span class="type">APIs</span> 可用，语句将执行</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">APIs</span> 不可用，语句将不执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Swift 提供了多种控制流结构。其中包含 &lt;code&gt;while&lt;/code&gt; 循环来执行多次任务； &lt;code&gt;if&lt;/code&gt;、 &lt;code&gt;guard&lt;/code&gt; 和 &lt;code&gt;switch&lt;/code&gt; 语句来执行特定条件下不同的代码分支； 还有 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 语句使控制流跳转到你代码中的其他位置。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://hadesxiye.github.io/categories/Swift/"/>
    
    
      <category term="Swift4.2" scheme="https://hadesxiye.github.io/tags/Swift4-2/"/>
    
      <category term="控制流" scheme="https://hadesxiye.github.io/tags/%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    
  </entry>
  
</feed>
