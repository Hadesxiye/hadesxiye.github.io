<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fun&amp;Enjoy</title>
  
  <subtitle>this is Hades&#39;s blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hadesxiye.github.io/"/>
  <updated>2018-09-05T07:43:42.048Z</updated>
  <id>https://hadesxiye.github.io/</id>
  
  <author>
    <name>Hades</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLVM</title>
    <link href="https://hadesxiye.github.io/2018/08/23/LLVM/"/>
    <id>https://hadesxiye.github.io/2018/08/23/LLVM/</id>
    <published>2018-08-23T10:54:52.000Z</published>
    <updated>2018-09-05T07:43:42.048Z</updated>
    
    <content type="html"><![CDATA[<p><center>LLVM Logo</center><br><a id="more"></a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a><strong><font color="#FF8C00">LLVM</font></strong></h2><blockquote><p>一个开源编译器架构，目前Xcode采用的就是LLVM架构。</p></blockquote><h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a><strong><font color="#FF8C00">Clang</font></strong></h2><blockquote><p>由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。</p></blockquote><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a><strong><font color="#FF8C00">GCC</font></strong></h2><blockquote><p>GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p></blockquote><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a><strong><font color="#FF8C00">GNU</font></strong></h2><blockquote><p>GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。</p></blockquote><h2 id="在Xcode上使用GCC"><a href="#在Xcode上使用GCC" class="headerlink" title="在Xcode上使用GCC"></a><strong><font color="#FF8C00">在Xcode上使用GCC</font></strong></h2><blockquote><p>Xcode在C和C++上是支持使用GCC的，如下：<br><img src="/2018/08/23/LLVM/XcodeGNU.jpg" title="Xcode9.4上的截图"><br>具体参数的使用请参考：<a href="https://stackoverflow.com/questions/35300064/gnu-gcc-on-xcode" target="_blank" rel="noopener">stackoverflow:Xcode上的GNU GCC</a></p></blockquote><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="LLVM-1"><a href="#LLVM-1" class="headerlink" title="LLVM"></a>LLVM</h3><p>全名：<br>Low Level Virtual Machine  直译：底层虚拟机<br>/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/</p><p>  The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.<br>- 来自LLVM官网的介绍 <a href="http://llvm.org/" target="_blank" rel="noopener">LLVM官网</a></p><p>  LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。</p><p>  LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。<br> - 来自维基百科 <a href="https://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM on wiki</a></p><p>  简单来说</p><blockquote><p>LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。<br>编译器是Clang，GCC，ICC，VC++等。</p></blockquote><h4 id="Xcode和LLVM"><a href="#Xcode和LLVM" class="headerlink" title="Xcode和LLVM"></a>Xcode和LLVM</h4><blockquote><p>Xcode3之前，用的是GCC<br>Xcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器<br>Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留<br>Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能<br>Xcode4.6,LLVM升级到4.2版本<br>Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成</p></blockquote><h3 id="Clang-1"><a href="#Clang-1" class="headerlink" title="Clang"></a>Clang</h3><p>Clang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。<br>Clang项目包括Clang前端和Clang静态分析器等。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang on wiki</a></p><h3 id="GCC-1"><a href="#GCC-1" class="headerlink" title="GCC"></a>GCC</h3><p><a href="http://gcc.gnu.org/" target="_blank" rel="noopener">GCC官网</a><br>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。</p><p>原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。</p><p>许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。</p><p>GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC on wiki</a></p><h3 id="GNU-1"><a href="#GNU-1" class="headerlink" title="GNU"></a>GNU</h3><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">GNU官网</a><br>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。</p><p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。<br>- 来自维基百科 <a href="https://zh.wikipedia.org/zh-cn/GNU" target="_blank" rel="noopener">GNU on wiki</a></p><h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><p>LLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。<br>尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。<br>LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。</p><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU Debugger 顾名思义<br>支持编程语言有C、C++、Pascal以及FORTRAN<br>在许多的类UNIX操作系统上都可以使用</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>lexical analysis /ˈlɛksɪkəl/<br>词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>syntactic analysis，也叫 parsing<br>/sɪnˈtæktɪk əˈnæləsəs/  /ˈpɑːzɪŋ/<br>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.</p><h3 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h3><p>parser<br>通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。</p><h3 id="源语言-amp-源程序"><a href="#源语言-amp-源程序" class="headerlink" title="源语言&amp;源程序"></a>源语言&amp;源程序</h3><p>Source language&amp;Source program<br>被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。</p><h3 id="目标语言-amp-目标程序"><a href="#目标语言-amp-目标程序" class="headerlink" title="目标语言&amp;目标程序"></a>目标语言&amp;目标程序</h3><p>Object language or Target language &amp; Object program or Target program<br>编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。</p><h3 id="中间语言（中间表示）"><a href="#中间语言（中间表示）" class="headerlink" title="中间语言（中间表示）"></a>中间语言（中间表示）</h3><p>Intermediate language（representation）<br>在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。</p><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>Grammars<br>/ˈgræməz/<br>文法是用于描述语言的语法结构的形式规则。</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。<br>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。</p><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>abstract syntax tree或者缩写为AST<br>/ˈæbstrækt ˈsɪnˌtæks tri/<br>抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="CMD-B"><a href="#CMD-B" class="headerlink" title="CMD+B"></a>CMD+B</h3><p>Objective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。<br>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。<br>C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。</p><p>在使用Xcode按下cmd+B后，会经过以下流程：<br><img src="/2018/08/23/LLVM/02.png" title="Clang/LLVM 编译过程"><br><strong>预处理（Pre-process）</strong>：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。</p><p><strong>词法分析 （Lexical Analysis）</strong>：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。</p><p><strong>语法分析（Semantic Analysis）</strong>：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。</p><p><strong>静态分析（Static Analysis）</strong>：使用它来表示用于分析源代码以便自动发现错误。</p><p><strong>中间代码生成（Code Generation）</strong>：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</p><p><strong>优化（Optimize）</strong>：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p><p><strong>生成目标文件（Assemble）</strong>：生成Target相关Object(Mach-o) 。</p><p><strong>链接（Link）</strong>：生成 Executable 可执行文件。</p><p>关于此过程的详细测试，参考<a href="https://juejin.im/post/5a30ea0ff265da43094526f9" target="_blank" rel="noopener">掘金</a></p><h3 id="LLVM的具体操作"><a href="#LLVM的具体操作" class="headerlink" title="LLVM的具体操作"></a>LLVM的具体操作</h3><p>请参考<a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="noopener">关于LLVM，这些东西你必须知道！</a></p><blockquote><p>基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等<br>Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 <code>a+b</code> 改为 <code>a-(-b)</code><br>将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了<br>基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。</p></blockquote><p>所以基于LLVM可以完成：</p><ul><li>做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。</li><li>编写ClangPlugin，命名规范，代码规范，扩展功能。</li><li>编写Pass，代码混淆优化。</li></ul><h3 id="使用Clang进行开发"><a href="#使用Clang进行开发" class="headerlink" title="使用Clang进行开发"></a>使用Clang进行开发</h3><p>详细参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p><p>Clang的特性<br>相比于 GCC，Clang 具有如下优点：</p><ul><li>编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。</li><li>占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。</li><li>模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。</li><li>诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。</li><li>设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。</li></ul><p>当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强：</p><ul><li>支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。</li><li>支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。</li></ul><p>以下是目前GCC和Clang对C++支持的情况：<br><img src="/2018/08/23/LLVM/03.png" title="GCC Clang对C++支持对比"></p><p>更多参考<a href="https://zh.cppreference.com/w/cpp/compiler_support" target="_blank" rel="noopener">C++ 编译器支持情况表</a></p><h3 id="使用LLVM创建一个编译器"><a href="#使用LLVM创建一个编译器" class="headerlink" title="使用LLVM创建一个编译器"></a>使用LLVM创建一个编译器</h3><p>首先参考这篇文章来写一个helloworld<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/" target="_blank" rel="noopener">IBM developerWorks</a></p><p>关于LLVM IR的生成与创建<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm2/index.html" target="_blank" rel="noopener">IBM developerWorks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;LLVM Logo&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编译相关" scheme="https://hadesxiye.github.io/categories/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="LLVM" scheme="https://hadesxiye.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="https://hadesxiye.github.io/tags/Clang/"/>
    
      <category term="GNU" scheme="https://hadesxiye.github.io/tags/GNU/"/>
    
      <category term="GCC" scheme="https://hadesxiye.github.io/tags/GCC/"/>
    
      <category term="Xcode" scheme="https://hadesxiye.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本的入门（一）</title>
    <link href="https://hadesxiye.github.io/2018/08/15/Shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hadesxiye.github.io/2018/08/15/Shell脚本的入门（一）/</id>
    <published>2018-08-15T10:48:08.000Z</published>
    <updated>2018-08-23T11:05:23.589Z</updated>
    
    <content type="html"><![CDATA[<p><center>Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。</center><br><a id="more"></a></p><h2 id="Simple-BB"><a href="#Simple-BB" class="headerlink" title="Simple BB"></a><strong>Simple BB</strong></h2><blockquote><p>为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路<br>首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。<br>获取目标资源的路径，根据A中的行数进行循环<code>find</code>查找，找到就用<code>cp</code>命令替换，未找到的重定向输出到临时文件B<br>最后打印B的内容，<code>remove</code>临时文件。<br>其中对文本的处理使用了<code>awk</code>命令</p></blockquote><p>脚本下载地址在我的github上 <a href="https://github.com/Hadesxiye/Shell_ReplaceSameNameFile" target="_blank" rel="noopener">资源替换脚本</a></p><hr><h2 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a><strong>Shell介绍</strong></h2><blockquote><p>Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。<br>而我使用shell只是因为<br>我用的mac - -</p></blockquote><hr><h2 id="Shell的工作原理"><a href="#Shell的工作原理" class="headerlink" title="Shell的工作原理"></a><strong>Shell的工作原理</strong></h2><blockquote><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p></blockquote><hr><h2 id="Shell的创建"><a href="#Shell的创建" class="headerlink" title="Shell的创建"></a><strong>Shell的创建</strong></h2><blockquote><p>1.打开文本编辑工具，输入一下内容<br><code>#!/bin/bashecho &quot;Hello World&quot;</code><br>2.保存为 <code>hello world.sh</code>在目录 A<br>3.在终端<code>cd</code>到目录 A<br>4.终端输入<code>chmod +x ./hello world.sh</code> （这一步是给脚本添加权限）<br>5.执行脚本   <code>./hello world.sh</code> 或者 直接把 <code>hello world.sh</code>拖入终端</p></blockquote><p>这很简单，无图。</p><hr><h2 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a><strong>Shell中的变量</strong></h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=&quot;a1&quot;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example=a1</span><br></pre></td></tr></table></figure><p>但是<br><code>example=a 1</code>  并不等同于 <code>example=&quot;a 1&quot;</code><br>因为<code>&quot; &quot;</code>（空格）在shell中用作指令的间隔<br><code>example=a 1</code> 其实只是将a负责给example 然后在输入了个1</p><blockquote><p>这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！</p></blockquote><h3 id="变量的访问"><a href="#变量的访问" class="headerlink" title="变量的访问"></a>变量的访问</h3><p>在变量前加上<code>$</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $example</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a><strong>Shell中的四则运算</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a + $b</span><br><span class="line">$a - $b</span><br><span class="line">$a \* $b</span><br><span class="line">$a / $b</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>乘法的时候需要进行转义<br><code>=</code> 赋值时，前后无空格<br>而运算符号前后必须有空格</p></blockquote><hr><h2 id="Shell中的其他运算符"><a href="#Shell中的其他运算符" class="headerlink" title="Shell中的其他运算符"></a><strong>Shell中的其他运算符</strong></h2><blockquote><p>=、==、!=、！、-o、-a</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-o 或</span><br><span class="line">-a 与</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><blockquote><p>-eq        两个数相等返回true<br>-ne          两个数不相等返回true<br>-gt            左侧数大于右侧数返回true<br>-It          左侧数小于右侧数返回true<br>-ge        左侧数大于等于右侧数返回true<br>-le            左侧数小于等于右侧数返回true</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><blockquote><p>=    两个字符串相等返回true<br>!=    两个字符串不相等返回true<br>-z    字符串长度为0返回true<br>-n    字符串长度不为0返回true<br>-d file    检测文件是否是目录，如果是，则返回 true<br>-r file    检测文件是否可读，如果是，则返回 true<br>-w file    检测文件是否可写，如果是，则返回 true<br>-x file    检测文件是否可执行，如果是，则返回 true<br>-s file    检测文件是否为空（文件大小是否大于0，不为空返回 true<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true</p></blockquote><hr><h2 id="Shell字符串操作"><a href="#Shell字符串操作" class="headerlink" title="Shell字符串操作"></a><strong>Shell字符串操作</strong></h2><pre><code>  mtext="hello"  #定义字符串  mtext2="world"  mtext3=$mtext" "$mtext2  #字符串的拼接  echo $mtext3  #输出字符串  echo ${#mtext3}  #输出字符串长度  echo ${mtext3:1:4}  #截取字符串</code></pre><hr><h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a><strong>Shell数组</strong></h2><pre><code>  array=(1 2 3 4 5)  #定义数组  array2=(aa bb cc dd ee)  #定义数组  value=${array[3]}  #找到某一个下标的数，然后赋值  echo $value  #打印  value2=${array2[3]}  #找到某一个下标的数，然后赋值  echo $value2  #打印  length=${#array[* ]}  #获取数组长度  echo $length</code></pre><hr><h2 id="Shell输出"><a href="#Shell输出" class="headerlink" title="Shell输出"></a><strong>Shell输出</strong></h2><pre><code>  echo</code></pre><hr><h2 id="Shell的判断"><a href="#Shell的判断" class="headerlink" title="Shell的判断"></a><strong>Shell的判断</strong></h2><pre><code>  a=10  b=20  if [ $a == $b ]  then  echo "true"  fi  if [ $a == $b ]  then  echo "true"  else  echo "false"  fi  if [ $a == $b ]  then  echo "a is equal to b"  elif [ $a -gt $b ]  then  echo "a is greater than b"  elif [ $a -lt $b ]  then  echo "a is less than b"  else  echo "None of the condition met"  fi</code></pre><hr><h2 id="Shell中的test命令"><a href="#Shell中的test命令" class="headerlink" title="Shell中的test命令"></a><strong>Shell中的test命令</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  test $[num1] -eq $[num2]  #判断两个变量是否相等</span><br><span class="line">  test num1=num2  #判断两个数字是否相等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-e file    文件存在则返回真</span><br><span class="line">-r file    文件存在并且可读则返回真</span><br><span class="line">-w file    文件存在并且可写则返回真</span><br><span class="line">-x file    文件存在并且可执行则返回真</span><br><span class="line">-s file    文件存在并且内容不为空则返回真</span><br><span class="line">-d file    文件目录存在则返回真</span><br></pre></td></tr></table></figure><hr><h2 id="Shell中的循环"><a href="#Shell中的循环" class="headerlink" title="Shell中的循环"></a><strong>Shell中的循环</strong></h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code>  for ((i=1;i<=10;i++)) 5="" 6="" 7="" 8="" 9="" do="" echo="" $i="" done="" for="" i="" in="" {1..5}="" file="" $home="" .bash*="" $file="" <="" code=""></=10;i++))></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code>  while [ $COUNTER -lt 5 ]  do  COUNTER=`expr $COUNTER + 1`  echo $COUNTER  done  echo '请输入。。。'  echo 'ctrl + d 即可停止该程序'  while read FILM  do  echo "Yeah! great film the $FILM"  done</code></pre><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><pre><code>  break  #跳出所有循环  break n  #跳出第n层f循环  continue  #跳出当前循环</code></pre><hr><h2 id="Shell中的函数"><a href="#Shell中的函数" class="headerlink" title="Shell中的函数"></a><strong>Shell中的函数</strong></h2><blockquote><p>无参数无返回值</p></blockquote><pre><code>  sysout(){  echo "hello world"  }  sysout    </code></pre>> 无参数有返回值<pre><code>  test(){  aNum=3  anotherNum=5  return $(($aNum+$anotherNum))  }  test  result=$?  echo $result</code></pre>> 有参数有返回值<pre><code>  test(){  echo $1  #接收第一个参数  echo $2  #接收第二个参数  echo $3  #接收第三个参数  echo $#  #接收到参数的个数  echo $*  #接收到的所有参数  }  test aa bb cc    </code></pre><h2 id="Shell中的重定向"><a href="#Shell中的重定向" class="headerlink" title="Shell中的重定向"></a><strong>Shell中的重定向</strong></h2><pre><code>  $echo result > file  #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写  $echo result >> file  #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写  echo input < file  #获取输入流</code></pre><h2 id="Shell中的变量操作"><a href="#Shell中的变量操作" class="headerlink" title="Shell中的变量操作"></a><strong>Shell中的变量操作</strong></h2><blockquote><p>awk 指令<br>获取指定行数的资源名字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceNameTemp=$(awk &apos;NR==&quot;&apos;$i&apos;&quot; &#123;print;exit&#125;&apos; $OutputFile)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取对应文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp=$&#123;temp##*/&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>清空文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: &gt; &quot;$OutputFile&quot;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a><strong>常用的Linux命令</strong></h2><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><blockquote><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p></blockquote><blockquote><p>基本结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&apos; file</span><br></pre></td></tr></table></figure></p></blockquote><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中</p><p> <strong>工作原理</strong></p><blockquote><p>第一步：执行BEGIN{ commands }语句块中的语句；<br>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。<br>第三步：当读至输入流末尾时，执行END{ commands }语句块。</p></blockquote><p><strong>BEGIN</strong>语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p><p><strong>END</strong>语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p><p><strong>pattern</strong>语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p><blockquote><p>获取指定行数的文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;NR==&quot;&apos;$i&apos;&quot; &#123;print;exit&#125;&apos; file</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取文件的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print NR&#125;&apos; &quot;file&quot;|tail -n1</span><br></pre></td></tr></table></figure></p></blockquote><p>关于awk的详细用法请参考 <a href="http://man.linuxde.net/awk" target="_blank" rel="noopener">awk命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="https://hadesxiye.github.io/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://hadesxiye.github.io/tags/Shell/"/>
    
      <category term="Linux" scheme="https://hadesxiye.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
