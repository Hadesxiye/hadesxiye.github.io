<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift可选链]]></title>
    <url>%2F2018%2F12%2F07%2FSwift%E5%8F%AF%E9%80%89%E9%93%BE%2F</url>
    <content type="text"><![CDATA[blog 下载 xxxxxx default primary success info warning danger danger no-icon数字1.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 折构过程]]></title>
    <url>%2F2018%2F12%2F07%2FSwift%E6%8A%98%E6%9E%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[析构器 会在类的实例销毁之前被立即调用。使用 deinit 关键字来标示析构器，类似于使用 init 关键字标示构造器。 析构器仅适用于 class 类型。 析构器是如何运作的当不再需要某一个实例时，Swift 会自动销毁该实例，以释放资源。 Swift 通过 自动引用计数（ ARC ）来管理实例内存，就如 自动引用计数 中所述。通常在实例释放时，你无需行手执动清理。但是，当你在使用自己的资源时，可能需要自己执行一些额外的清理。例如，如果你创建了一个自定义类以打开文件并向其写入一些数据，则可能需要在销毁类实例之前关闭该文件。 在类的定义中, 类最多只能有一个析构器。 析构器不接受任何参数，并且没有括号：123deinit &#123; //执行析构器&#125; 在实例销毁之前，会自动调用析构器。你不能自己调用析构器。父类的析构器由其子类继承，父类析构器会在子类析构器实现的末尾自动调用。即使子类不提供自己的析构器，父类析构器也会被调用。 因为实例在调用析构器之后才会被释放，所以析构器可以访问调用它的实例的所有属性，并可以根据这些属性修改其行为（例如查找需要关闭的文件的名称） ）。 析构器实践这是一个析构器的实践。这个例子为一个简单的游戏定义了两个新类型， Bank 和 Player 。 Bank 类管理一种虚拟货币，且流通的货币永远不会超过10,000枚。在游戏中有且只有一个 Bank ，因此 Bank 使用类来实现, 并且该类含有类型属性以及用于存储和管理其当前状态的类型方法：1234567891011class Bank &#123; static var coinsInBank = 10_000 static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int &#123; let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank) coinsInBank -= numberOfCoinsToVend return numberOfCoinsToVend &#125; static func receive(coins: Int) &#123; coinsInBank += coins &#125;&#125; Bank 使用 coinsInBank 属性跟踪它当前持有的硬币的数量。它还提供了两个方法— distribute(coins:) 和 receive(coins:) —来处理硬币的分配和收集。 distribute(coins:) 方法在分配硬币之前先检查银行中是否有足够的硬币。如果没有足够的硬币，Bank 返回的数字将会小于请求的数字（如果银行中没有硬币则返回零）。该方法返回一个整数值，表示实际可提供的硬币数。 receive(coins:) 方法只是将得到的硬币数量添加回银行的总硬币数中。 Player 类描述了游戏中的玩家。每个玩家的钱包在任何时候都有一定数量的硬币。这个数量是由玩家的 coinsInPurse 属性表示：123456789101112class Player &#123; var coinsInPurse: Int init(coins: Int) &#123; coinsInPurse = Bank.distribute(coins: coins) &#125; func win(coins: Int) &#123; coinsInPurse += Bank.distribute(coins: coins) &#125; deinit &#123; Bank.receive(coins: coinsInPurse) &#125;&#125; 每个 Player 实例在初始化期间, 会得到来自银行的指定数量硬币。但是如果银行没有足够的硬币，那么 Player 实例只能拿到少于指定数量的硬币。 Player 类定义了一个 win(coins:) 方法，它从银行中取回一定数量的硬币并将它们添加到玩家的钱包中。 Player 类还实现了一个析构器，它会在 Player 实例被释放前调用。在这个例子中，析构器只是将所有玩家的硬币归还给银行：12345var playerOne: Player? = Player(coins: 100)print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")// 打印 「一个新玩家加入了游戏并获得了100个硬币」print("There are now \(Bank.coinsInBank) coins left in the bank")// 打印 「银行现在剩余9900个硬币」 如果剩余硬币充足，创建一个新 Player 实例同时就需要立即分配100个硬币。这个 Player 实例存储在一个名为 playerOne 的可选值变量中。这里使用可选变量，因为玩家可以随时离开游戏。可选项方式可让你跟踪游戏中当前玩家是否存在。 因为 playerOne 是一个可选值，所以当我们尝试访问它的 coinsInPurse 属性以打印其默认硬币数，或调用它的 win(coins:) 方法时，我们需要加上一个感叹号 （ ! ） 来解包：12345playerOne!.win(coins: 2_000)print("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")// 打印 「PlayerOne 赢了2000个硬币，现在有2100个硬币」print("The bank now only has \(Bank.coinsInBank) coins left")// 打印 「银行现在只剩下7900个硬币」 现在，玩家赢得了 2,000 个硬币。玩家的钱包现在包含 2,100 个硬币，银行只剩下 7,900 个硬币。12345playerOne = nilprint("PlayerOne has left the game")// 打印 「PlayerOne 离开游戏」print("The bank now has \(Bank.coinsInBank) coins")// 打印 「银行现在有10000个硬币」 玩家现在已离开了游戏。通过将可选的 playerOne 变量置为 nil 来表示 「没有 Player 实例。」 此时， playerOne 变量对 Player 实例的引用被销毁。没有其他属性或变量仍然引用着 Player 实例，因此它就会被销毁以释放其内存。在销毁前， Player自动调用了它的析构器被，并将它的硬币送回银行。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>折构过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 构造过程]]></title>
    <url>%2F2018%2F10%2F18%2FSwift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[实例的准备过程，这个过程包含了设置实例每个存储属性的初始值并在实例使用之前执行全部所需的其他设置或初始化。构造过程 就是使用类，结构体或枚举 通过定义构造器来实现构造过程，这更像调用创建某一类型实例的特殊方法。和 Objective-C 的构造器不同，Swift 的构造器不用返回值。它们主要的作用就是确保在第一次使用前某类型的实例都能正确的初始化。 类的实例也可以实现析构器，在该类实例释放前执行自定义的清理工作。关于析构器的更多信息，请参阅 析构过程. 设置存储属性的初始值类和结构体在其创建实例时 必须 为它们所有的存储属性设置适当的初始值。存储属性不能处于未知状态。 你可以在构造器中为存储属性设置初始值，或是作为定义属性时的一部分设置其默认值。详情如下。 注意当你为存储属性设置默认值时，或是在构造器中设置其初始值，属性值是直接设置的，并不会调用任何属性观察器。 构造器构造器 在创建某类实例时调用。其最简单的形式用 init 关键字来写，就像一个不带参数的实例方法：123init() &#123; // 在这执行初始化设置&#125; 下面的例子定义了一个名为 Fahrenheit 的新结构体，用于保存华氏温度。Fahrenheit 结构体有一个 Double 类型的存储属性 temperature：123456789struct Fahrenheit &#123; var temperature: Double init() &#123; temperature = 32.0 &#125;&#125;var f = Fahrenheit()print("The default temperature is \(f.temperature)° Fahrenheit")// 打印 "The default temperature is 32.0° Fahrenheit" 这个结构体定义了一个没有参数的构造器 init，并将存储属性 temperature 的值初始化为 32.0 ( 水冰点的华氏温度 )。 默认属性值如上所示，你可以在构造器中设置一个存储属性的初始值。或指定一个 默认属性值 作为声明属性的一部分。指定默认属性值你可以通过在属性定义时为其赋一个初始值。 注意如果一个属性总是相同的初始值，与其在构造器中设置一个值不如提供一个默认值。其效果是相同的，但是默认值与属性构造器的联系更紧密一些。它使构造器更简短，更清晰，并且可以通过默认值推断属性类型。默认值也使你更易使用默认构造器和构造器继承，本章稍后会详细解释。 你可以通过上述为 temperature 属性提供默认值的简单形式来写结构体 Fahrenheit ：123struct Fahrenheit &#123; var temperature = 32.0&#125; 自定义构造过程如下所述，你可以通过输入参数和可选类型属性，或在构造过程中给常量属性赋值来自定义构造过程。 构造参数你可以提供 构造参数 作为构造器定义的一部分，以定义自定义构造过程中值的类型和名字。构造参数有着与函数参数和方法参数相同的功能和语法。 下面的例子定义了一个名为 Celsius 的结构体，用于存储摄氏度温度。结构体Celsius 实现了名为 init(fromFahrenheit:) 和 init(fromKelvin:) 的两个构造器，使用不同单位温度的值初始化了一个结构体实例:12345678910111213struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius is 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius is 0.0 第一个构造器有一个构造参数，其外部参数名为fromFahrenheit，内部参数名为 fahrenheit。第二个也有一个构造参数，其外部参数名为 fromKelvin，内部参数名为 kelvin。 两个构造器都将它们的参数转换为对应的摄氏温度并将其值存入名为 temperatureInCelsius 属性中。 内部参数名和外部参数名与函数和方法的参数一样，构造参数有一个在构造器中使用的内部参数名和一个调用构造器时使用的外部参数名。 不过，构造器并不像函数和方法在括号之前有一个可识别的名字。因此，构造参数的名字和类型就在识别哪一个构造器应该被调用时扮演了一个非常重要的角色。因此，如果你在构造器中没有为 每一个 参数提供外部参数名，Swift 就会自动为其提供外部参数名。 下面的例子定义了一个名为 Color 的结构体，并有名为 red，green 和 blue 三个常量。这三个属性存储了 0.0 到 1.0 之间的值，用于表示颜色中红，绿，蓝的值。 Color 提供了一个带有红，蓝，绿三个 Double 类型参数的构造器。Color 也提供了只带有 white 参数的第二个构造器，用于给三个颜色组件设置相同的值。12345678910111213struct Color &#123; let red, green, blue: Double init(red: Double, green: Double, blue: Double) &#123; self.red = red self.green = green self.blue = blue &#125; init(white: Double) &#123; red = white green = white blue = white &#125;&#125; 通过为每个构造参数传值，两个构造器都能创建一个新的 Color 实例：12let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5) 注意如果不使用外部参数名是无法调用这些构造器的。如果在构造器中定义了外部参数名就必须使用，忽略它将会触发编译错误。12let veryGreen = Color(0.0, 1.0, 0.0)// 这会报编译错误 - 必须使用外部参数名 无需外部参数名的构造参数如果你不想对构造参数使用外部参数名，写一个下划线（_）来代替显式外部参数名以重写其默认行为。 这有一个之前 构造参数 中 Celsius 例子的扩展版本，使用已经是摄氏温度的 Double 值传入额外构造器以创建一个新的 Celsius 实例：1234567891011121314struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125; init(_ celsius: Double) &#123; temperatureInCelsius = celsius &#125;&#125;let bodyTemperature = Celsius(37.0)// bodyTemperature.temperatureInCelsius is 37.0 构造器 Celsius(37.0) 有清晰的调用意图而无需外部参数名。因此将构造器写成 init(_ celsius: Double) 这种很恰当，这样就可以使用没有名字的 Double 值来调用。 可选属性类型如果你的自定义类型有一个逻辑上允许『 没有值 』存储属性 — 也许因为构造过程期间不为其赋值，或是因为它在稍后的某个时间点上被设置为『没有值』— 声明属性为 可选 类型。可选类型的属性会自动被初始化为 nil，表示属性在构造过程期间故意设置为『没有值』。 下面的例子定义了一个名为 SurveyQuestion 的类，并有一个名为 response 的可选类型其关联值类型为 String 类型的属性：1234567891011121314class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")cheeseQuestion.ask()// 打印 "Do you like cheese?"cheeseQuestion.response = "Yes, I do like cheese." 提出调查问题后，才能知道答案，所以声明 response 属性为 String? 类型，或是『 optional String』。当 SurveyQuestion 的实例被初始化时，它会自动被赋值为 nil，意味着『 还没有字符串 』。 在构造过程期间给常量赋值构造过程期间你可以在任何时间点给常量属性赋值，只要构造完成时设置了确定值即可。一旦常量属性被赋值，就不能再次修改。 注意对于类的实例来说，常量属性只能在定义常量属性类的构造器中修改。不能在派生类中修改。 你可以修改上面 SurveyQuestion 的例子，使用常量属性而不是变量属性来表示问题 text ，用于指明一旦创建了 SurveyQuestion 实例，问题就不会再次修改。即使 text 属性现在是一个常量，但你仍然可以在类的构造器中设置其值：1234567891011121314class SurveyQuestion &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let beetsQuestion = SurveyQuestion(text: "How about beets?")beetsQuestion.ask()// 打印 "How about beets?"beetsQuestion.response = "I also like beets. (But not with cheese.)" 默认构造器Swift 为属性均有默认值和没有构造器的结构体或类提供了一个 默认构造器 。默认构造器创建了一个所有属性都有默认值的新实例。 例子中定义了一个名为 ShoppingListItem 的类，并封装了购物清单中物品的名字，数量和购买状态：123456class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 因为 ShoppingListItem 类的所有属性都有默认值，而且它是一个没有父类的基类，所以 ShoppingListItem 自动获得了一个默认构造器以创建一个新的实例，并为其所有属性设置默认值。（ name 属性是一个关联值类型为 String 的可选类型，虽然代码中没有写，但它会自动接收默认值 nil。） 上面的例子使用 ShoppingListItem() 这种形式的构造语法调用默认构造器为 ShoppingListItem 类创建了一个新的实例，并将这个新的实例赋值给名为 item 的变量。 结构体类型的成员构造器如果结构体没有任何自定义构造器，那么结构体类型会自动接收一个 成员构造器。不同于默认构造器，即使结构体的存储属性没有默认值，它也会接收成员构造器。 成员构造器是初始化结构体实例所有成员属性的便捷方法。实例的属性初始值通过参数名称传给成员构造器。 下面的例子定义了一个名为 Size 的结构体并有名为 width 和 height 的两个属性。通过为属性分配一个默认值 0.0 从而推断出属性类型是 Double。 Size 结构体自动接收了成员构造器 init(width:height:)，用于初始化一个新的 Size 实例：1234struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) 值类型的构造器代理构造器可以调用其他构造器来执行实例的部分构造过程。这个过程称之为 构造器代理 ，以避免多个构造器之间的重复代码。 构造器代理的工作规则和形式规则都不同于值类型或类类型。值类型（ 结构体和枚举 ）不支持继承，所以其构造代理过程相对简单，因为他们只能代理给自己提供的其他构造器。如 继承 中所述，类是可以继承于其他类的。这意味着类有确保在构造期间将继承来的存储属性合理赋值的额外责任。这些责任稍后会在 类的继承和构造过程 中介绍。 对于值类型，在自定义构造器中使用 self.init 来引用同一类型中的其他构造器。你只能在构造器中调用 self.init。 如果你为值类型定义了一个自定义构造器，你将无法再访问该类型的默认构造器（ 如果是结构体就是成员构造器 ）。这个约束避免了一种缺陷，就是某人使用了某个自动构造器而意外绕开了一个带有额外必要设置且更复杂的构造器。 注意如果你想让你的自定义类型可以使用默认构造器，成员构造器，自定义构造器来进行初始化，就把自定义构造器写在扩展中，而不是作为值类型原始实现的一部分。更多详情，请参阅 扩展。 下面的例子定义了一个用以表示几何矩形的结构体 Rect 。这个例子需要名为 Size 和 Point 的两个辅助结构体，它们都为自己所有属性提供了一个默认值 0.0 ：123456struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125; 你可以使用以下三种方式中的任意一种来初始化结构体 Rect— 使用默认值为 0 的 origin 和 size 属性，提供指定的 origin 和 size，或是提供指定的 center 和 size。在结构体的定义中用三种自定义构造器来表示这三种构造方式：1234567891011121314struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 第一个 Rect 构造器，init()，与结构体没自定义构造器时接收的默认构造器功能相同。用一堆大括号 {} 来表示此构造器为空。调用这个构造器返回一个 Rect 实例，其 origin 和 size 属性使用属性定义时的默认值 Point(x: 0.0, y: 0.0) 和 Size(width: 0.0, height: 0.0) 来初始化：12let basicRect = Rect()// basicRect 的 origin 是（ 0.0，0.0 ），它的 size 是（ 0.0，0.0 ） 第二个 Rect 构造器，init(origin:size:)，与结构体没自定义构造器时接收的成员构造器功能相同。这个构造器只是简单的把 origin 和 size 参数值赋值给适当的存储属性：123let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))// originRect 的 origin 是（ 2.0，2.0 ），它的 size 是（ 5.0，5.0 ） 第三个 Rect 构造器，init(center:size:)，稍微有些复杂。先基于 center 和 size 的值计算了合适的原点。然后调用（ 或是代理给 ）构造器 init(origin:size:) 以在合适的属性中存储新的 origin 和 size ：123let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))// // centerRect 的 origin 是（ 2.5，2.5 ），它的 size 是（ 3.0，3.0 ） 构造器 init(center:size:) 可以把 origin 和 size的新值赋给合适的属性。然而构造器 init(center:size:) 利用已提供了相同功能的现有构造器会更方便（ 并且意图更清晰 ）。 类的继承和构造过程类的所有存储属性 — 包括任何从父类继承而来的属性 — 必须 在构造过程期间赋值。 Swift 给类类型定义了两种构造器以确保所有存储属性都能接收到初始值。它们分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器 是类的主要构造器。一个指定构造器初始化该类引入的所有属性，并调用合适的父类构造器以继续父类链上的构造过程。 类往往只有很少的指定构造器，通常一个类只有一个指定构造器。指定构造器是构造过程发生的『漏斗（funnel）』点，通过该点将构造过程持续到其父类链。 每个类至少要有一个指定构造器。如同稍后在 自动构造器的继承 中描述的那样，一些情况下，这个条件都是继承父类的一个或多个指定构造器而满足的。 其次是 便利构造器，类的辅助构造器。你可以定义便利构造器来调用同一类中的指定构造器并为指定构造器的一些参数设置默认值。你也可以定义便利构造器为特殊用例类或是输入类型类创建实例。 你应当只在你的类需要时而为其提供便利构造器。相比普通的构造模式，创建便利构造器会节省很多时间并将类的构造过程变得更加清晰。 指定构造器和便利构造器的语法类的指定构造器和值类型的简单构造器写法相同：123init(parameters) &#123; statements&#125; 便利构造器有着相同风格的写法，但是在 init 关键字之前需要放置 convenience 修饰符，并使用空格来分隔：123convenience init(parameters) &#123; statements&#125; 类的构造代理为了简化指定构造器和便利构造器之间的关系。Swift 对构造器之间的代理采用了如下三条规则： 规则 1 指定构造器必须调用其直系父类的指定构造器。 规则 2 便利构造器必须调用 同一 类中的其他构造器。 规则 3 便利构造器最后必须调用指定构造器。 简单的记忆方法： 指定构造器必须 向上 代理。 便利构造器必须 横向 代理。 下图解释了这些规则父类有一个指定构造器和两个便利构造器。一个便利构造器调用另一个便利构造器，后者又调用指定构造器。这符合上述规则 2 和规则 3。 父类本身并没有父类，所以规则 1 不适用。 该图中的派生类有两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的一个，因为它只能调用同一类中的其他构造器。这符合上述规则 2 和规则 3。两个指定构造器必须调用父类中唯一的指定构造器，所以也符合上述规则 1。 注意这些规则并不影响每个类 创建 实例。上图中的任何构造器都可以用于为其所属类创建完全初始化的实例。这些规则只会影响类的构造器实现。 下图展示了一个关于四个类之间更复杂的层级结构。它解释了这个层级结构中的指定构造器如何在类的构造过程中饰演『 漏斗（funnel）』点，并简化了构造链中类之间的关系： 两段式构造器过程Swift 中类的构造过程是两段式处理。第一阶段，为类引入的每个存储属性赋一个初始值。一旦确定了所有存储属性的初始状态，第二阶段开始，在新的实例被认为可以使用前，每个类都有机会进一步定制其存储属性。 两段式构造过程的使用让构造过程更安全，同时对于类层级结构中的每个类仍然给予完全的灵活性。两段式构造过程防止了属性在初始化前访问其值，并防止其他构造器意外给属性赋予不同的值。 注意Swift 的两段式构造过程类似于 Objective-C 的构造过程。主要区别就是在第一阶段期间，Objective-C 对每个属性赋值为 0 或空（例如 0 或 nil），Swift 的构造过程的流程就更灵活，允许设置自定义初始值，并能应付一些 0 或 nil 不能作为有效默认值的类型。 Swift 的编译器执行了四个有帮助的安全检查以确保两段式构造过程无误完成： 安全检查 1 指定构造器必须确保其类引入的所有属性在向上代理父类构造器之前完成初始化。 如上所述，一个对象的内存只在其所有存储属性初始状态已知时才被认为完全初始化。为了符合此规则，指定构造器必须确保其所属类拥有的属性在向上代理前完成初始化。 安全检查 2 指定构造器必须在继承属性赋值前向上代理父类构造器，否则，便利构造器赋予的新值将被父类构造过程的一部分重写。 安全检查 3 便利构造器必须在 任何 属性（包括同一类中定义的属性）赋值前代理另一个构造器。否则便利构造器赋予的新值将被其所属类的指定构造器重写。 安全检查 4 构造器在第一阶段构造过程完成前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。 类实例在第一阶段完成前并不是完全有效的。一旦第一阶段结束，类实例才是有效的，才能访问属性，调用方法。 以下是基于以上四个安全检查的两段式构造过程的流程： 阶段 1 在类中调用指定或便利构造器。 对一个新实例分配内存，但内存没还没有初始化。 指定构造器确认其所属类的所有存储属性都有值。现在那些存储属性的内存初始化完成。 指定构造器移交给父类构造器以为其存储属性执行相同的任务。 这个过程沿着类的继承链持续向上，直到到达继承链的顶端。 一旦到达链的顶端，并且链中最后的类确保其所有存储属性都有值，则认为实例的内存已经完全初始化，至此阶段 1 完成。 阶段 2 从链顶端往下，链中每个指定构造器都可以选择进一步定制实例，构造器现在可以访问 self 并修改它的属性，调用实例方法，等等。 最终，在链中的任何便利构造器也都可以选择定制实例以及使用 self 。 以下展示了假设的派生类和父类之间的构造过程阶段 1：在这个例子中，构造过程开始于在派生类上调用一个便利构造器。便利构造器还不能修改任何属性。它横向代理了同一类中的指定构造器。 根据安全检查 1，指定构造器确保派生类的所有属性都有值，然后在它的父类上调用指定构造器以持续链上的构造过程。 父类的指定构造器确保父类所有属性都有值。这里没有父类要初始化，所以所无需进一步代理。 一旦父类的所有属性都有了初始值，就认为其内存完全初始化，此时阶段 1 完成。 以下展示了同一构造过程 阶段 2 ：父类的指定构造器现在有机会进一步定制实例了（尽管不做也可以）。 一旦父类的指定构造器调用结束，派生类的指定构造器就可以执行额外的自定义设置（尽管这也可不做）。 最终，派生类的指定构造器调用结束，最初调用的便利构造器可执行额外的自定义设置。 构造器的继承和重写与 Objective-C 的派生类不同，Swift 的派生类默认不继承其父类构造器。Swift 这种机制防止了更定制化的派生类继承父类的简单构造器，也防止将简单构造器用于创建不完全初始化或是错误初始化的派生类实例。 注意在安全和适合的情况下，父类构造器是可以继承的。详情请参阅 自动构造器的继承 。 如果你想要自定义派生类有一个或多个与其父类相同的构造器，你可以在子类中提供这些自定义构造器的实现。 当你在写一个与父类 指定 构造器相匹配的派生类构造器时，你是在有效的重写指定构造器。因此，你必须在派生类构造器的定义前写上修饰符 override 。就像 默认构造器 中描述的那样，即使你重写的是一个自动提供的默认构造器，也要写上 override 。 重写属性，方法或是下标，修饰符 override 的存在提示着 Swift 去检查父类是否有匹配的指定构造器用于重写，并验证重写构造器的参数是否已按预期指定。 注意重写父类指定构造器时总是要写修饰符 override 的，即使你实现的是派生类的便利构造器。 相反的，如果你写一个与父类 便利 构造器相匹配的派生类构造器，根据 类的构造器代理 规则，派生类是不能直接调用父类便利构造器的。因此，你的派生类（严格来说）没有重写父类构造器。所以，在提供与父类便利构造器相匹配的实现时，无需编写 修饰符 override。 下面的例子定义了一个名为 Vehicle 的基类。这个基类声明了一个名为 numberOfWheels 的存储属性，其默认值为 Int 类型的 0。名为 description 的计算属性用 numberOfWheels 属性创建一个表示交通工具特性的 String 类型描述。123456class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return "\(numberOfWheels) wheel(s)" &#125;&#125; Vehicle 类为它仅有的存储属性提供了一个默认值，并且没有提供任何自定义构造器。因此，它自动接收了一个默认构造器，就如同 默认构造器 中描述的那样。默认构造器（在可用时）总是类中的指定构造器，并且可以用于创建一个 numberOfWheels 为 0 的新 Vehicle 实例：123let vehicle = Vehicle()print("Vehicle: \(vehicle.description)")// Vehicle: 0 wheel(s) 下面的例子定义了 Vehicle 的派生类 Bicycle：123456class Bicycle: Vehicle &#123; override init() &#123; super.init() numberOfWheels = 2 &#125;&#125; 派生类 Bicycle 定义了一个自定义构造器init()。这个指定构造器匹配于 Bicycle 父类的指定构造器，所以这个 Bicycle 版本的构造器使用修饰符 override 标记。 Bicycle 的构造器 init() 首先调用 super.init()，它调用了 Bicycle 父类 Vehicle 的默认构造器。这确保在 Bicycle 有机会修改属性前 Vehicle 完成继承属性 numberOfWheels 的初始化。调用 super.init() 后，将 numberOfWheels 的原始值替换为新值 2。 如果你创建一个 Bicycle 的实例，你可以调用它的计算继承属性 description 以查看numberOfWheels 属性是如何更新的：123let bicycle = Bicycle()print("Bicycle: \(bicycle.description)")// Bicycle: 2 wheel(s) 注意派生类可在构造过程期间可修改变量继承属性，但不能修改常量继承属性。 自动构造器的继承如上所述，派生类默认不继承其父类构造器。然而，如果满足某些特定条件，父类构造器 是 可以被自动继承的。实际上，这意味着很多常见场景中你不需要重写构造器，并且可以安全的以最小代价继承父类构造器。 假设你为派生类引入的所有属性提供了默认值，请应用以下两条规则以达到自动继承的目的： 规则 1 如果你的派生类没有定义任何指定构造器，它会自动继承其父类的所有指定构造器。 规则 2 如果你的派生类为其父类的 所有 指定构造器都提供了实现 — 无论是按照规则 1 继承而来，或是定义时提供了自定义实现 — 它都会自动继承父类的所有便利构造器。 甚至在派生类进一步添加便利构造器时，这些规则仍然适用。 注意派生类可以用便利构造器实现父类的指定构造器以作为满足规则 2 的一部分。 实践指定构造器和便利构造器下例在实践中展示了指定构造器，便利构造器和自动构造器的继承。该例定义了关于 Food，RecipeIngredient 和 ShoppingListItem 的层级关系，并演示了它们的构造器是如何相互作用的。 层级结构中的基类名为 Food，它是一个包装食品名称的简单类。Food 引入了一个名为 name 的 String 类型属性，并且提供了两个构造器以创建 Food 实例：123456789class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: "[Unnamed]") &#125;&#125; 下图展示了构造链中的 Food 类：类没有默认成员构造器，所以 Food 类提供了一个带有单个参数 name 的指定构造器。这个构造器可以使用一个指定的 name 属性值创建新的 Food 实例。12let namedMeat = Food(name: "Bacon")// namedMeat 的 name 是 "Bacon" Food 类的构造器 init(name: String) 是一个 指定 构造器，因为它确保了 Food 实例的所有存储属性被完全初始化。Food 类没有父类，所以构造器 init(name: String) 不需要调用 super.init() 完成其构造过程。 Food 类也提供了一个没有参数的 便利 构造器 init()。便利构造器 init() 横向代理 Food 类的指定构造器 init(name: String)，并为其构造参数 name 传值 [Unnamed] 以为新食物提供一个默认占位名。12let mysteryMeat = Food()// mysteryMeat 的 name 是 "[Unnamed]" 层级结构中的第二个类是 Food 的派生类 RecipeIngredient。RecipeIngredient 类模型是食谱中的一种配料。它引入了一个 Int 类型的属性 quantity（以及从父类 Food 继承而来的 name 属性）并定义了两个创建 RecipeIngredient 实例的构造器：12345678910class RecipeIngredient: Food &#123; var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125; 下面展示了构造链中的 RecipeIngredient 类：RecipeIngredient 类有一个指定构造器，init(name: String, quantity: Int)，用于填充 RecipeIngredient 实例的所有属性。该构造器首先将传递而来的构造参数 quantity 的值赋给RecipeIngredient 唯一引入的新属性 quantity。然后，构造器向上代理 Food类的构造器 init(name: String)。这个过程符合上述 两段式构造过程 中的安全检查 1。 RecipeIngredient 也定义了一个便利构造器，init(name: String)，用于单独使用 name 来创建一个 RecipeIngredient 实例。这个便利构造器假设任何 RecipeIngredient实例的 quantity 为 1，所以不需要显示指定 quantity 即可创建实例。便利构造器的定义可以更快捷，方便的创建 RecipeIngredient 实例，并在创建多个 quantity 为 1 的 RecipeIngredient 实例时避免重复代码。这个便利构造器只是简单的横向代理了类的指定构造器，并为 quantity 传值 1。 RecipeIngredient 类的便利构造器 init(name: String) 使用与 Food 类的 指定 构造器 init(name: String) 相同的参数。因为这个便利构造器就是重写了父类的指定构造器，所以必须使用修饰符 override 标记（详情请见 构造器的继承与重写）。 即使 RecipeIngredient 提供了一个便利构造器 init(name: String)，但是由于 RecipeIngredient 为父类所有指定构造器提供了实现。因此，RecipeIngredient 也自动继承了父类的所有便利构造器。 这个例子中，RecipeIngredient 的父类是 Food，它有一个便利构造器 init()。因此这个构造器由 RecipeIngredient 继承。继承版本的 init() 方法与 Food 版本的相同，除了它代理了 RecipeIngredient 版本的 init(name: String)，而不是 Food 的。 这三个构造器都可以用于创建新的 RecipeIngredient 实例：123let oneMysteryItem = RecipeIngredient()let oneBacon = RecipeIngredient(name: "Bacon")let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6) 层级结构中的第三个也是最后一个类是 RecipeIngredient 的派生类 ShoppingListItem。ShoppingListItem 类模型是购物清单中出现的一种食谱配料。 购物清单中的每项物品开始时都是『未购买状态』。为了表示这一事实，ShoppingListItem引入 Boolean 类型属性 purchased，其默认值是false。ShoppingListItem 也添加了一个计算属性 description，用于为 ShoppingListItem 实例提供文本描述：12345678class ShoppingListItem: RecipeIngredient &#123; var purchased = false var description: String &#123; var output = "\(quantity) x \(name)" output += purchased ? " ✔" : " ✘" return output &#125;&#125; 注意ShoppingListItem 没有定义为 purchased 提供初始值的构造器，因为添加到购物清单中的物品（如同模型中那样）总是未购买的。 因为它为所有属性提供了一个默认值并且没有定义任何构造器，所以ShoppingListItem 自动继承了它父类的 所有 指定构造器和便利构造器。 下图展示了三个类的整体构造链： 三个继承构造器都可以用于创建新的 ShoppingListItem 实例：1234567891011121314var breakfastList = [ ShoppingListItem(), ShoppingListItem(name: "Bacon"), ShoppingListItem(name: "Eggs", quantity: 6),]breakfastList[0].name = "Orange juice"breakfastList[0].purchased = truefor item in breakfastList &#123; print(item.description)&#125;// 1 x Orange juice ✔// 1 x Bacon ✘// 6 x Eggs ✘ 上面使用数组字面量的形式创建了一个包含三个 ShoppingListItem 实例的新数组 breakfastList。数组的类型被推断为 [ShoppingListItem]。数组创建后，数组中的第一个元素 ShoppingListItem 实例的名字从 &quot;[Unnamed]&quot; 修改为 &quot;Orange juice&quot; 并被标记为已购买。打印数组中每项物品的描述会显示它们的默认状态已按预期设置。 可失败构造器有时定义类，结构体或是枚举，构造过程可以失败是很有帮助的。无效的构造参数值可能会触发这种失败，或是缺失某种需要的外部资源，又或是未能满足某种条件。 为了应对可能失败的构造过程，你可以为类，结构体，或是枚举定义一个或是多个可失败构造器。编写可失败构造器的语法就是在 init 关键字后面添加问号（init?）。 注意你不能使用相同的参数类型或参数名定义一个可失败构造器后又定义一个非失败构造器。 可失败构造器会创建一个关联值类型是自身构造类型的 可选 类型。在可失败构造器中编写 return nil 以表示可以在任何情况下触发失败。 注意严格来说，构造器没有返回值。它们的作用是确保构造过程结束时 self 可以完全并正确的初始化。虽然你写 return nil 是用于触发构造器失败，但表示构造成功是不会使用 return 关键字的。 例如，为数字类型转换实现可失败构造器。使用构造器 init(exactly:) 以确保数字类型之间的转换可以保持精准值。如果类型转换不能保持值不变，则构造失败。 123456789101112131415let wholeNumber: Double = 12345.0let pi = 3.14159if let valueMaintained = Int(exactly: wholeNumber) &#123; print("\(wholeNumber) conversion to Int maintains value of \(valueMaintained)")&#125;// 打印 "12345.0 conversion to Int maintains value of 12345"let valueChanged = Int(exactly: pi)// valueChanged 的类型是 Int?，不是 Intif valueChanged == nil &#123; print("\(pi) conversion to Int does not maintain value")&#125;// 打印 "3.14159 conversion to Int does not maintain value" 下面的例子定义了结构体 Animal，它有一个 String 类型的常量属性 species。Animal 结构体也定义了一个只有一个构造参数 species 的可失败构造器。该构造器检查传递给构造器的 species 参数值是否为空字符串。如果是空字符串，则触发构造失败。否则，将其赋值给 species 属性，构造过程成功：1234567struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125; 你可以使用可失败构造器尝试初始化一个 Animal 实例，并且检查是否构造成功：1234567let someCreature = Animal(species: "Giraffe")// someCreature 的类型是 Animal?，不是 Animalif let giraffe = someCreature &#123; print("An animal was initialized with a species of \(giraffe.species)")&#125;// 打印 "An animal was initialized with a species of Giraffe" 如果你给可失败构造器的 species 参数传了一个空字符串，构造器就会触发构造失败：1234567let anonymousCreature = Animal(species: "")// anonymousCreature 的类型是 Animal?，不是 Animalif anonymousCreature == nil &#123; print("The anonymous creature could not be initialized")&#125;// 打印 "The anonymous creature could not be initialized" 注意检查空字符串值（例如 &quot;&quot; 而不是 &quot;Giraffe&quot;）和检查值为 nil 的关联值类型是 String 的 可选 类型是完全不同的概念。在上面的例子中，一个 String 类型的空字符串（&quot;&quot;）是有效的。然而，空字符串作为 animal 的 species 属性值明显不合适。因此要限制模型，如果是空字符串可失败构造器应该触发构造失败。 枚举的可失败构造器你可以使用可失败构造器选择基于一个或多个参数的枚举成员。如果提供的参数不符合任何一个枚举成员，则构造失败。 下例定义了枚举 TemperatureUnit，以及三种可能有的状态(kelvin，celsius 和 fahrenheit）。可失败构造器用于找到一个与代表温度符号的 Character 类型的值相符合的枚举成员：123456789101112131415enum TemperatureUnit &#123; case kelvin, celsius, fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case "K": self = .kelvin case "C": self = .celsius case "F": self = .fahrenheit default: return nil &#125; &#125;&#125; 你可以使用可失败构造器在三种可能的状态中选择一个合适的枚举成员，如果参数与三个状态中的任何一个都不匹配就会引起构造失败：1234567891011let fahrenheitUnit = TemperatureUnit(symbol: "F")if fahrenheitUnit != nil &#123; print("This is a defined temperature unit, so initialization succeeded.")&#125;// 打印 "This is a defined temperature unit, so initialization succeeded."let unknownUnit = TemperatureUnit(symbol: "X")if unknownUnit == nil &#123; print("This is not a defined temperature unit, so initialization failed.")&#125;// 打印 "This is not a defined temperature unit, so initialization failed." 带有原始值枚举的可失败构造器带原始值的枚举会自动接收一个可失败构造器 init?(rawValue:)，它有一个名为 rawValue 的参数，其类型是相应的原始值类型，如果找到了相匹配的枚举成员，就构造该枚举成员，否则构造失败。 你可以使用 Character 类型的原始值重写上例的 TemperatureUnit 以更好的利用构造器 init?(rawValue:)：123456789101112131415enum TemperatureUnit: Character &#123; case kelvin = "K", celsius = "C", fahrenheit = "F"&#125;let fahrenheitUnit = TemperatureUnit(rawValue: "F")if fahrenheitUnit != nil &#123; print("This is a defined temperature unit, so initialization succeeded.")&#125;// 打印 "This is a defined temperature unit, so initialization succeeded."let unknownUnit = TemperatureUnit(rawValue: "X")if unknownUnit == nil &#123; print("This is not a defined temperature unit, so initialization failed.")&#125;// 打印 "This is not a defined temperature unit, so initialization failed." 构造失败的传递类、结构体或枚举的可失败构造器可以横向代理同一类型中的其他可失败构造器。类似的，派生类的可失败构造器可以向上代理其父类的可失败构造器。 任意情况下，如果你代理了其他构造器而导致构造失败。整个构造过程立即失败，不再进一步执行构造代码。 注意一个可失败构造可以代理一个非失败构造器。如果你需要添加一个可能失败的状态到现有构造过程，请使用这个办法，否则将会构造失败。 下例定义了 Product 的派生类 CartItem。CartItem 类模型是一个在线购物车中的物品。CartItem 引入了一个常量存储属性 quantity 并确保这个属性值起码为 1：12345678910111213141516class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class CartItem: Product &#123; let quantity: Int init?(name: String, quantity: Int) &#123; if quantity &lt; 1 &#123; return nil &#125; self.quantity = quantity super.init(name: name) &#125;&#125; CartItem 的可失败构造器首先验证是否接收到了值为 1 或更大的 quantity。如果 quantity 是无效的，整个构造过程立即失败，构造代码不再执行。同样，Product 检查可失败构造器的 name 值，如果 name 是空字符串构造会立即失败。 如果你使用非空的 name，值为 1 或是更大值的 quantity 创建了一个 CartItem 实例，那么构造成功：1234if let twoSocks = CartItem(name: "sock", quantity: 2) &#123; print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")&#125;// 打印 "Item: sock, quantity: 2" 如果你尝试使用值为 0 的 quantity 创建一个 CartItem 实例，CartItem 构造器则会引发构造过程失败：123456if let zeroShirts = CartItem(name: "shirt", quantity: 0) &#123; print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")&#125; else &#123; print("Unable to initialize zero shirts")&#125;// 打印 "Unable to initialize zero shirts" 相似的，如果你尝试使用空 name 值去创建一个 CartItem 实例，其父类 Product 的构造器也会引发构造过程失败：123456if let oneUnnamed = CartItem(name: "", quantity: 1) &#123; print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")&#125; else &#123; print("Unable to initialize one unnamed product")&#125;// 打印 "Unable to initialize one unnamed product" 重写可失败构造器你可以在派生来中重写父类的可失败构造器，就像其他构造器那样。或是你可以用派生类的 非失败 构造器重写父类的可失败构造器。这允许你定义一个不会构造失败的派生类，即使父类的构造过程允许失败。 注意如果你使用非失败的派生类构造器重写了可失败的父类构造器，向上代理父类构造器的唯一的方法就是强制解包（force-unwrap）可失败父类构造器的结果。 注意你可以使用非失败构造器重写可失败构造器，但是反过来不行。 下例定义了一个类 Document。这个类模型是一个文档，它可以使用属性值为非空字符串或是 nil 的 name 初始化，但不能是空字符串：12345678910class Document &#123; var name: String? // 该构造器使用值为 nil 的 name 创建文档 init() &#123;&#125; // 该构造器使用非空值的 name 创建文档 init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125; 下面的例子定义了 Document 的子类 AutomaticallyNamedDocument，派生类 AutomaticallyNamedDocument 重写了继承自 Document 的两个指定构造器。如果实例没有使用 name 初始化，或是传递给构造器 init(name:) 的参数值是空字符串，重写构造器确保了 AutomaticallyNamedDocument 实例的 name 属性有一个初始值&quot;[Untitled]&quot;：1234567891011121314class AutomaticallyNamedDocument: Document &#123; override init() &#123; super.init() self.name = "[Untitled]" &#125; override init(name: String) &#123; super.init() if name.isEmpty &#123; self.name = "[Untitled]" &#125; else &#123; self.name = name &#125; &#125;&#125; AutomaticallyNamedDocument 使用非失败构造器 init(name:) 重写了父类的可失败构造器 init?(name:)。因为 AutomaticallyNamedDocument 使用与父类不同的方式处理了空字符串，所以不在需要可失败构造器，因此提供了一个非失败版本的构造器代替继承而来的可失败构造器。 作为实现派生类非失败构造器实现的一部分，你可以在构造器中强制解包以调用父类的可失败构造器。例如，下面的派生类 UntitledDocument 的 name 总是 &quot;[Untitled]&quot;，并且它在构造器期间使用了父类的可失败构造器 init(name:)。12345class UntitledDocument: Document &#123; override init() &#123; super.init(name: "[Untitled]")! &#125;&#125; 这个例子中，如果调用父类的构造器 init(name:) 时传入空字符串作为 name 的值，强制解包操作将会导致运行时错误。然而，由于它使用的是常量字符串，你可以看见构造器并不会失败，所以这个例子中也不会发生运行时错误。 init! 可失败构造器通常使用在关键字 init 后面放置问号（init?）的方式来定义一个可失败构造器，用于创建一个适当的可选类型实例。你也可以定义一个可失败构造器，将其用于创建一个适当的隐式解包可选类型的实例。为了定义这个可失败构造器，在关键字 init 后面用叹号来替代问号（init!）。 你可以从 init? 代理到 init! 反之亦然，并且可以使用 init! 重写 init? 反之亦然。你也可以从 init 代理到 init!，不过在 init! 构造失败时会触发断言。 必要构造器在类构造器的定义前写修饰符 required 以指明该类的每个派生类必须实现此构造器。12345class SomeClass &#123; required init() &#123; // 在这实现构造器 &#125;&#125; 在每个派生类实现必要构造器时也必须在构造器前面写修饰符 required，以指明构造器要求应用于继承链中所有派生类。重写一个必要指定构造器时无需写修饰符 override：12345class SomeSubclass: SomeClass &#123; required init() &#123; // 在这实现派生类的必要构造器 &#125;&#125; 注意如果派生类符合继承构造器的要求，则无需在派生类中为必要构造器提供显式实现。 使用闭包或函数设置默认属性值如果一个存储属性的默认值需要某些自定义或设置，你可以使用闭包或是全局函数为该属性提供自定义默认值。每当该属性所属类型的新实例被初始化时，闭包或函数就会被调用，其返回值就会作为该属性的默认值。 这种函数或闭包通常会创建一个与属性类型相同类型的临时值，为满足预期的初始状态而处理其值，然后返回该临时值作为属性的默认值。 以下是如何使用闭包作为属性默认值的大致轮廓：1234567class SomeClass &#123; let someProperty: SomeType = &#123; // 在闭包中创建一个带有默认值的 someProperty // someValue 的类型必须是 SomeType return someValue &#125;()&#125; 注意那个闭包的结束是在大括号后面尾随一对空括号。这告诉 Swift 立即执行闭包。如果你忽略了这对括号，则为试图将闭包本身赋值给属性，而不是闭包的返回值。 注意如果你使用闭包初始化属性，记住在闭包执行时其他实例还未初始化。这意味着无法在闭包中访问其他属性值，即使那些属性有默认值。你也不能隐式使用 self 属性，或是调用实例方法。 下例定义了一个结构体 Chessboard，其模型是国际象棋的棋盘。国际象棋是 8 x 8 黑白格交替的棋盘。为了表示这个棋盘，结构体 Chessboard 有一个属性 boardColors，它是一个存储 64 个 Bool 类型值的数组。在数组中，值为 true 代表黑格，值为 false 代表白格。数组中的第一个值表示棋盘左上角的格子，数组中最后一个元素代表棋盘右下角的格子。 使用闭包设置颜色值并初始化数组 boardColors：1234567891011121314151617struct Chessboard &#123; let boardColors: [Bool] = &#123; var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 &#123; for j in 1...8 &#123; temporaryBoard.append(isBlack) isBlack = !isBlack &#125; isBlack = !isBlack &#125; return temporaryBoard &#125;() func squareIsBlackAt(row: Int, column: Int) -&gt; Bool &#123; return boardColors[(row * 8) + column] &#125;&#125; 每当一个新的 Chessboard 实例创建时，都会执行闭包，并且会返回已计算的 boardColors 默认值。上例中的闭包为棋盘上的每一格计算合适的颜色并将其值保存在临时数组 temporaryBoard 中，一旦完成设置就将 temporary 数组作为闭包的返回值返回。返回的数组保存在 boardColors 中并可以使用效用函数 squareIsBlackAt(row:column:) 查询：12345let board = Chessboard()print(board.squareIsBlackAt(row: 0, column: 1))// 打印 "true"print(board.squareIsBlackAt(row: 7, column: 7))// 打印 "false"]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>构造过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 继承]]></title>
    <url>%2F2018%2F10%2F17%2FSwift%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一个类可以 继承 另一个类的方法，属性以及其他特性。当一个类继承另一个类时，继承类称为 子类，被继承类称为 父类。在 Swift 中，继承是类类型区别于其他类型的基本特性。Swift 中的子类可以调用和访问父类的方法，属性和下标，还可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会通过检查重写的定义和父类的定义是否匹配来帮助确保重写是正确的。 子类还可以给继承的属性添加属性观察器，以便在属性值发生变化时得到通知。属性观察器可以被添加到任何属性，不管它原始定义是储存属性还是计算属性 定义一个基类不继承任何类的类被称为 基类 。 注意Swift 中的类并不继承自一个统一的类。定义类时如果不指定父类那么该类自动成为基类。 下面的代码样例定义了一个基类 Vehicle。这个基类定义了一个存储属性 currentSpeed，其默认值为 0.0（推断该属性类型为 Double ）。和一个只读的 String 类型的计算属性 description，description 使用 currentSpeed 的值来创建车辆的描述。 基类 Vehicle 还定义了一个空方法 makeNoise。这个方法之后会被 Vehicle 的子类重写：123456789class Vehicle &#123; var currentSpeed = 0.0 var description: String &#123; return "traveling at \(currentSpeed) miles per hour" &#125; func makeNoise() &#123; // 空方法，不是所有车辆都发出噪音 &#125;&#125; 你可以使用 初始化语法 来创建一个 Vehicle 的实例，用类型名并紧跟小括号来表示：1let someVehicle = Vehicle() 你可以访问已经创建的 Vehicle 实例的 description 属性来打印人类可读的车辆当前速度的描述：12print("Vehicle: \(someVehicle.description)")// Vehicle: traveling at 0.0 miles per hour Vehicle 类定义了车辆共有的特性，但其本身并没有太大作用。为了使其更加有用，你需要优化它来描述更具体的车辆类型。 子类化子类化 是在已有类的基础上创建新类的行为。 子类可以继承父类的特性，然后对其进行更改。你还可以为子类添加新的特性。 为了表示一个类拥有父类，声明子类时要在后面写上父类的类名，使用冒号分割：123class SomeSubclass: SomeSuperclass &#123; // 子类在这里定义&#125; 下面的例子中定义了一个叫 Bicycle 的类，它继承于父类 Vehicle ：123class Bicycle: Vehicle &#123; var hasBasket = false&#125; 这个新的类 Bicycle 会自动获取 Vehicle 类的所有特性，如 currentSpeed 、 description 属性和它的方法 makeNoise() 。 除了继承的特性外， Bicycle 类中还定义了一个新的存储属性 hasBasket ，它的初始值是 false （ 推断出该属性为 Bool 类型 ). 默认情况下，你新创建的任何 Bicycle 实例（自行车）都没有basket（篮子）。 Bicycle 实例创建之后，你可以将 hasBasket 属性修改为 true 来表示是否有 basket ：12let bicycle = Bicycle()bicycle.hasBasket = true 你也可以修改 Bicycle 实例继承的 currentSpeed 属性，还可以查询继承的 description 属性：123bicycle.currentSpeed = 15.0print("Bicycle: \(bicycle.description)")// Bicycle: traveling at 15.0 miles per hour 子类本身也是可以被继承的，下面的例子为 Bicycle 创建了一个名为「tandem」的双座自行车子类：123class Tandem: Bicycle &#123; var currentNumberOfPassengers = 0&#125; Tandem 类继承了 Bicycle 类中所有的属性和方法，同时 Bicycle 类继承了 Vehicle 类中所有的属性和方法。Tandem 类还添加了一个新的存储属性 currentNumberOfPassengers，初始值为 0 。 如果你创建了一个 Tandem 类的实例， 则可以使用任何新创建的属性和继承的属性， 还可以查询从 Vehicle 类继承的只读属性 description ：123456let tandem = Tandem()tandem.hasBasket = truetandem.currentNumberOfPassengers = 2tandem.currentSpeed = 22.0print("Tandem: \(tandem.description)")// Tandem: traveling at 22.0 miles per hour 重写一个子类可以对实例方法、类方法、实例属性、类属性或下标进行自定义实现，如果没有自定义则会从超类继承，这就是所谓的 重写 。 重写从父类继承的特性，你需要在定义重写时添加 override 前缀。这表明你打算重写一个特性并且没有使用错误的匹配定义。意外的重写会导致不可预料的行为，且任何没有使用 override 关键词修饰的重写声明在编译代码时会被标记为错误。 override 关键词也提醒 Swift 编译器去检查你重写的这个类的超类（或它的某个父类）是否有匹配重写版本的声明。这个检查确保你的重写定义是正确无误的。 访问父类的方法、属性和下标当你在子类中重写方法、属性或下标时，有时把父类的实现作为重写的一部分是很有用的。例如，你可以优化现有的实现，或将修改后的值存储在现有的继承变量中。 在适当的情况下，应该用 super 前缀访问父类的方法、属性或下标： 一个名为 someMethod() 的重写方法可以在实现中通过 super.someMethod() 来调用父类的 someMethod() 方法。一个名为 someProperty 的属性可以在重写 getter 或 setter 的实现中通过 super.someProperty 访问父类的 someProperty 属性。一个 someIndex 的重写下标可以在重写下标的实现中通过 super[someIndex] 访问父类的相同下标。 重写方法你可以通过在子类中重写继承的实例或类型方法来对方法的实现进行修改。 下面的例子定义了一个 Vehicle 的新子类 Train，在 Train 中重写了继承自 Vehicle 的 makeNoise() 方法：12345class Train: Vehicle &#123; override func makeNoise() &#123; print("Choo Choo") &#125;&#125; 如果你创建一个 Train 的新实例并调用它的 makeNoise() 方法，你可以看到调用的是子类 Train 中的该方法：123let train = Train()train.makeNoise()// 输出 "Choo Choo" 重写属性可以重写继承的实例或类型属性，以便为该属性提供自己定义的 getter 和 setter，或给重写的属性添加属性观察器观测先前属性值的改变。 重写属性的 Getters 和 Setters无论继承的属性原来是存储属性还是计算属性，都可以提供自定义的 getter（如果 setter 适用，也包括 setter）来重写任何继承属性。子类不知道继承的属性是存储属性还是计算属性，子类只知道继承的属性具有特定的名称和类型。你必须始终声明要重写的属性的名称和类型，以使编译器能够检查你重写的属性是否与具有相同名称和类型的父类属性匹配。 通过在子类属性中重写 getter 和 setter，可以将继承的只读属性重写为读写属性，但是，你不能将继承的读写属性重写为只读属性。 注意如果你重写属性的 setter 就必须同时重写属性的 getter。如果你不想在重写 getter 中修改继承属性的值，你可以简单地在 getter 中返回 super.someProperty，其中 someProperty 是你想要重写的属性名称。 下面的例子中定义了一个新的类 Car ，它是 Vehicle 的子类。Car 类声明了一个存储属性 gear，默认值为 1 。Car 还重写了从 Vehicle 中继承的 description 属性，用来提供包括当前档位的自定义描述：123456class Car: Vehicle &#123; var gear = 1 override var description: String &#123; return super.description + " in gear \(gear)" &#125;&#125; 重写的 description 属性首先调用了 super.description ，它返回的是 Vehicle 类中的 description 属性。然后， Car 类中重写的 description 版本在末尾添加了一些额外的文本，用来描述当前的档位： 如果你创建了一个 Car 类的实例并且设置了 gear 和 currentSpeed 属性，你就能看到它的 description 属性返回了 Car 类中重写过的描述：12345let car = Car()car.currentSpeed = 25.0car.gear = 3print("Car: \(car.description)")// Car: traveling at 25.0 miles per hour in gear 3 重写属性观察者你可以用属性重写特性给一个继承属性增加属性观察者。 无论这个属性的初始值是多少，当它的值改变时你将会收到通知。 注意你不能给常量存储属性或只读属性增加属性观察者。 因为这些属性值不能被修改，所以它是不能提供 willSet 或 didSet 的重写实现。当然，你不能为同一个属性同时提供 setter 重写和 didSet 观察者。 如果你想观察这个属性值的改变，并且你已经为这个属性提供了一个重写的 setter 方法，那么你能在这个自定义 setter 方法里观察到它任何值的改变。 下面定义了一个叫 AutomaticCar 的新类， 它是 Car 的子类。AutomaticCar 表示一个能自动变速的汽车类，它能基于当前速度自动选择一个合适的档位：1234567class AutomaticCar: Car &#123; override var currentSpeed: Double &#123; didSet &#123; gear = Int(currentSpeed / 10.0) + 1 &#125; &#125;&#125; 当你更改 AutomaticCar 实例的 currentSpeed 属性值时，这个属性的 didSet 观察者将会观察到值的改变并根据新速度给 gear 属性设置一个合适的档位。按照换算规则，档位是新 currentSpeed 值除以 10 后四舍五入取整再 + 1 的值。 例如，速度 35.0 将代表 4 档位：1234let automatic = AutomaticCar()automatic.currentSpeed = 35.0print("AutomaticCar: \(automatic.description)")// 自动汽车： 当前行驶的速度是 35.0 mph， 档位为 4 防止重写你可以通过标记方法、属性或下标为 final 来防止它被重写。通过在方法、属性或下标前添加关键字 final （比如 final var、 final func、 final class func 和 final subscript）来完成此操作。 任何重写子类中的 final 方法、属性或下标的尝试都会在编译时报错。添加到类扩展中的方法、属性或下标页可以在扩展中标记为 final。 你可以通过在类的定义中 class 关键字前添加 final 修饰符将整个类标记为 final，比如 final class。任何对标记为 final 的类进行继承的子类都会在编译时报错。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 下标]]></title>
    <url>%2F2018%2F10%2F16%2FSwift%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[类、结构体和枚举可以定义 下标 ，它是用于访问集合，列表或序列的成员元素的快捷方式。 你可以直接使用下标来对值进行读写，而无需设置单独的读写方法。 例如，你可以将 Array 实例中的元素作为 someArray [index] 访问，将 Dictionary 实例中的元素作为 someDictionary [key] 访问。 你可以为单个类型定义多个下标，并根据传递给下标的索引值的类型，选择要使用的相应下标进行重载。 下标不限于单个维度，你可以定义具有多个输入参数的下标以满足你自定义类型的需求。 下标语法使用下标, 让你可以通过在实例名称后面的方括号中写入一个或多个值来查询类的实例。它们的语法类似于实例方法和计算属性语法。使用 subscript 关键字定义下标，并且和实例方法类似，可以指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或只读。和计算属性类似, 读写是由 getter 和 setter 方法实现的：12345678subscript(index: Int) -&gt; Int &#123; get &#123; // 在这里返回一个对应下标的值 &#125; set(newValue) &#123; // 在这里执行对应的赋值操作 &#125;&#125; newValue 的类型与下标的返回值相同。与计算属性一样，你可以选择不指定 setter 的 (newValue) 参数。但是如果你没有指定参数，那么 newValue 会成为你 setter 的默认参数。 与只读计算属性一样，你可以通过删除 get 关键字以及大括号来简化只读下标的声明：123subscript(index: Int) -&gt; Int &#123; // 在这里返回一个对应下标的值&#125; 这是一个只读下标实现的例子，它定义了一个 TimesTable 结构体来表示一个 n 倍整数表：123456789struct TimesTable &#123; let multiplier: Int subscript(index: Int) -&gt; Int &#123; return multiplier * index &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print("six times three is \(threeTimesTable[6])")// 输出 "six times three is 18" 在这个例子中，创建了一个新的 TimesTable 实例来表示三倍表。通过将值 3 作为实例的 multiplier 参数值来初始化结构体。 你能够通过下标来调用 threeTimesTable 实例，比如调用 threeTimesTable[6]。这请求了三倍表中的第六项，返回 18 ，也就是 6 的 3 倍。 注意n 倍表是基于固定的数学规则定义的。给 threeTimesTable[someIndex] 赋新值是不合适的，因此 TimesTable 的下标倍定义为只读下标。 下标的用法下标的准确含义依赖于使用它的上下文。下标通常被用来作为访问集合、列表或序列中的元素的快捷方式。你可以用最合适的方式来为你的特定类或结构体函数实现下标。 例如，Swift 中的 Dictionary 类型实现了一个下标来设置和检索存储在 Dictionary 实例中的值。你可以通过在下标括号中提供一个符合字典键类型的键来设置字典的值，并且把符合字典值类型的值赋给下标：12var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]numberOfLegs["bird"] = 2 上面的例子定义了一个名为 numberOfLegs 的变量并使用含有三个键值对的字典初始化它。字典 numberOfLegs 的类型被推断为 [String: Int]。创建字典后，通过下标将一个 String 类型的键 「bird」 和一个 Int 类型的值 2 添加到了字典。 注意Swift 的 Dictionary 类型将其键值作为下标实现并返回一个可选类型。对于上面的 numberOfLegs 字典，键值下标存取的值类型为 Int?，表示「可选的整数」。Dictionary 类型用可选的下标类型来模拟不是每个键都有值的事实，可以通过为该键指定一个 nil 值来删除该键值。 下标选项下标可以设置任意数量的输入参数，这些输入参数也可以是任意类型。 同时，下标也可以返回任何类型。 下标可以使用可变参数，但它们不能使用输入输出参数或是提供默认参数值。 类或结构体可以提供尽可能多的下标实现，并且能够基于当前下标括号内的值或者值的类型来推断合适的下标。定义多个下标被称为下标重载。 虽然下标采用单参数是最常见的，但在合适的情况下也可以定义带多个参数的下标。下面的例子定义了一个 Matrix 结构体，这个结构体表示一个类型为 Double 的二维矩阵。Matrix 结构体的下标有两个整型参数：12345678910111213141516171819202122struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) &#125; func indexIsValid(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValid(row: row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValid(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125; Matrix 提供了一个带有两个名为 rows 和 columns 参数的构造器，并构造一个足够大的数组来存储 Double 类型的 rows * columns 值。矩阵中的每个值初始化为 0.0 。为实现此目的，把数组的大小和初始单元格值 0.0 传递给数组构造器，该构造器会构造并初始化一个正确大小的新数组。 你可以通过传递合适的行数和列数给构造器来构造新的 Matrix 实例：1var matrix = Matrix(rows: 2, columns: 2) 上面的示例创建了一个新的带有两行两列的 Matrix 实例。Matrix 实例的 grid 数组实际上是矩阵从左上角到右下角的展开：可以通过传递行和列的值到下标来给矩阵赋值，行和列用逗号隔开：12matrix[0, 1] = 1.5matrix[1, 0] = 3.2 这两行代码调用下标的 setter 方法给矩阵的右上角（row 为 0 且 column 为 1）赋值 1.5 和左下角（row 为 1 且 column 为 0）赋值 3.2。Matrix 下标的 getter 方法和 setter 方法都包含一个断言来检查下标的 row 和 column 是否有效。为了辅助这些断言，Matrix 包含一个名为 indexIsValid(row:column:) 的便捷方法，该方法检查请求的 row 和 column 是否超出矩阵的边界：123func indexIsValid(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns&#125; 如果尝试访问矩阵边距之外的下标就会触发断言：12let someValue = matrix[2, 2]// 这里触发了断言，因为下标 [2, 2] 超出了矩阵的边界]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 方法]]></title>
    <url>%2F2018%2F10%2F15%2FSwift%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法 是与特定类型相关联的函数。类、结构体和枚举都可以定义实例方法，这些方法会封装特定的任务和功能用于处理给定类型的实例。类、结构体和枚举还可以定义类型方法。类型方法类似于 Objective-C 中的类方法。 可以在结构体和枚举中定义方法，是 Swift 与 C 和 Objective-C 的主要区别。在 Objective-C 中，类是唯一可以定义方法的类型。但在 Swift 中，由于类、结构体和枚举都支持定义方法，所以在选择定义类型时你有更多的选择。 实例方法实例方法 是属于特定类、结构或枚举实例的函数。它们的功能是提供访问和修改实例属性的方法，或提供与实例目的相关的功能。实例方法与函数具有完全相同的语法，如 函数 中所述。 你在其所属类型的开始和结束括号内编写实例方法。实例方法可以隐式访问该类型的所有其它实例方法和属性。实例方法只能被它所属类型的实例调用。如果没有实例，不能单独调用它。 下面是一个简单 Counter 类的示例，可用于计算操作发生的次数：123456789101112class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func increment(by amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125; Counter 类中定义了三个实例方法 increment() 将计数器增加 1 。increment(by: Int) 将计数器增加指定的值。reset() 将计数器重置为 0。 Counter 类中还声明了一个可变的属性 count ，用来记录计数器当前的值。 和调用属性一样，你可以使用点语法来调用实例方法：12345678let counter = Counter()// 计数器初始值为 0counter.increment()// 计数器的值现在为 1counter.increment(by: 5)// 计数器的值现在为 6counter.reset()// 计数器的值现在为 0 方法的参数可以同时拥有一个参数名称（在方法内使用）和一个参数标签（在调用方法时使用），和 函数的参数标签和参数名 中描述的一样。方法的参数也是如此，因为方法也是函数只不过它和类相关联。 self 属性类型的每个实例都有一个名为 self 的隐式属性，它与实例本身完全等效。你可以使用 self 属性来调用自己的实例方法。 上面例子中的 increment() 方法也可以这样实现的：123func increment() &#123; self.count += 1&#125; 实际上，你并不需要经常在代码中书写 self 。如果没有显式地书写 self ，那么只要在方法中使用了该类的属性或方法名称，Swift 就会假定你调用了当前实例的属性或方法。在 Counter 的三个实例方法中使用 count （而不是 self.count ）证明了这个假设。 当实例方法的参数名称与该实例的属性名称相同时，这时候就会发生命名冲突问题。在这种情况下，会使用参数名称优先原则，这时候你就需要以更严格的方式调用属性。即你需要用书写 self 的方式来调用属性以区分参数名称和属性名称。 这里， self 消除了一个名为 x 的方法参数和一个也被称为 x 的实例属性之间名称相同的歧义：1234567891011struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOf(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;let somePoint = Point(x: 4.0, y: 5.0)if somePoint.isToTheRightOf(x: 1.0) &#123; print("This point is to the right of the line where x == 1.0")&#125;// 打印 "This point is to the right of the line where x == 1.0" 如果没有 self 前缀，Swift 会假设 x 的两个用法都调用了名为 x 的方法参数。 在实例方法中修改值类型结构体和枚举是 值类型 。默认情况下，无法在其实例方法中修改值类型的属性。 但是，如果需要在特定方法中修改结构体或枚举的属性，可以选择将这个方法 异变 。然后，该方法就可以异变（即更改）其属性，并且当方法结束时，它所做的任何更改都将写回原始的结构体中。该方法还可以为隐式的 self 属性分配一个全新的实例，并且该新实例将在方法结束时替换现有实例。 你可以通过在方法的 func 关键字前放置 mutating 关键字来选择开启此行为：1234567891011struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y: 1.0)somePoint.moveBy(x: 2.0, y: 3.0)print("The point is now at (\(somePoint.x), \(somePoint.y))")// 打印 "The point is now at (3.0, 4.0)" 上面的 Point 结构体定义了一个异变方法 moveBy(x:y:) ，它会基于特定的数值移动 Point 实例。此方法实际上修改了调用它的那个点，而不是返回一个新点。 mutating 关键字被添加到其定义中，以使其能够修改其属性。 请注意，你不能在常量结构体类型上调用异变方法，因为它的属性不能更改，即使它们是变量属性，如 常量结构体实例的存储属性 中所述：123let fixedPoint = Point(x: 3.0, y: 3.0)fixedPoint.moveBy(x: 2.0, y: 3.0)// 编译器会报错 在可变方法中给 self 赋值可变方法能给隐性的 self 属性赋以一个全新的实例。上面以 Point 为例的代码也可以用下面这种方式来实现：123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; self = Point(x: x + deltaX, y: y + deltaY) &#125;&#125; 这个版本的可变方法 moveBy(x:y:) 创建了一个新的结构体，且该结构体的 x 与 y 值都被设定为目标位置。调用这个可变版本的方法与上个版本的方法最终结果一样。 枚举的可变方法可以将隐性的 self 参数设置成同一枚举类型中的不同成员。123456789101112131415161718enum TriStateSwitch &#123; case off, low, high mutating func next() &#123; switch self &#123; case .off: self = .low case .low: self = .high case .high: self = .off &#125; &#125;&#125;var ovenLight = TriStateSwitch.lowovenLight.next()// ovenLight 现在等于 .highovenLight.next()// ovenLight 现在等于 .off 在这个例子中，我们定义了一个枚举，它拥有三种状态的开关。当 next() 方法被调用时，这个开关将在三种不同的电源状态（off，low 和 high）之间循环切换。 类型方法就像上面所描述的，实例方法是在类型的实例上被调用的方法。你也可以直接在类型本身上定义方法，这样的方法被称作 类型方法 。为了明确一个方法是类型方法，你可以在这个方法的 func 关键词前加上 static 关键词。在类中，也可以使用 class 关键词来声明一个类型方法。与 static 关键词不同的是，用 class 关键词声明的类型方法允许它的子类重写其父类对类型方法的实现。 注意在 Objective-C 中，你只能为 Objective-C 的类定义类型方法。而在 Swift 中，你可以为所有的类、结构体或枚举定义类型方法。每一个类型方法可被调用的作用域都被其所支持的类型明确划分。 就像实例方法那样，类型方法可以通过点语法来调用。不同的是，你将直接在类上调用类型方法，而不是在类型的实例上调用。你可以像下面这样在一个被叫做 SomeClass 的类上调用其类型方法：123456class SomeClass &#123; class func someTypeMethod() &#123; // 这里是类型方法的实现细节 &#125;&#125;SomeClass.someTypeMethod() 在一个方法的函数体中，隐性属性 self 指代其类型本身，而非指代类型的实例。就像你对实例属性与实例方法的参数之间做的那样，这意味着你可以使用 self 来消除类属性与类型方法的参数之间的歧义。 一般来说，你在类型方法函数体内使用的任何非完全标准的方法和属性名称将会引用对应的类型级别的方法和属性。类型方法可以直接使用方法的名称来调用另一个类型方法，而无需使用类型名称作为前缀。同样的，结构体和枚举上的类型方法可以通过使用不带类型名称前缀的类型属性名称来访问该类型属性。 下面的示例定义了一个名为 LevelTracker 的结构体，它用来追踪玩家在游戏的不同级别或阶段的进度。这是一款单人游戏，但可以在一台设备上存储多个玩家的信息。 首次玩游戏时，所有的游戏等级（除了第一级）都会被锁定。每当玩家完成一个等级时，该等级就会被设备上的所有玩家解锁。 LevelTracker 结构体使用类型属性和方法来追踪游戏的哪些级别已被解锁。它还追踪单个玩家的当前级别。12345678910111213141516171819202122struct LevelTracker &#123; static var highestUnlockedLevel = 1 var currentLevel = 1 static func unlock(_ level: Int) &#123; if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125; &#125; static func isUnlocked(_ level: Int) -&gt; Bool &#123; return level &lt;= highestUnlockedLevel &#125; @discardableResult mutating func advance(to level: Int) -&gt; Bool &#123; if LevelTracker.isUnlocked(level) &#123; currentLevel = level return true &#125; else &#123; return false &#125; &#125;&#125; LevelTracker 结构体追踪任何玩家解锁的最高级别。该值存储在名为 highestUnlockedLevel 的类型属性中。 LevelTracker 还定义了两个类型函数来处理 highestUnlockedLevel 属性。第一个是名为 unlock(_:) 的类型函数，每当解锁一个新级别时它会更新 highestUnlockedLevel 的值。第二个是一个名为 isUnlocked(_:) 的便捷类型函数，如果某个特定的级别号已被解锁，则返回 true 。（请注意，这些类型方法可以直接使用 highestUnlockedLevel 类型属性，而无需将其写为 LevelTracker.highestUnlockedLevel 。） 除了类型属性和类型方法之外，LevelTracker 还追踪单个玩家在游戏中的进度。它使用一个名为 currentLevel 的实例属性来跟踪玩家当前的游戏等级。 为了帮助管理 currentLevel 属性， LevelTracker 定义了一个名为 advance(to:) 的实例方法。在更新 currentLevel 之前，此方法先检查所请求的新级别是否已解锁。 advance(to:) 方法返回一个布尔值，表示它是否实际上能够设置 currentLevel 。因为调用 advance(to:) 方法时我们有时候可能会需要忽略返回值，所以这个函数用 @ discardableResult 特性标记。 @ discardableResult表示取消不使用返回值的警告 LevelTracker 结构体与 Player 类一起使用，如下所示，用于追踪和更新单个玩家的进度：1234567891011class Player &#123; var tracker = LevelTracker() let playerName: String func complete(level: Int) &#123; LevelTracker.unlock(level + 1) tracker.advance(to: level + 1) &#125; init(name: String) &#123; playerName = name &#125;&#125; Player 类创建一个 LevelTracker 实例来跟追踪该玩家的进度。它还提供了一个名为 complete(level:) 的方法，只要玩家完成特定级别就会调用它。此方法会为所有玩家解锁下一关，并更新当前玩家的进度到下一关。（忽略 advance(to:) 的布尔性返回值，是因为已经知道通过调用前一行的 LevelTracker.unlock(_:) 来解锁该级别。） 你可以为新玩家创建一个 Player 类的实例，看看当玩家完成第一级时会发生什么：1234var player = Player(name: "Argyrios")player.complete(level: 1)print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")// 打印 "highest unlocked level is now 2" 如果你创建了第二个玩家，并尝试将其移动到游戏中任何玩家都尚未解锁的等级，则设置玩家当前等级的尝试会失败：1234567player = Player(name: "Beto")if player.tracker.advance(to: 6) &#123; print("player is now on level 6")&#125; else &#123; print("level 6 has not yet been unlocked")&#125;// 打印 "level 6 has not yet been unlocked"]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 属性]]></title>
    <url>%2F2018%2F10%2F14%2FSwift%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[属性 可以将值与特定类、结构体或者枚举类型相关联。存储属性将常量和变量值存储为实例的一部分，而计算属性则是通过计算得到一个值（而不是存储值）。计算属性适用于类、结构体和枚举类型，而存储属性只适用于类和结构体类型。 存储和计算属性通常都与特定类型的实例相关联。但是，属性也可以与类型本身相关联，这种属性称为类型属性。 此外，你还可以定义属性观察器以监视属性值的更改，并使用自定义的操作对其进行响应。你既可以将属性观察器添加到自己定义的存储属性中，也可以添加到从父类继承来的属性中。 存储属性简单来说，存储属性是一个存储在特定的类或结构体中的常量或变量。存储属性可以是 变量存储属性 （由 var 关键字定义）或 常量存储属性 （由 let 关键字定义）。 你可以为存储属性提供默认值作为其定义的一部分，如 默认属性值 中所述。你还可以在初始化期间设置和修改存储属性的初始值。即使对于常量存储属性也是如此，如 在初始化期间给常量属性赋值 中所述。 下面的示例定义了一个名为 FixedLengthRange 的结构体，该结构体描述了一个整数范围，其范围长度在创建后无法更改：12345678struct FixedLengthRange &#123; var firstValue: Int let length: Int&#125;var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// 该整数范围表示整数值 0、1 和 2rangeOfThreeItems.firstValue = 6// 该整数范围现在表示整数值 6、7 和 8 FixedLengthRange 的实例有一个名为 firstValue 的变量存储属性和一个名为 length 的常量存储属性。在上面的示例中，length 在创建新实例时被初始化，之后无法更改，因为它是常量属性。 常量结构体实例的存储属性如果创建结构体实例并将该实例声明为常量，则无法修改实例的属性，即使它们被声明为变量属性：1234let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// 此整数范围表示整数值 0、1、2 和 3rangeOfFourItems.firstValue = 6// 这行代码会报错，即使 firstValue 是一个变量属性 因为 rangeOfFourItems 被声明为常量（使用 let 关键字），所以即使 firstValue 是一个变量属性，也不可以改变它的值。 这种行为是由于结构体是 值类型 。当值类型的实例声明为常量时，其所有属性也都会被标记为常量。 类的行为却并非如此，这是因为类是 引用类型 。如果将引用类型的实例声明为常量时，你仍可以修改该实例的变量属性。 延迟存储属性延迟存储属性 的初始值直到第一次使用时才进行计算。你可以通过在其声明之前标注 lazy 修饰符来表示一个延迟存储属性。 注释你必须始终将延迟属性声明为变量（使用 var 关键字），因为延迟属性的初始值可能在实例初始化完成之后，仍然没有被赋值。而常量属性必须在实例初始化完成 之前 就获得一个值，因此不能声明为延迟。 当属性的初始值依赖于外部因素时，延迟属性就非常有用了，因为这些外部因素的值可能在实例初始化完成之后才知道。当属性的初始值需要执行复杂或代价高昂的计算时，你应该只在需要的时候才执行，这时候延迟属性也很有用。 下面的示例，使用延迟存储属性来避免复杂类的不必要的初始化。这个例子定义了两个名为 DataImporter 和 DataManager 的类，它们的代码都没有全部列出：12345678910111213141516171819class DataImporter &#123; /* DataImporter 是一个从外部文件导入数据的类。 假设该类需要花费大量时间来初始化。 */ var filename = "data.txt" // DataImporter 类将在此处提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // DataManager 类将在此处提供数据管理功能&#125;let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data")// 类型为 DataImporter 的 importer 属性实例尚未创建 DataManager 类有一个名为 data 的存储属性，它使用一个空的 String 数组进行初始化。尽管它的其余功能没有展示出来，但我们仍然可以猜到这个 DataManager 类的目的是管理并提供访问 String 数组的方法。 DataManager 类同时还具有从文件导入数据的功能。这个功能由 DataImporter 类提供，我们同时假定初始化 DataImporter 类需要大量时间。这可能是因为初始化 DataImporter 实例时，需要打开文件并将其内容读入内存。 因为 DataManager 实例管理数据的功能，并不依赖从文件导入数据的功能，因此在创建 DataManager 实例时，我们不应该立刻创建 DataImporter 实例。相反，在 DataImporter 第一次被使用时再创建它才更有意义。 因为 importer 属性被 lazy 修饰符所标记，因此它在第一次被访问时 DataImporter 实例才会被创建，例如当查询其 filename 属性时：123print(manager.importer.filename)// 现在 DataImporter 的实例 importer 已经被创建了// 打印 "data.txt" 注释如果被 lazy 修饰符所标记的属性，同时被多个线程访问，并且该属性尚未被初始化，则无法保证该属性仅被初始化一次。 存储属性和实例变量如果你有使用 Objective-C 的经验，你可能知道它提供了 两种 方法来存储值和引用。除了属性之外，你还可以使用实例变量来作为属性的底层存储。 Swift 将这些概念统一到一个属性声明中。Swift 属性没有相应的实例变量，并且属性的底层存储不能被直接访问。这种方式避免了在不同的上下文中如何访问值的混淆，并将属性的声明简化为单个明确的语句。有关属性的所有信息（包括其名称、类型和内存管理特征）都在单个位置定义，作为类型定义的一部分。 计算属性除了存储属性之外，类、结构体和枚举还可以定义 计算属性 ，它们实际上并不存储值。相反，它们会提供了一个 getter 方法和一个可选的 setter 方法来间接读取和设置其他属性和值。123456789101112131415161718192021222324252627struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print("square.origin is now at (\(square.origin.x), \(square.origin.y))")// 打印 "square.origin is now at (10.0, 10.0)" 此示例定义了三种用于处理几何形状的结构体： Point 封装了一个点的 x 坐标和 y 坐标。 Size 封装了 width 和 height 。 Rect 用原点和大小定义一个矩形。 Rect 结构体还提供了一个名为 center 的计算属性。Rect 的当前中心位置始终可以从其 origin 和 size 来唯一确定，因此你并不需要将中心点存储为一个 Point 类型的存储属性。相反，我们应该在 Rect 中定义一个名为 center 的计算变量，并自定义它的 getter 和 setter 方法，这样我们就可以使用矩形的 center 属性，就像它是一个真正的存储属性一样。 上面的例子创建了一个名为 square 的 Rect 变量。 square 变量原点初始化为 (0, 0)，宽度和高度初始化为 10。该正方形由下图中的蓝色方块表示。 然后通过点语法（ square.center ）访问 square 变量的 center 属性，这会导致调用 center 的 getter 方法来读取当前属性值。 Getter 方法实际上会计算并返回一个新的 Point 来表示正方形的中心，而不是返回一个现有的值。从上面代码可以看出，getter 方法正确地返回了一个中心点 (5, 5) 。 接下来我们将 center 属性设置为新的值 (15, 15) ，它会将方块向上和向右移动到下图中橙色方块所示的新位置。设置 center 属性会调用 center 的 setter 方法，它将会修改 origin 存储属性的 x 和 y 值，并将方块移动到新的位置。 Setter 声明的速记符号如果计算属性的 setter 方法没有为要设置的新值定义名称，则使用默认名称 newValue 。这是 Rect 结构体的替代版本，它使用了这种速记符号：123456789101112131415struct AlternativeRect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set &#123; origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) &#125; &#125;&#125; 只读计算属性只有 getter 方法但没有 setter 方法的计算属性称为 只读计算属性 。只读计算属性始终返回一个值，可以通过点语法访问，但不能给它赋值。 注意你必须使用 var 关键字来声明计算属性（包括只读计算属性），这是因为它们的值是不固定。let 关键字仅用于常量属性，这种属性一旦被初始化以后，就不能再更改它们的值。 你还可以通过删除 get 关键字及其大括号来简化只读计算属性的声明：123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")// 打印 "the volume of fourByFiveByTwo is 40.0" 这个例子定义了一个名为 Cuboid 的新结构体，它代表一个具有 width ， height 和 depth 属性的3D矩形框。这个结构体还有一个名为 volume 的只读计算属性，它计算并返回长方体的当前体积。 volume 可以被设置是没有意义的，因为对于特定的 volume 值，对应的 width ， height 和 depth 是不能唯一确定的。所以在这种情况下， Cuboid 提供只读计算属性以使外部用户能够获取当前计算体积是很有用的。 属性观察器属性观察器会观察并对属性值的变化做出反应。每次设置属性值时都会调用属性观察器，即使新值与属性的当前值相同。 你可以将属性观察器添加到你定义的任何存储属性上，但延迟存储属性除外。你还可以通过在子类中重写属性来为任何继承的属性（无论是存储还是计算）添加属性观察器。你并不需要为非重写的计算属性定义属性观察器，因为你可以在计算属性的 setter 方法中观察并响应其值的更改。属性重写将在 重写 中有详细描述。 你可以选择在属性上定义一个或两个观察器： 在存储值之前调用 willSet 。 存储新值后立即调用 didSet 。 如果实现 willSet 观察器，它会将新属性值作为常量参数传递。你可以在 willSet 实现中指定此参数的名称。如果不在实现中指定参数名称，则使用默认参数名称 newValue 。 类似地，如果你实现一个 didSet 观察器，它会传递一个包含旧属性值的常量参数。你可以指定参数名称或使用默认参数名称 oldValue 。如果你在自己的 didSet 属性观察器里给自己赋值，那么你赋值的新值将会替代刚刚设置的值。 注意在调用父类初始化方法之后，在子类中给父类属性赋值时，将会调用父类属性的 willSet 和 didSet 观察器。如果在调用父类初始化方法之前，在子类中给父类属性赋值，则不会调用父类的观察器。 下面是一个 willSet 和 didSet 的例子。示例中定义了一个名为 StepCounter 的类，它记录了一个人行走的总步数。该类可用于导入来自计步器或其它计步装置的数据，以追踪人们的日常运动情况。12345678910111213141516171819202122class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print("将要设置 totalSteps 为 \(newTotalSteps)") &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print("增加了 \(totalSteps - oldValue) 步") &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// 将要设置 totalSteps 为 200// 增加了 200 步stepCounter.totalSteps = 360// 将要设置 totalSteps 为 360// 增加了 160 步stepCounter.totalSteps = 896// 将要设置 totalSteps 为 896// 增加了 536 步 StepCounter 类声明了 Int 类型的 totalSteps 属性。这是一个带有 willSet 和 didSet 观察器的存储属性。 只要为属性赋了新值，就会调用 totalSteps 的 willSet 和 didSet 观察器。即使新值与当前值相同，也是如此。 这个例子的 willSet 观察器使用了自定义参数名称 newTotalSteps 来表示即将到来的新值。在此示例中，它只是打印出即将设置的值。 在更新 totalSteps 的值之后调用 didSet 观察器。它将 totalSteps 的新值与旧值进行比较。如果步骤总数增加，则会打印一条消息，显示增加了多少步数。 didSet 观察器不会为旧值提供自定义参数名称，而是使用默认名称 oldValue 。 注意如果将具有观察器的属性作为 in-out 参数传递给函数，则 willSet 和 didSet 观察器一定会被调用。这是因为 in-out 参数是 copy-in copy-out 内存模型：值一定会在函数结束后写回属性。 全局和局部变量上面描述的用于计算和观察属性的功能也可用于 全局变量 和 局部变量 。全局变量是指在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是指在函数、方法或闭包上下文中定义的变量。 你在前面章节中遇到的全局和局部变量都是 存储变量 。 存储变量（如存储属性）为特定类型的值提供存储，并允许设置和检索该值。 总之，你可以在全局或局部范围内定义 计算变量 和给存储变量设置观察器。计算变量只会计算它们的值，而不存储它们，编写方式与计算属性相同。 注意全局常量和变量总是被延迟计算，与 延迟存储属性 类似。与延迟存储属性不同的是，全局常量和变量不需要使用 lazy 修饰符进行标记。局部常量和变量永远不会被延迟计算。 类型属性实例属性是属于特定类型的实例的属性。每次创建该类型的新实例时，它都有自己的一组属性值，与任何其他实例不同。 你还可以定义属于该类型本身的属性，而不是类型的实例属性。无论你创建的该类型的实例有多少，这些属性都只会有一个副本。这些属性称为 类型属性 。 类型属性用于定义一个对某个类型的 所有 实例都可见的值，例如所有实例都可以使用的常量属性（如 C 中的静态常量），或者所有实例都可以访问的全局变量属性（如 C 中的静态变量）。 存储类型属性可以是变量或常量。计算类型属性始终是变量属性，与声明计算实例属性的方式相同。 注意与存储实例属性不同，你必须始终为存储类型属性提供默认值。这是因为类型本身没有初始化方法来给存储类型属性赋值。存储类型属性在首次访问时被初始化。它们会被保证只初始化一次，即使同时由多个线程访问。请注意你并不需要用 lazy 修饰符标记它们。 类型属性的语法在 C 和 Objective-C 中，你使用 全局 静态变量来定义与类型关联的静态常量和变量。但是，在 Swift 中，类型属性是写在类型定义的花括号内，作为类型定义的一部分，并且每个类型属性都明确地显示它支持的类型。 你可以使用 static 关键字定义类型属性。对于类类型的计算类型属性，可以使用 class 关键字来允许子类覆盖超类的实现。下面的示例显示了存储和计算类型属性的语法：123456789101112131415161718192021struct SomeStructure &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 注意上面的计算类型属性是只读计算类型属性，但你也可以使用与计算实例属性相同的语法定义读写计算类型属性。 检索和设置类型属性类型属性可以使用点语法来进行检索和设置，就像实例属性一样。但是，类型属性是基于 类型 来进行检索和设置，而不是基于该类型的实例。 例如：123456789print(SomeStructure.storedTypeProperty)// 打印 "Some value."SomeStructure.storedTypeProperty = "Another value."print(SomeStructure.storedTypeProperty)// 打印 "Another value."print(SomeEnumeration.computedTypeProperty)// 打印 "6"print(SomeClass.computedTypeProperty)// 打印 "27" 以下示例使用两个存储类型属性作为建模一个数字音频信道音频测量表的结构体的一部分。每个通道的整数音频电平在 0 和 10 之间。 下边的图例展示了这个音频频道如何组合建模一个立体声音频测量表。当通道的音频电平为 0 时，该通道的任何灯都不会亮起。当音频电平为 10 时，该通道的所有灯都会亮起。在该图中，左声道的当前电平为 9 ，右声道的当前电平为 7 ： 上面描述的音频通道由 AudioChannel 结构体实例表示：12345678910111213141516struct AudioChannel &#123; static let thresholdLevel = 10 static var maxInputLevelForAllChannels = 0 var currentLevel: Int = 0 &#123; didSet &#123; if currentLevel &gt; AudioChannel.thresholdLevel &#123; // 将新音频电平值限制在阈值之内 currentLevel = AudioChannel.thresholdLevel &#125; if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123; // 将此存储为新的目前最大的电平值 AudioChannel.maxInputLevelForAllChannels = currentLevel &#125; &#125; &#125;&#125; AudioChannel 结构体定义了两个存储类型属性以支持其功能。第一个， thresholdLevel ，定义音频电平值可以采用的最大阈值。对于所有 AudioChannel 实例，这是一个常量值 10 。（如下面描述的那样）如果音频信号电平值高于 10 ，我们仍然只能把它设置为 10 。 第二个类型属性是名为 maxInputLevelForAllChannels 的变量存储属性。这个变量保存 所有 AudioChannel 实例接收的最大输入值。它的初始值为 0 。 AudioChannel 结构体还定义了一个名为 currentLevel 的存储实例属性，它表示通道的当前音频电平值，范围为 0 到 10 。 currentLevel 属性有一个 didSet 属性观察器，可以在赋值时检查 currentLevel 的值。该观察器执行两项检查： 如果 currentLevel 的新值大于允许的 thresholdLevel ，则属性观察器将 currentLevel 限制为 thresholdLevel 。如果 currentLevel 的新值（在阈值之内）高于 所有 AudioChannel 实例先前接收的电平值，则属性观察器将新的 currentLevel 值存储在 maxInputLevelForAllChannels 类型属性中。 注意在第一个检查中，即使 didSet 观察器将 currentLevel 设置为不同的值，也不会导致再次调用观察器。 你可以使用 AudioChannel 结构体创建两个名为 leftChannel 和 rightChannel 的音频通道，以表示立体声音响系统的音频等级：12var leftChannel = AudioChannel()var rightChannel = AudioChannel() 如果将 左 通道的 currentLevel 设置为 7 ，则可以看到 maxInputLevelForAllChannels 类型属性更新为 7 ：12345leftChannel.currentLevel = 7print(leftChannel.currentLevel)// 打印 "7"print(AudioChannel.maxInputLevelForAllChannels)// 打印 "7" 如果你试图将 右 通道的 currentLevel 设置为 11 ，你可以看到右通道的 currentLevel 属性的值是阈值 10 ，而 maxInputLevelForAllChannels 类型属性的值也更新为 10 ：12345rightChannel.currentLevel = 11print(rightChannel.currentLevel)// 打印 "10"print(AudioChannel.maxInputLevelForAllChannels)// 打印 "10"]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>类和结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 类和结构体]]></title>
    <url>%2F2018%2F10%2F13%2FSwift%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[结构体和类是通用，灵活的设计，是你程序代码的结构基础。使用与你定义常量，变量和函数相同的语法来定义属性和方法以此为你的结构体和类添加功能。 并不像其他语言，Swift 不需要你为自定义结构体和类创建单独的接口与实现文件，Swift 中定义结构体和类在一个文件里，并且该类或结构体对其他代码会自动创建外部接口。 比较结构体和类Swift 中结构体和类有很多共同点，二者皆可： 定义属性以存储值 定义方法以提供功能 定义下标以提供下标语法访问其值 定义构造器以设置其初始化状态 通过扩展以增加默认实现功能 遵循协议以提供某种标准功能 类有有一些结构体没有的额外功能： 继承让一个类可以继承另一个类的特征 类型转换让你在运行时可以检查和解释一个类实例 析构器让一个类的实例可以释放任何被其所分配的资源 引用计数允许对一个类实例进行多次引用 使用类的额外功能其代价就是增加了复杂性。一般来说，更推荐结构体和枚举，因为他们更加容易进行推断，并且适当或必要时使用类。实际上，这意味着将会使用结构体和枚举来定义大多数自定义数据类型。更多比较详情请参阅 抉择在结构体和类之间。 定义语法结构体和类有相似的定义语法。使用 struct 关键字定义结构体、使用 class 关键字定义类。二者都在大括号中定义其具体内容：123456struct SomeStructure &#123; // structure definition goes here&#125;class SomeClass &#123; // class definition goes here&#125; 注意每当你定义一个新的结构体或类都是定义一个全新的 Swift 类型。请使用 UpperCamelCase 命名法（例如 SomeStructure 和 SomeClass）以符合大写命名风格的标准 Swift 类型（例如 String，Int 和 Bool）。对于属性和方法使用 lowerCamelCase 命名法（例如 frameRate 和 incrementCount）以此和类名区分。 以下是定义结构体和类的示例:12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 上面的例子定义了一个名为 Resolution 的结构体，用于描述基于像素的显示分辨率。这个结构体有两个存储属性分别名为 width 和 height。 存储属性是与结构体或类绑定并存储为其一部分的常量或变量。由于设置这两个属性的初始值为 0 所以其类型被推断为 Int 。 上面的例子还定义了一个名为 VideoMode 的类，用于描述视频的指定显示模式，这个类有四个为存储属性的变量。第一个，resolution，是 Resolution 结构体初始化的一个实例，其类型被推断为 Resolution。至于其他三个属性，新的 VideoMode 实例会把 interlaced 设置为 false（逐行扫描视频），播放帧数 frameRate 设置为 0.0，和一个名为 name 关联值类型是 String 的 可选类型。由于是可选类型，name 默认值自动为 nil，或说『无 name 值』。 结构体与类实例Resolution 结构体和 VideoMode 类的定义只描述了 Resolution 和 VideoMode 是什么样的。他们并没有描述一个特定的分辨率或视频模式。为此，我们需要创建其实例来指定分辨率或视频模式。 结构体和类创建实例的语法非常相似：12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都可以使用构造语法创建新的实例，最简单形式的构造语法就是类或结构体的类型名称之后尾随空括号，例如 Resolution() 或 VideoMode()。这样就创建了一个类或结构体的实例，并且所有属性全部初始化为默认值。 访问属性你可以使用点语法来访问一个实例的属性。点语法中，在实例名的后面直接写属性名，用（.）来分割。12print("The width of someResolution is \(someResolution.width)")// 打印 "The width of someResolution is 0" 这个例子中，someResolution.width 就是 someResolution 中的 width， 返回其默认值 0。你也可深入访问子属性，例如 VideoMode 的 resolution 属性的 width 的属性：12print("The width of someVideoMode is \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is 0" 你也可以使用点语法给变量属性赋值：123someVideoMode.resolution.width = 1280print("The width of someVideoMode is now \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is now 1280" 结构体类型的成员构造器所有结构体都有一个用于初始化结构体实例的成员属性，并且是自动生成的成员构造器。实例属性的初始化值通过属性名称传递到成员构造器中：1let vga = Resolution(width: 640, height: 480) 与结构体不同，类没有默认的成员构造器 值类型的结构体和枚举值类型是一种赋值给变量或常量，或传递给函数时，值会被拷贝的类型。 其实你在之前的章节中已广泛的使用了值类型。其实 Swift 中的所有基本类型 — 整数，浮点数，布尔，字符串，数组和字典 — 它们都是值类型，其底层也是以结构体实现的。 Swift 中所有的结构体和枚举都是值类型。这意味着在代码中你创建的任何结构体或枚举的实例 — 及其任何值类型的属性 — 都会在传递时被拷贝。 注意标准库所定义的集合例如数组，字典和字符串都进行了优化以减少拷贝时的性能开销。这些集合不是直接复制，而是在原始实例和所有副本之间共享内存。如果集合的任意一个副本被修改，则会在修改之前复制该元素。代码中这种行为看似好像立即发生。 这个示例用了上面的 Resolution 结构体：12let hd = Resolution(width: 1920, height: 1080)var cinema = hd 声明了一个名为 hd 的常量并使用全高清视频的宽高（ 1920 像素宽，1080 像素高 ）将其初始化为 Resolution 的实例。 还声明了一个名为 cinema 的变量并使用当前 hd 的值为其赋值。 因为 Resolution 是一个结构体，所以会制作一个当前实例的副本赋值给 cinema 。虽然 hd 和 cinema 现在有同样的宽高，但是他们在底层是完全不同的两个实例。 接下来，将 cinema 的属性 width 修改为略宽一点的数字影院放映的 2 K 标准宽度（ 2048 像素宽和 1080 像素高 ）1cinema.width = 2048 查看 cinema 的属性 width 会发现已经改成了 2048：12print("cinema is now \(cinema.width) pixels wide")// 打印 "cinema is now 2048 pixels wide" 而原始 hd 实例的 width 属性还是之前的值 1920:12print("hd is still \(hd.width) pixels wide")// 打印 "hd is still 1920 pixels wide" 当 hd 赋值给 cinema 时，存储在 hd 中的值就拷贝给了新的 cinema 实例。最终结果就是相同数值但完全独立的两个实例。由于他们完全独立，所以设置 cinema 的宽度为 2048 并不会影响 hd 中的存储，如下图所示： 枚举也适用于同样的行为准则：1234567891011121314enum CompassPoint &#123; case north, south, east, west mutating func turnNorth() &#123; self = .north &#125;&#125;var currentDirection = CompassPoint.westlet rememberedDirection = currentDirectioncurrentDirection.turnNorth()print("The current direction is \(currentDirection)")print("The remembered direction is \(rememberedDirection)")// 打印 "The current direction is north"// 打印 "The remembered direction is west" 当 currentDirection 的值赋值给 rememberedDirection，实际上也是值拷贝。因此改变 currentDirection 的值并不会影响存储在 rememberedDirection 中原始值的副本。 类是引用类型与值类型不同，赋值给变量或常量，或是传递给函数时，引用类型并不会拷贝。引用的不是副本而是已经存在的实例。 下面这个例子使用了之前定义的 VideoMode 类。12345let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = "1080i"tenEighty.frameRate = 25.0 这个例子声明了一个名为 tenEighty 的常量并将其设置为引用 VideoMode 类的实例。用之前的 1920 * 1080 的高清分辨率的副本赋给视频模式。将其命名为”1080i“ 并设置为隔行扫描。最后设置帧率为每秒 25.0 帧。 然后将 tenEighty 赋值给一个名为 alsoTenEighty 的新常量，同时修改其帧率：12let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0 因为类是引用类型，所以其实 tenEighty 和 alsoTenEighty 引用了同一个 VideoMode 的实例。实际上，他们只是两个不同名字的相同实例，如下图所示： 查看 frameRate 的属性 tenEighty ，会发现它正确的引用了 VideoMode 实例的新帧率 30.0：12print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")// 打印 "The frameRate property of tenEighty is now 30.0" 以上的例子还显示了引用类型推断有多费劲。如果 tenEighty 和 alsoTenEighty 在你的代码中相距甚远，那么可能很难找到改变视频模式的所有地方。无论你在哪里使用 tenEighty，都需要考虑用到 alsoTenEighty 的代码，反之亦然。相反，值类型就很好推断，因为在你的源文件中相同值相互作用的所有代码是紧密相连的。 注意 tenEighty 和 alsoTenEighty 声明的是常量而不是变量。但是你仍然可以改变 tenEighty.frameRate 和 alsoTenEighty.frameRate，因为常量 tenEighty 和 alsoTenEighty 的值自身实际上没有改变。tenEighty 和 alsoTenEighty 本身并不存储 VideoMode 的实例，他们都只是在底层引用了 VideoMode 的实例。改变的是 VideoMode 的属性 frameRate ，而不是引用 VideoMode 的常量的值。 恒等运算符因为类是引用类型，在底层可能多个常量和变量引用同一个类的实例。（ 同样的理论对结构体和枚举来说并不有效，因为当它们赋值给常量或变量，或是传递给函数时，总是拷贝的。） 有时找出两个常量或变量是否引用同一个类的实例很有帮助。为此，Swift 提供了恒等运算符： 等价于 (===) 非等价 (!==) 使用他们来检查两个常量或变量是否引用同一个实例：1234if tenEighty === alsoTenEighty &#123; print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")&#125;// 打印 "tenEighty and alsoTenEighty refer to the same VideoMode instance." 注意等价于（ 用三个等号表示 === ）和等于（ 用两个等号表示==）完全不是一回事。等价于意思是两个常量或变量完全引用相同的类实例。等于的意思是两个实例某种意义上的值相等或相同，就像类型设计者定义的那样。 当你自定义结构体或类时，你有责任决定两个实例相等的标准。在 等价运算符中介绍了实现自定义『 等于 』和『 非等于 』的流程。 指针如果你有过 C，C++，或 Objective-C 的经验，你或许知道这些语言使用指针来指向内存中的地址。指向某种引用类型实例的 Swift 常量或变量和 C 中的指针类似，但是并不直接指向内存地址，你也不需要写星号（*）来表示创建了一个引用。定义引用和 Swift 中的其他常量或变量一样。如果你需要直接与指针交互标准库提供了指针和 buffer 类型 — 请参阅 手动内存管理.]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>类和结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 枚举]]></title>
    <url>%2F2018%2F10%2F12%2FSwift%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举 为一组相互关联的值定义一种通用类型，它能确保我们在代码中类型安全地使用这些值。 假如你熟悉 C 语言，你应该知道 C 语言中的枚举会为一系列整形值分配相关联的名称。Swift 中的枚举更加灵活，我们不必给每个 case 都提供一个值。如果给枚举的每个 case 分配一个值（被称作“原始”值），这个值可以是字符串或字符类型，也可以是整形或者浮点数。 此外，枚举中的 case 能够被指定为 任意 不同类型的关联值，类似于其它语言中的关联体（unions）和变形体（variants）。我们用枚举定义了一系列相关的情形值时，每个情况的关联值都可以是不同类型。 枚举在 Swift 中是一等类型，它采用了许多传统语言中只能被类支持的特性，例如计算属性（用来提供枚举值的附加信息）和实例方法（用来提供与枚举值相关联的一些方法）。枚举也可以定义构造函数，用来提供初始值；可以在原有实现的基础上进行功能上的扩展；还可以通过遵守协议来提供标准功能。 枚举语法使用 enum 关键词来声明枚举并把它们的全部定义放在一对大括号内：123enum SomeEnumeration &#123; // 枚举的定义放在这里&#125; 下面的例子是使用枚举表示指南针的四个方向：123456enum CompassPoint &#123; case north case south case east case west&#125; 枚举中定义的值 (比如 north, south, east, 和 west) 是枚举的成员。使用 case关键字来定义一个新的枚举成员。 注意不像 C 和 Objective-C，Swift 的枚举成员在创建时不会被赋予一个默认的整型值。在上述CompassPoint 一例中，north, south, east 和 west 不会被隐式赋值为 0, 1, 2 和 3。相反，这些不同的枚举成员本身就是完备的值，并且是明确定义的CompassPoint类型。 多个成员可以出现在同一行，并以逗号来隔开：123enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 每个枚举都定义了一个全新的类型。像 Swift 中其他的类型一样，它们的名字（例如 CompassPoint 和 Planet ）应该以大写字母开头。为了阅读起来更简洁明了，以单数形式命名枚举，而不是复数形式：1var directionToHead = CompassPoint.west directionToHead 的类型在被 CompassPoint 的一个值初始化时可以推断出来。一旦 directionToHead 被声明为 CompassPoint类型，你可以使用更简短的点语法来设置其为一个不同的 CompassPoint 值：1directionToHead = .east 因为 directionToHead 的类型已知，所以你可以在赋值阶段省略类型名。在使用显示类型的枚举值时，这种写法让代码具有更高的可读性。 用 Switch 语句来匹配枚举值在 switch 语句中你可以对每个枚举值进行匹配:123456789101112directionToHead = .southswitch directionToHead &#123;case .north: print("Lots of planets have a north")case .south: print("Watch out for penguins")case .east: print("Where the sun rises")case .west: print("Where the skies are blue")&#125;// 打印 "Watch out for penguins" 这段代码可以理解为: 「就 directionToHead 这个值而言，当它等于 .north 时，输出 Lots of planets have a north，当它是 .south 时则会输出 Watch out for penguins」。 以此类推。在 控制流 中提到, 一个 switch 语句必须列举出枚举中的所有值。 如果漏掉了 .west 这个 case，这段代码就会因为没有考虑到 CompassPoint 这个枚举中的所有情况而不会被编译。 需要穷举所有的情况来确保不会有遗漏。 当不需要给每一个枚举中的情况都写一个 case 时，你可以用 default 来代替其他所有没有被声明的情况：12345678let somePlanet = Planet.earthswitch somePlanet &#123;case .earth: print("Mostly harmless")default: print("Not a safe place for humans")&#125;// 打印 "Mostly harmless" 遍历枚举的情况定义一个所有枚举情况的集合在某些枚举中是很有用的。你通过在枚举的名字后面写 : CaseIterable 来使用它。Swift 用 allCases 这个属性来暴露出这个枚举中所有 case 的集合。例子如下：123456enum Beverage: CaseIterable &#123; case coffee, tea, juice&#125;let numberOfChoices = Beverage.allCases.countprint("\(numberOfChoices) beverages available")// 打印 "3 beverages available" 在上面的例子中，通过 Beverage.allCases 可以得到 Beverage 这个枚举包含的所有 case 的集合。你可以想其他集合一样使用 allCases – 集合中的元素为这个枚举的值，在这个例子中也就是 Beverage 的值。上面的例子中得到了枚举中 case 的个数，而下面的例子中则用 for 循环遍历了所有的 case。123456for beverage in Beverage.allCases &#123; print(beverage)&#125;// coffee// tea// juice 关联值上一节的示例演示了枚举本身是如何被定义（和分类）的。你可以为 Planet.earth 设置一个常量或变量，并在稍后查看此值。但是，如果能够在这些成员值旁边存储其他类型的 关联值 就更方便了。这能让你存储成员值之外的其他自定义信息，并且每次在代码中使用该成员值时允许这个信息发生变化。 你可以定义 Swift 枚举以存储任何给定类型的关联值，并且如果需要，每种枚举的值类型可以不同。这种枚举在其他编程语言中称为 区分联合 ， 标记的联合 或 变体。 例如，假设库存跟踪系统需要通过两种不同类型的条形码跟踪产品。有些产品使用标有数字 0 到 9 的 UPC 格式的 1D 条形码。每个条形码都有一个「数字系统」码，后面跟着五个「制造商代码」码和五个「产品代码」码。然后是「检查」码，以验证条形码是否被正确扫描： 其他产品使用 QR 格式的二维条码进行标记，可以使用任何ISO 8859-1字符，并且可以编码长达 2953 个字符的字符串： 对于库存跟踪系统来说，如果能将 UPC 条形码存储为四个整数的元组，同时将 QR 条形码存储为任意长度的字符串，会是最方便的。 在 Swift 中，定义这两种类型的产品条形码的枚举如下所示：1234enum Barcode&#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125; 这可以理解为：「定义一个名为 Barcode 的枚举类型，它可以是一个 upc 的值，带有（ Int ， Int ， Int ， Int ）类型的关联值，或者是一个 qrCode的值，带有 String 类型的关联值。」 这个定义没有提供任何实际的 Int 或 String 值 — 它只定义了，当一个 Barcode 类型的常量或变量在等于 Barcode.upc 或 Barcode.qrCode 时，可以存储的相关值的 类型 。 可以使用以下任一类型创建新的条形码：1var productBarcode = Barcode.upc(8, 85909, 51226, 3) 这个例子创建了一个名为 productBarcode 的新变量，并为它赋值 Barcode.upc ，其关联值为 (8, 85909, 51226, 3) 。 可以为同一产品分配不同类型的条形码：1productBarcode = .qrCode("ABCDEFGHIJKLMNOP") 这时，原始的 Barcode.upc 和其整形数值被新的 Barcode.qrCode 和其字符串值所替代。条形码的常量和变量可以存储为一个 .upc 或者一个 .qrCode （连同它的关联值），但是在任何指定时间只能存储其中之一。 像以前一样，不同的条形码可以使用一个 switch 语句来检查。然而这次关联值可以被提取作为 switch 语句的一部分。你可以在 switch 的case 分支代码中提取每个关联值作为一个常量（用 let 前缀）或者一个变量（用 var 前缀）来使用：1234567switch productBarcode &#123;case .upc(let numberSystem, let manufacturer, let product, let check): print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")case .qrCode(let productCode): print("QR code: \(productCode).")&#125;// 打印 "QR code: ABCDEFGHIJKLMNOP." 如果一个枚举成员的所有关联值都被提取作为常量，或者全被提取作为变量，为了简洁，你可以放置一个 var 或者 let 标注在成员名称的前面：1234567switch productBarcode &#123;case let .upc(numberSystem, manufacturer, product, check): print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")case let .qrCode(productCode): print("QR code: \(productCode).")&#125;// 打印 "QR code: ABCDEFGHIJKLMNOP." 原始值在 关联值 小节的条形码例子中演示了一个枚举成员如何声明它们存储着不同类型的关联值。作为关联值的替代，枚举成员可以被默认值（称为 原始值 ）预先填充，其中这些原始值具有相同的类型。12345enum ASCIIControlCharacter: Character &#123; case tab = "\t" case lineFeed = "\n" case carriageReturn = "\r"&#125; 在这里，称为 ASCIIControlCharacter 的枚举的原始值被定义为字符型 Character ，并被设置了一些比较常见的 ASCII 控制字符。字符 值的描述请详见 字符串和字符。 原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。 注意原始值和关联值是 不相同 的。当你开始在你的代码中定义枚举的时候原始值是被预先填充的值，向上述的三个 ASCII 值。对于一个特定的枚举成员，它的原始值始终是相同的。关联值是你在创建一个基于枚举成员的新常量或者变量时才会被设置的，并且每次当你这么做的时候，它的值可以不同。 原始值的隐形赋值在使用原始值为整型值或者字符串类型的枚举时，不需要显式的给每一个枚举成员设置原始值，Swift 会自动赋值。 例如，如果使用整型值作为原始值，隐式赋值的值会依次递增1.如果第一个枚举成员没有设置原始值，那么它的原始值就是 0。 下面的枚举是对之前的 Planet 这个枚举的一个细化，利用原始整型值来代表每个 planet 在太阳系中的顺序：123enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 在上述例子中, Planet.mercury 有一个显式值 1 , Planet.venus 有一个隐式值 2 , 依次类推。 当使用字符串作为原始值时，每个枚举成员的隐式初值是该成员的名称。 下面的枚举是对之前 CompassPoint 枚举的改进，其中使用字符串原始值表示每个方向的名称：123enum CompassPoint: String &#123; case north, south, east, west&#125; 在上面的例子中， CompassPoint.south 有一个隐含的原始值 「south」 ，依此类推。 你可以使用其 rawValue 属性访问枚举的原始值：12345let earthsOrder = Planet.earth.rawValue// earthsOrder 的值为 3let sunsetDirection = CompassPoint.west.rawValue// sunsetDirection 的值为 "west" 使用原始值初始化如果使用原始值类型定义枚举，该枚举会自动获得一个初始化方法，该初始化方法接受原始值类型的值（作为名为 rawValue 的参数）并返回枚举成员或 nil 。你可以使用此初始化方法尝试创建枚举的新实例。 这个例子从原始值 7 中识别出天王星：12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet 是 Planet? 类型，并且等于 Planet.uranus 然而，并非所有 Int 值都会找到匹配的行星。因此，原始值初始化方法始终返回 可选 枚举成员。在上面的例子中， possiblePlanet 的类型是 Planet? ，或「可选的 Planet 」。 注意原始值构造器是一个可失败构造器，因为并非每个原始值都能返回对应的枚举成员。有关更多信息，请参阅 可失败构造器 。 如果你试图找到一个位置为 11 的行星，那么原始值初始化方法返回的可选 Planet 值将为 nil ：123456789101112let positionToFind = 11if let somePlanet = Planet(rawValue: positionToFind) &#123; switch somePlanet &#123; case .earth: print("Mostly harmless") default: print("Not a safe place for humans") &#125;&#125; else &#123; print("There isn't a planet at position \(positionToFind)")&#125;// 打印 "There isn't a planet at position 11" 此示例使用可选绑定来尝试访问原始值为 11 的行星。 语句 if let somePlanet = Planet(rawValue: 11) 创建了一个可选的 Planet ，并且当可选 Planet 有返回值时，将 Planet 的值赋给 somePlanet 。 在这个例子中，不可能找到位置为 11 的行星，因此执行 else 分支。 递归枚举递归枚举 是枚举的一种，它允许将该枚举的其他实例，作为自己一个或多个枚举成员的关联值。 你可以通过在枚举成员之前加上 indirect 来表示枚举成员是递归的，它将告诉编译器插入必要的间接层。 例如，这是一个存储简单算术表达式的枚举：12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 你还可以在枚举的开头加入 indirect ，以将所有具有关联值的枚举成员标示为可递归的：12345indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 此枚举可以存储三种算术表达式：普通数字、两个表达式的相加以及两个表达式的相乘。 addition 和 multiplication 枚举成员的相关值同时也是算术表达式 — 这使得嵌套表达式成为可能。 例如，表达式 (5 + 4) * 2 在乘法的右侧有一个数字，在乘法的左侧有另一个表达式。 因为数据是嵌套的，用于存储数据的枚举也需要支持嵌套 — 这意味着枚举需要是可递归的。 下面的代码展示了为 (5 + 4) * 2 创建的 ArithmeticExpression 递归枚举：1234let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2)) 递归函数是一种处理递归结构数据的简单方法。 例如，这是一个计算算术表达式的函数：123456789101112func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;print(evaluate(product)) 当此函数遇到纯数字，直接返回相关值即可。 当此函数遇到加法或乘法，则分别计算符号左侧和右侧的表达式，然后将它们相加或相乘。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 闭包]]></title>
    <url>%2F2018%2F10%2F11%2FSwift%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[『闭包』是独立的代码块, 可以在你代码中随意传递和使用 。Swift 中的闭包与 Objective-C/C 中的 Block、其他编程语言中的匿名函数相似。 闭包可以从定义它们的代码的上下文中捕获和存储任何变量。这也被称为这些变量和常量被暂时关闭使用。并且 Swift 负责处理你所捕获的内存进行管理。 闭包采取如下三种形式之一： 全局函数是一个有名字但不会捕获任何值的闭包。 嵌套函数是一个有名字并且可以捕获其封闭函数域内值的闭包。 闭包表达式是一个用轻量语法所写的可以捕获其上下文中变量或常量值的匿名闭包。 Swift 的闭包表达式具有干净、清晰的风格，并鼓励在常见场景中进行语法优化使其简明、不杂乱。这些优化主要包括： 利用上下文推断参数和返回值类型 单语句表达式的闭包可以隐式返回结果 参数名称缩写 尾随闭包语法 闭包表达式闭包表达式 是一种用简短、集中的语法构建内联闭包的方式。闭包表达式提供了几种语法优化的方式，使其能够写出简短的闭包而又不失去闭包函数的可读性。下面的闭包表达式示例，通过在几次迭代中不断改善 sorted(by:) 方法的方式来说明这些优化，每一次迭代都用更简洁的方式描述了相同的功能。 方法排序Swift的基础库提供了一个名字叫做 sorted(by:) API，它通过你编写的一个闭包来进行对数组进行排序。 当完成所有排序代码, sorted(by:) 方法会返回一个与旧数组相同规格和相同类型的新数组, 并且每个元素都会在正确的位置。 最开始的数组也不会通过 sorted(by:) 被修改。 下面的闭包示例使用了 sorted(by:) 方法进行了对于 String 类型进行反向排序。这是最开始将要被排序的数组：1let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"] sorted(by:) 方法接受一个闭包表达式，闭包表达式接受两个相同类型的数组元素，并且返回 Bool 布尔值来告诉是否第一个值应该在第二个值的前面还是后面。如果这个第一个值应该在第二个值 前面 则返回 true, 反之返回 false。 这个例子是对 String 类型的数组进行排序，因此这个闭包需要是 (String, String) -&gt; Bool 类型的函数。 提供该排序闭包的一种方法是写正确类型的函数，并且作为参数传入 sorted(by:) 方法中。 如下：12345func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// reversedNames 会等于 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 如果第一个字符串「s1」大与第二个字符串「s2」，backward(_:_:) 函数将返回 true ，指示 s1 在这个排序数组中位置应该在 s2 的前面。对于字符串来说，“大于”的意思就是“在字母表中出现较后”。这意思是说字母 &quot;B&quot; 是大于字母 &quot;A&quot; 的，也就是说字符串 &quot;Tom&quot; 是大于 &quot;Tim&quot; 的。这是一个反向排序的例子 &quot;Barry&quot; 将出现在 &quot;Alex&quot; 前面，依此类推。 然而，使用单一表达式的函数「a&gt;b」是一种相当冗长的方式。在本例中最好写法是使用闭包表达式内联的方式编写一个排序闭包。 闭包表达式语法闭包表达式语法基本组成如下:123&#123; (parameters) -&gt; return type in statements&#125; parameters 在闭包表达式中当作入参，但它们没有默认值。如果你参数类型为入参，则可以在闭包中使用可变类型的方法。元组也可以当做参数和返回值。 下面的例子展示了上面 backward(_:_:) 函数的闭包表达式版本：123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 注意这个内联闭包与 backward(_:_:) 函数的入参和返回值是相同的。在这两种情况下，它被写成 (s1: String, s2: String) -&gt; Bool 。然而，对于内联闭包表达式，参数和返回值被写在花括号‘内部’，而不是外部。 闭包表达式主体部分开始于关键字 in 。这个关键字也代表这个闭包的入参和返回值已经声明结束，主体部分将要开始。 因为上面闭包表达式的主体部分比较短，甚至可以写成一行。1reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) 这也说明了 sorted(by:) 方法总体调用保持不变。一对括号仍然包含该方法的入参。然而，现在参数却是一个内联闭包了。 通过上下文推测类型因为这个排序闭包是作为一个方法的参数，Swift 能够推断出这个闭包的参数和返回值。 sorted(by:) 方法将被一个字符串数组调用，以至于方法参数的函数的类型一定是 (String, String) -&gt; Bool 。这也意味 (String, String) 和 Bool类型可以不需要作为闭包定义的一部分。也正因为推断出了所有入参和返回值，返回的符号 (-&gt;) 和入参周围的括号也可以被省略。简写后如下：1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 当闭包以内联的形式作为一个函数或者方法的参数传入时，始终可以被推断出入参和返回值的类型。因此，当内联闭包被方法或函数当作参数使用时，你也不需要以完整形式去写这个内联闭包。 尽管如此，你也按照个人意愿将参数类型显示出来。如果这样的做法可以让你的读者对你的代码不保持模凌两可，显示参数类型也是被鼓励使用的。在 sorted(by:) 方法的调用情况下，闭包的目的是帮助一个数组进行排序，也正因为这个闭包在字符串数组中被使用，可以让读者轻松推断出这个闭包正在使用 String 类型的值。 单一闭包表达式隐式返回单一闭包表达式可以省略声明 return 关键字来返回单一表达式的结果，上一个事例省略后如下：1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 这里，这个 sorted(by:) 方法函数类型清晰的表明闭包必须返回一个 Bool 类型的值。也因为这个闭包内部包含一个单一表达式 (s1 &gt; s2) 并且返回一个明确的 Bool 类型的值，因此关键字 return 可以被省略。 缩写参数名Swift 自动为内联闭包提供了参数名缩写写法，这里可以使用$0, $1, $2 等来代替闭包的参数。 如果你在闭包表达式中使用了缩写写法，你就可以省略闭包中的参数声明部分，并且这个缩写参数的值和类型也会通过函数预期类型推断出来。in 关键字也可以被省略，因为这个闭包表达式已经通过主体完全构建出来了。缩写后如下：1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 这里，$0 和 $1 的值指的是第一个和第二个 String 的参数 运算符方法实际上还有一种 更简短 的方式来编写上面例子中的闭包表达式。Swift 的 String 类型将其大于运算符（&gt;）的字符串特定实现为具有两个 String 类型参数的方法，并返回一个 Bool 类型的值。而这正好与 sorted(by: ) 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于运算符，Swift 可以自动推断出你想使用其特定于字符串的实现：1reversedNames = names.sorted(by: &gt;) 尾随闭包如果你需要将闭包表达式作为函数的最后一个参数传入函数，并且这个闭包非常长，这样的情况下使用 “尾随闭包” 这种写法会很有效。尾随闭包通常在函数调用的括号之后，即使他仍是一个参数。当你使用尾随闭包语法，你可以不用填写函数入参为闭包那部分的参数。123456789101112131415func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // 函数主体部分&#125;// 这里被调用函数没用后置闭包的写法:someFunctionThatTakesAClosure(closure: &#123; // 闭包主体部分&#125;)// 这里被调用函数使用后置闭包的写法:someFunctionThatTakesAClosure() &#123; // 尾随闭包主体部分&#125; 上面的字符串排序闭包 闭包表达式语法 作为尾随闭包被写在 sorted(by:) 方法的括号外部，如下：1reversedNames = names.sorted() &#123; $0 &gt; $1 &#125; 如果函数只有一个闭包类型入参，并且使用了尾随闭包的写法，当你调用这个函数的时候可以省略函数名称后面写 () ，写法如下：1reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 如果一个闭包代码很长以至于不能把它写在同一行上，这时使用后置闭包写法就比较有用了。例如，Swift 的 Array 类型的 map(_:) 方法就把闭包表达式作为唯一的参数传入。对数组中每个元素调用一次闭包，并为该元素返回一个映射值（可能是其他类型）。映射的值和类型由调用的闭包制定。 将提供的闭包应用到数组中的每个元素之后，map(_:) 方法会返回一个包含所有新映射值的新数组，并与原数组保持相同顺序。 下面介绍如何调用 map(_:) 方法并使用后置闭包的写法，来对一个 Int 类型的数组转换成 String 类型的数组。[16, 58, 510] 数组用于创建新数组 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]:12345let digitNames = [ 0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"]let numbers = [16, 58, 510] 这段代码上边创建了一个映射字典，整数数字作为键，以整数数字转换的英文作为值。并定义了一个整形数组，准备去转换成字符串数组。 你可以调用数组的 map(_:) 方法并传入一个后置闭包表达式，将 numbers 类型的数组转换为一个 String 类型的数组：1234567891011let strings = numbers.map &#123; (numbers) -&gt; String in var number = numbers var output = "" repeat &#123; output = digitNames[number % 10]! + output number /= 10 &#125; while number &gt; 0 return output&#125;// strings 被推测成 [String] 类型的数组// 它的值为 ["OneSix", "FiveEight", "FiveOneZero"] map(_:) 方法传入的闭包表达式会调用数组中每一个元素。你将不需要指定闭包的入参 number 类型，因为这个类型在数组映射的时候可以被推断出来。 这个例子中，局部变量 number 是在闭包主体中初始化并赋予闭包入参 number 的值，因此可以在闭包体内修改它的值。(函数或闭包的参数是常量)。闭包表达式也指定了一个 String 类型的返回值，指明了映射数组的返回值类型。 闭包表达式每次被调用时都会构建一个名为 output 的字符串。它通过取余操作 (number % 10) 获取 number 最末位数字并通过这个数组去字典 digitNames 找到对应的字符串。闭包可以使用字典找到所有大于等于 0 的字符串。 注意字典 digitNames 下标形式的调用之后是感叹号 (!) ，因为字典下标形式调用返回一个可选类型的值，表示对应键值不存可能查找失败的情况。上边的例子中 number % 10 获得的值一定作为 digitNames 字典的有效下标，因此使用感叹号强制解包字典索引下的 String 类型的值。 通过 digitNames 字典检索出得字符串会被存储在 output 字符串的前面，通过这种反向操作有效的构建了一个与原始值每个数字位置相同的字符串。( 取余表达式 number % 10 ,在 16 值是 6 ，在 58 值是8 ，在 510 值是 0 ) 。 然后这个 number 的值除以 10 。因为是整形在除法时会被四舍五入，然后 16 变成 1 , 58 变成 5 , 510 变成 51。 这个过程被一直被重复直到 number 值为 0 。 output 字符串在闭包中被返回，并且添加到了 map(_:) 方法的输出数组中。 上边的例子中使用了后置闭包的写法让这个闭包被调用后代码立即巧妙的封装函数的功能，不需要在 map(_:) 方法的括号里包装闭包体。 值捕获闭包可以 捕获 它所定义的上下文环境中的常量和变量。在闭包体内可以使用和修改这些常量和变量的值， 即使这些常量、变量的作用域已经不存在了。 在 Swift 中，闭包捕获值的最简单的形式是嵌套函数–写在另一个函数的函数体内。嵌套函数可以捕获外部函数中的任意参数，也可以捕获定义在函数外部的任意常量、变量。 这是一个例子，一个叫做 makeIncrementer 的函数内部包含了一个嵌套函数 incrementer 。嵌套函数 incrementer() 从它所在的上下文环境中，捕获了两个值，runningTotal 和 amount 。捕获这些值之后 incrementer 作为一个每调用一次就会让 runningTotal 和 amount 的值进行相加的闭包被 makeIncrementer 函数返回。12345678func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125; makeIncrementer 的返回值类型是 () -&gt; Int。这意味着它返回的是一个 函数，而不是一个简单的值。 这个函数没有参数，每次被调用后会返回一个 Int 类型的值。想了解一个函数如何返回其他函数，请参考 函数类型和返回值类型. makeIncrementer(forIncrement:) 这个函数定义了一个整型变量 runningTotal，用来存储将被返回的计算后的总和。这个变量的初始值是 0 。 makeIncrementer(forIncrement:) 函数有一个 Int 型的参数，参数标签是 forIncrement ，参数名是 amount 。传递给这个参数的参数值用来指定每一次增加函数被调用后 runningTotal 的值增加多少。 makeIncrementer 函数定义了一个名为 incrementer 的嵌套函数，这个函数用来执行具体的增加操作。这个函数只进行简单的相加，并将结果返回。 当单独来看 incrementer() 这个嵌套函数时，会觉得有点不可思议：1234func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal&#125; incrementer() 是一个无参数的函数，但是在它的函数体内却使用了 runningTotal 和 amount 这两个变量。通过从它周围的函数中将 runningTotal、 amount 这两个变量进行捕获，并在自己的函数内使用。 通过引用进行捕获来确保 makeIncrementer 函数调用结束后 runningTotal 和 amount 这两个变量不消失，同时也可以确保在下一次调用 incrementer 函数时 runningTotal 是可用的。 注意作为优化，如果一个值在闭包内没被修改，或闭包创建后该值没被修改，Swift 可能会替换捕获而是存储这个值的一个 拷贝。Swift 还会处理所有不再被使用的变量的内存管理问题。 这是一个 makeIncrementer 的例子：1let incrementByTen = makeIncrementer(forIncrement: 10) 这里定义了一个常量 incrementByTen，每次调用加数器函数都会将 10 和 runningTotal 变量的值相加，最后将函数的返回值赋值给常量 incrementByTen。多次调用这个函数的打印结果如下：123456incrementByTen()// 返回值是 10incrementByTen()// 返回值是 20incrementByTen()// 返回值是 30 如果你创建第二个加数器，它会存储一个新的、单独的 runningTotal 变量：123let incrementBySeven = makeIncrementer(forIncrement: 7)incrementBySeven()// 返回值是 7 继续调用原来的加数器（incrementByTen）会继续让它自己的 runningTotal 变量增加，不会影响到 incrementBySeven 捕获到的变量：12incrementByTen()// 返回值是 40 注意如果你将闭包作为一个类实例的属性，闭包通过引用该实例或其他成员来捕获该实例，在闭包和实例之间可能会导致循环引用。Swift 使用 捕获列表 来打断循环引用。更多信息请参考 闭包的循环引用 。 闭包引用类型在上面的例子中，incrementBySeven 和 incrementByTen 是常量，但是这些常量闭包仍然能够增加它们捕获到的 runningTotal 变量。这因为闭包和函数是 引用类型。 无论你分配变量还是常量给函数或闭包，实际上你是设置闭包或者函数引用该常量或变量。在上面的例子中，闭包 incrementByTen 选择 引用 的是常量，而不是闭包本身内容。 这也意味这如果你分配一个闭包两个不同的变量或常量, 这些常量和变量引用相同的闭包：123let alsoIncrementByTen = incrementByTenalsoIncrementByTen()// 返回值为 50 逃逸闭包当一个闭包作为参数传递给函数时，闭包被称为 逃逸 了函数，但是会在函数返回后才调用。当您声明将闭包作为参数之一的函数时，可以在参数的类型之前写入 @ escape，用来表示允许闭包逃逸。 有一种闭包可以逃逸的方式是存储在函数外定义的变量中。比如，许多有异步操作的函数以闭包参数作为 completion handler。函数在启动操作之后就已经返回，但在操作完成之后才调用闭包——这种闭包就需要需要逃逸，以便函数返回后调用。例如:1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; someFunctionWithEscapingClosure(_:) 函数将闭包作为它的参数，并且添加到函数之外的数组中。如果你不将函数中的这个参数标记为 @escaping，将为得到一个编译时的错误。 用 @escaping 标记闭包意味着你会在闭包中显式地使用 self。在刚才的例子中，传递给 someFunctionWithEscapingClosure(_:) 的是一个逃逸闭包，意味着需要显式地使用 self。相对来说，传给 someFunctionWithNonescapingClosure(_:) 的是一个非逃逸闭包，就意味着可以隐式地使用 self。1234567891011121314151617181920func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x)// 打印 "200"completionHandlers.first?()print(instance.x)// 打印 "100" 自动闭包自动闭包 自动包装书写的表达式，并将表达式作为一个闭包传入的函数。自动闭包不包含任何参数，当它被调用时会返回一个内部表达式包装的值。这种写法让你使用正常表达式而不是闭包的语法使你可以省略函数旁边的大括号。 调用 类型函数采用自动闭包是常见的，实现 该类型的函数并不常见。例如， assert(condition:message:file:line:) 方法为 condition 和 message 参数采用了自动闭包的写法，参数 condition 只在编译时取值，并且 message 参数只在 condition 参数为 false 时取值。 一个自动闭包能让我们延时取值，因为内部代码没有运行，直到你调用这个闭包。延时取值对于较大计算量和具有副作用的代码是非常有效的，因为这样能够让你去控制何时计算该代码，下面的代码展示了闭包如何延时计算：123456789101112var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]print(customersInLine.count)// 打印 "5"let customerProvider = &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count)// 打印 "5"print("Now serving \(customerProvider())!")// 打印 "Now serving Chris!"print(customersInLine.count)// 打印 "4" 尽管在闭包内部 customersInLine 的第一个元素被移除了，但是在闭包被调用之前，该元素是不会被移除。如果这个闭包永远不会被调用，那么这个闭包内部的表达式将永远不会执行，这意味着这个数组中的元素永远不会被移除。注意 customerProvider 不是一个 字符串 类型而是 () -&gt; String — 一个没有参数且返回值是字符串的函数。 当你将闭包作为参数传递给函数时，你能获得同样的延时求值行为：123456// customersInLine 数组是 ["Alex", "Ewa", "Barry", "Daniella"]func serve(customer customerProvider: () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: &#123; customersInLine.remove(at: 0) &#125; )// 输出 "Now serving Alex!" 上面代码中的 serve(customer:) 函数接受一个返回顾客姓名的显示闭包。下面这个版本的 serve(customer:) 完成同样的功能，不过它并没有接受一个显示闭包，而是接受一个自动闭包，使用 @autoclosure 关键字标记参数。现在你可以将这个函数当作一个接受 String 类型的参数的函数而不是一个闭包一样调用。这个参数会自动转换成一个闭包，因为参数 customerProvider 的类型被标记成 @autoclosure 属性。123456// customersInLine 数组是 ["Ewa", "Barry", "Daniella"]func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: customersInLine.remove(at: 0))// 输出 "Now serving Ewa!" 注意自动闭包使用过多会让你的代码很难阅读。 函数和上下文应该明确表明代码被延迟执行。 如果你想一个自动闭包也允许逃逸闭包的功能，你需要同时标记 @autoclosure 和 @escaping 关键字。123456789101112131415// customersInLine 数组值为 ["Barry", "Daniella"]var customerProviders: [() -&gt; String] = []func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123; customerProviders.append(customerProvider)&#125;collectCustomerProviders(customersInLine.remove(at: 0))collectCustomerProviders(customersInLine.remove(at: 0))print("Collected \(customerProviders.count) closures.")// 打印 "Collected 2 closures."for customerProvider in customerProviders &#123; print("Now serving \(customerProvider())!")&#125;// 打印 "Now serving Barry!"// 打印 "Now serving Daniella!" 在上边代码中，闭包作为 customerProvider 参数传入方法， collectCustomerProviders(_:) 函数为 customerProviders 数组拼接传入的闭包。数组 customerProviders 在函数外部定义，这意味着数组中的闭包允许在函数返回之后执行。综上所述，函数使用范围内必须允许 customerProvider 参数逃逸。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 函数]]></title>
    <url>%2F2018%2F10%2F10%2FSwift%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 是执行一个具体任务的一段独立代码块，你可以通过为函数命名来标识其任务功能，当需要执行这个任务时，函数名就可以用来「调用」该函数。 Swift 的统一的函数语法非常灵活，以致于从一个简单、无参数名的 C 风格函数，到一个复杂、多参数名的 Objective-C 风格方法都可以灵活表达。参数可以通过设置一个默认值，以简化函数的调用。 也可以传递可修改参数，一旦函数完成执行，传递的参数值就会被修改。 Swift 中的函数类型由参数值类型和返回值类型共同组成。你可以像其它类型一样来使用这个类型，这样把一个函数做为参数传递给另一个函数就会非常容易，并且可以从其它函数来返回函数。另外，一个封装了具体功能的函数能直接嵌套在另一个函数的代码块中。 函数的定义和调用在定义一个函数时，你可以可选地提供一个或多个输入值作为参数。当函数执行完成时，你也能可选地提供一个值作为返回值。 每一个函数的 函数名 描述了这个这个函数需要做的事情。你可以通过这个函数名去调用它并为它提供符合参数类型的参数值。 函数的实参值必须按形参的参数列表顺序依次传入。 下面我们定义一个 greet(person:) 方法 , 它表示向一个人打招呼， 它接受一个 String 类型的值做为输入并返回一个 String 类型的值 。1234func greet(person: String) -&gt; String &#123; let greeting = "Hello, " + person + "!" return greeting&#125; 函数名的定义应该清晰地指明这个函数的功能，函数的函数名前面必须要加 func 关键字。函数 -&gt; (向右的箭头) 后面是返回值，-&gt; 后面跟返回值的类型。 上面方法的方法名描述了这个方法要做的事情、需要的参数值和当执行完成时返回的值。在其他地方调用时，这个方法清晰的表达了它的作用1234print(greet(person: "Anna"))// Prints "Hello, Anna!"print(greet(person: "Brian"))// Prints "Hello, Brian!" 为了简化函数体书写，我们可以把消息的创建和返回合并在一条语句中:12345func greetAgain(person: String) -&gt; String &#123; return "Hello again, " + person + "!"&#125;print(greetAgain(person: "Anna"))// Prints "Hello again, Anna!" 函数的参数和返回值在 Swift 中，函数的参数和返回值是非常灵活的。你能定义任何事 无论是一个单一参数的简单函数 还是有着多个参数和不同参数选项的复杂函数。 无参函数函数可以没有参数。 下面是一个没有参数的函数，当调用时，它总是返回同一个 String 类型的值：12345func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125;print(sayHelloWorld())// Prints "hello, world" 多个参数函数也可以有多个参数，这些参数写在函数名后面的 () 内，参数之间通过 , 逗号分隔。 下面方法接受一个 String 类型的人名值和是否已经打过招呼的 Bool 值作为输入，返回一个给这个人打招呼的信息：123456789func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return greetAgain(person: person) &#125; else &#123; return greet(person: person) &#125;&#125;print(greet(person: "Tim", alreadyGreeted: true))// Prints "Hello again, Tim!" 无返回值函数函数也可以没有返回值。这个 greet(person:) 函数版本就没有返回值，而是将结果直接打印出来：12345func greet(person: String) &#123; print("Hello, \(person)!")&#125;greet(person: "Dave")// Prints "Hello, Dave!" 注意严格意义来说, greet(person:) 函数 仍然 返回一个值，只是这个返回值没有被定义。函数返回值没有定义时，默认是返回 Void 类型。它是一个简单的空元祖，可以被写做 () 。 调用函数时，它的返回值可以被忽略：1234567891011func printAndCount(string: String) -&gt; Int &#123; print(string) return string.count&#125;func printWithoutCounting(string: String) &#123; let _ = printAndCount(string: string)&#125;printAndCount(string: "hello, world")// prints "hello, world" and returns a value of 12printWithoutCounting(string: "hello, world")// prints "hello, world" but does not return a value 第一个函数 printAndCount(string:) 打印一个字符串，然后返回这个字符串的字符集数量。 第二个函数 printWithoutCounting(string:) 调用第一个函数，忽略了第一个函数的返回值。 所以当调用第二个函数时， 信息仍然被第一个函数打印了，但第一个函数的返回值确没被使用。 注意返回值可以被忽略， 但函数的返回值还是需要接收。 一个有返回值的函数的返回值不允许直接丢弃不接收，如果你尝试这样做，编译器将给你抛出错误。 多返回值函数你可以用一个元祖类型包装多个值来作为一个函数的返回值。 下面这个 minMax(array:) 函数，它找出参数数组中的最大整数和最小整数：123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 这个 minMax(array:) 函数返回一个包含了两个整型 Int 的元祖。 它们的键名分别是 Max 和 Min，所以你可以通过这个键名来访问这两个值。 minMax(array:) 方法先定义了两个变量 currentMin 和 currentMax ，分别存储这数组中第一个元素。 然后迭代数组，检查每一个值是否比最小值小或比最大值大，如果是则分别记录这个值。 最后，找出的最小值和最大值被包装在一个元祖中返回。因为这个元祖的成员值被作为函数返回值的一部分，最大值和最小值能通过点语法来直接被访问。123let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)")// Prints "min is -6 and max is 109" 注意这个从函数返回的元祖的成员不需要在被指定键名，因为它们的键名已经被作为函数返回类型的一部分而指定。 可选元祖返回类型如果从函数返回的元祖类型有可能为空， 你可以用一个可选元祖来指示这个返回值可能为 nil 。你可以在元祖返回类型后面加上一个 ? 问号来表示返回值可能为空， 例如 (Int, Int)? 或 (String, Int, Bool)?。 注意一个可选的元祖类型例如 (Int, Int)? 和元祖值可选例如 (Int?, Int?) 是不同的。 对于前者是整个元祖可能为空，而后者则是元祖内每一个独立的元素可能为空。 上面这个 minMax(array:) 函数返回了一个包含两个 Int 值的元祖。然而，这个函数没有对传递进来的数组进行任何安全性的检查。 如果这个数组为空， 这个 minMax(array:) 函数在尝试访问数组第一个元素时，将在运行时触发一个数组越界的错误。 为了处理空数组这种情况，将 minMax(array:) 方法的返回值标记为可选类型。如果数组为空，将返回 nil ：12345678910111213func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 你也能用可选值绑定的方法来检查 minMax(array:) 方法是否返回一个有效值：1234if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125;// Prints "min is -6 and max is 109" 函数的参数标签和参数名每一个参数都由一个 参数标签 和一个 参数名 构成。 参数标签被用在调这个方法时； 每一个参数标签写在参数的前面。参数名被用在函数的具体实现中。 默认参数的参数标签可以不写，用参数名来作为参数标签。1234func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // 在函数体内， 变量 firstParameterName 和 变量 secondParameterName 所对应的值分别是第一个和第二个参数传递进来的&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 所有的参数必须有一个唯一的名称。 尽管多个参数可以有相同的参数标签， 但唯一的参数标签将使你的代码可读性更好。 明确参数标签参数标签在参数名前面， 通过一个空格 来分隔：123func someFunction(argumentLabel parameterName: Int) &#123; // 在函数体内，变量 parameterName 的值对应是参数传递进来的&#125; 参数标签省略如果一个参数不需要参数标签，可以用下划线_ 来代替之前的参数标签。1234func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123; // 在函数体中，变量 firstParameterName 和 secondParameterName 分别对应第一个和第二个参数的值&#125;someFunction(1, secondParameterName: 2) 参数默认值你可以给函数的任何参数提供一个默认值，通过写在参数类型后面。 如果提供了默认值，你就可以在调用时省略给这个参数传值。12345func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // 调用时如果你没有给第二个参数传值，那么变量 parameterWithDefault 的值默认就是 12 。&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // 变量 parameterWithDefault 的值是 6someFunction(parameterWithoutDefault: 4) // 变量 parameterWithDefault 的值是 12 可变参数可变参数 接受 0 个或多个具体相同类型的值。调用时，你可以用一个可变参数来代表这些有着不确定数量的多个参数。在参数类型后面跟上 3 个点 ... 来表示参数的数量可变。 传入函数体内的可变参数可以被当做一个数组类型来使用。 下面这个例子中，变量名 numbers 表示的一系列可变参数（每一个的类型为 Double ）被合并成更合适的数组类型 [Double] 。 函数 arithmeticMean() 为传入的一系列数字计算出平均值：1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3，5 个数的平均值是 3arithmeticMean(3, 8.25, 18.75)// returns 10.0，3 个数的平均值是 10.0 注意一个函数至多只能有一个可变参数。 传入传出参数函数参数默认是常量，不能直接修改其值。编译器会报错如果你尝试在函数体内修改传入参数的值。 但如果你执意要修改这个参数值， 并希望在函数执行完成后修改的值仍然有效， 那么用 传入传出参数 来代替普通参数。 传入传出参数通过在参数类型前加上 inout 关键字来定义。传入传出参数可以有一个初始值， 传入函数后值将被修改，在函数执行完传出后，这个变量的初始值就会被替换完成。 更多有关传出传出参数的行为和编译器优化的详细讨论，请移步In-Out Parameters。 传入传出参数只支持变量。常量或字面量将不被允许做为参数传递，因为它们都不能被修改。 传值时，在参数名前面加上 &amp; 符号，来表示它能在函数体内被修改。 注意传入传出参数不能有默认值，并且可变参数也不能被标记 inout 。 下面这个 swapTwoInts(_:_:) 函数，有两个参数名分别为 a 和 b 的传入传出参数：12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoInts(_:_:) 函数简单地交换两个传入参数 a 和 b 的值。 首先将参数 a 的值存储于临时变量 temporaryA中，然后将 b 的值赋值给 a ， 最后将临时变量 temporaryA 的值再赋值给 b。 你可以通过传递两个Int类型的参数来调用swapTwoInts(_:_:)函数来交换彼此的值。 需要注意的是， 在调用 swapTwoInts(_:_:)方法时，变量 someInt 和 anotherInt 需要加上 &amp; 符号：12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// 打印 "someInt is now 107, and anotherInt is now 3" 上面这个例子中，即便变量 someInt 和 anotherInt 被定义在函数体外部，但通过参数传递，swapTwoInts(_:_:) 函数还是修改了彼此的初始值。 注意在同一个函数中，传入传出参数和返回值不一定要同时存在。上面这个例子中， swapTwoInts 函数没有返回值， 但变量 someInt 和 anotherInt 的初始值仍然被修改了。 传入传出参数为函数影响函数体外部的作用域提供了一种可选的方式。 函数类型每个函数的具体 函数类型 由它的参数类型和返回类型共同决定。 举个例子：123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 使用函数类型Swift 中，函数类型的使用和其他类型一样。 举个例子， 你可以定义 一个函数类型的常量或变量，并给其赋一个函数类型的值：1var mathFunction: (Int, Int) -&gt; Int = addTwoInts 你可以理解为： 『 定义了一个函数类型的 mathFunction 变量，「 它接收两个 Int 类型的参数，并返回一个 Int 值。」并把 addTwoInts 函数关联给这个变量。』 mathFunction 的类型和 addTwoInts(_:_:) 函数的类型相同，所以Swift 的类型检查器将允许这样的赋值。 现在，你就可以用 mathFunction 变量来调用 addTwoInts(_:_:) 函数了：12print("Result: \(mathFunction(2, 3))")// 打印 "Result: 5" 有着相同类型的不同方法可以赋值给同一个变量：123mathFunction = multiplyTwoIntsprint("Result: \(mathFunction(2, 3))")// 打印 "Result: 6" 像其他类型一样，当然你给一个变量或常量赋一个函数类型的值时， Swift 将帮你自动推导出值的真实类型：12let anotherMathFunction = addTwoInts// anotherMathFunction 被会自动推导成 `(Int, Int) -&gt; Int` 类型 函数类型作为参数你可以把 (Int, Int) -&gt; Int 类型的函数作为一个参数传递给另一个函数。 当这个函数被调用时，这使得具体实现逻辑被当做一个函数传递给了这个函数的调用者。 下面这个例子，打印 math functions 函数相加后的结果：12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// 打印 "Result: 8" 这个例子中， 定义了一个 printMathResult(_:_:_:) 的函数，它接收三个参数。第一个参数是一个叫 mathFunction的函数，其类型是 (Int, Int) -&gt; Int。 你可以为第一个参数传递一个类型是 (Int, Int) -&gt; Int 的函数作为参数。 第二个和第三个参数 a 和 b 都是 Int 类型。这两个变量被当做第一个函数参数的输入值传入给了第一个参数。 当调用 printMathResult(_:_:_:) 时，分别传递 addTwoInts(_:_:) 函数 和另外两个值 3 和 5。 3 和 5 被当做第一个函数的参数传递给它做了相加，最终打印结果 8。 函数 printMathResult(_:_:_:) 的作用是打印 addTwoInts(_:_:) 函数的返回值。 它不关心传入函数的具体实现 — 只关心传入函数的正确类型。 这使得 printMathResult(_:_:_:) 函数把一些具体的功能逻辑实现推给了它的调用者。 返回类型为函数类型你可以把一个函数类型作为另一个函数的返回类型。在这个返回箭头后面 (-&gt;) 跟上你要返回的具体函数类型。 下面这个例子分别定义了两个 stepForward(_:) 和 stepBackward(_:) 简单的函数。 stepForward(_:) 函数返回一个在其输入值上 +1 后的值， stepBackward(_:) 方法返回一个在其输入值上-1 后的值，两个方法的函数类型都是 (Int) -&gt; Int ：123456func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125; chooseStepFunction(backward:) 函数的返回类型是 (Int) -&gt; Int。 该函数根据一个 Bool 类型值来判断是返回 stepForward(_:) 还是 stepBackward(_:) 函数：123func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 现在你可以通过调用 chooseStepFunction(backward:) 并为其输入一个 Bool 类型的值来获得一个递增或递减的函数:123var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// 变量 moveNearerToZero 现在引用着 stepBackward() 函数 在上面这个例子中，最终返回递增还是递减函数由 currentValue 变量的值来决定。 变量 currentValue 的初始值是 3 ， currentValue &gt; 0 比较结果就为 true，所以调用 chooseStepFunction(backward:) 后返回 stepBackward(_:) 函数。 常量 moveNearerToZero存储着该函数的返回函数。 现在 moveNearerToZero 表示这个递减函数，从输入值递减至 0 ：1234567891011print("Counting to zero:")// Counting to zero:while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// 3...// 2...// 1...// zero! 嵌套函数到目前为止，在本章中你遇到的这些函数例子都是 全局函数 ， 它们被定义在全局作用域上。 当然，你也可以在函数体内定义一个函数，来做为该函数的 嵌套函数 。 虽然嵌套函数默认对函数体外部是透明的，但仍然可以被该函数调用。 函数也可以通过返回其内部的嵌套函数来使这个被嵌套的函数在外部作用域可以被使用。 你可以重写上面的 chooseStepFunction(backward:) 函数，来返回和使用其内部的嵌套函数：123456789101112131415161718func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// `moveNearerToZero` 变量引用着 `stepForward()` 函数while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// -4...// -3...// -2...// -1...// zero!]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 控制流]]></title>
    <url>%2F2018%2F10%2F09%2FSwift%E6%8E%A7%E5%88%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Swift 提供了多种控制流结构。其中包含 while 循环来执行多次任务； if、 guard 和 switch 语句来执行特定条件下不同的代码分支； 还有 break 和 continue 语句使控制流跳转到你代码中的其他位置。 Swift 还提供了 for-in 循环用来更简便的遍历数组（arrays）， 字典（dictionaries），区间（ranges），字符串（strings），和其他序列类型。 Swift 的 switch 语句比其他的类 C 语言更加强大。case 可以匹配多种不同的模式，包括间隔匹配（interval matches），元祖（tuples），和转换到特定类型。switch 语句的 case 体中匹配的值可以绑定临时常量或变量，在每个 case 中也可以使用 where 来实现更复杂的匹配情况。 For-In 循环可以使用 for-in 循环来遍历序列中的所有元素，例如数组中的所有元素，数字的范围，或者字符串的字符。 你也可以通过遍历一个字典来访问它的键值对。遍历字典时其中的每个元素都会返回成 (key, value) 元组（Tuple）的形式， 你也可以在 for-in 循环中显式的命名常量来分解 (key, value)元组。 在下面的例子中，字典中的值（Key）被分解为 animalName 常量，字典中的值（Value）被分解为 legCount 常量。1234567let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]for (animalName, legCount) in numberOfLegs &#123; print("\(animalName)s have \(legCount) legs")&#125;// ants have 6 legs// cats have 4 legs// spiders have 8 legs 上面的例子中，常数 index 的值在每次循环开始时都会自动赋值。因此，index 不需要在使用前进行声明。只要声明循环时，包含了该常量，就会对其进行隐式声明，不需要使用声明关键词 let 。 如果你不需要使用区间中的所有值，你可以使用 - 替代变量名来忽略对应的值。12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print("\(base) to the power of \(power) is \(answer)")// Prints "3 to the power of 10 is 59049" 在一些情况中你可能不想使用包含两个端点的闭区间。想象在手表表面上画每分钟的刻度标记。你想要从 0 分钟开始画 60 个刻度标记。可以使用半开区间操作符（..&lt;）来包含下界但不包含上界。1234let minutes = 60for tickMark in 0..&lt;minutes &#123; // 每分钟渲染一个刻度线（60 次）&#125; 一些用户在他们的界面上可能想要更少的刻度标记。他们可能更喜欢每 5 分钟一个刻度。使用 stride(from:to:by:) 函数可以跳过不需要的标记。1234let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) &#123; // 每 5 分钟打一个标记（0, 5, 10, 15 ... 45, 50, 55）&#125; 通过 stride(from:through:by:) 使用闭区间也是可以的：12345let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) &#123; // 每 3 小时打一个标记（3, 6, 9, 12）&#125; While 循环一个 while 循环会一直执行一组语句直到条件变为 false 。这类循环最适合第一次循环前不知道循环的次数的情况。Swift 提供两种类型的 while 循环： while 在每次循环开始时判断条件。 repeat-while 在每次循环结束时判断条件。 下方是 repeat-while 循环的一般形式：123repeat &#123; statements&#125; while condition 条件语句Swift 提供两种条件语句：if 语句和 switch 语句。通常，使用 if 语句来执行结果可能性较少的简单条件；switch 语句则更适合于有较多组合的更复杂的条件，而且，当需要使用模式匹配来判断执行合适的代码段时，switch 语句会更有用。 Ifif 语句最简单的形式只有一个 if 条件，而且只有当这个条件为 true 时才会执行对应的代码。 Switchswitch 语句会将某一个值与其它几种可能匹配的模式进行比较，然后它会执行第一个匹配成功的模式下对应的代码块。当可能的情形非常多时，应该使用 switch 语句替代 if 语句。 switch 语句最简单的形式是将一个值和另外一个或几个同类型的值进行比较。123456789switch some value to consider &#123;case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else&#125; 每个 switch 语句必须是 可穷尽的。 也就是说，判断的类型的每个可能的值都要有一个 switch 的分支（case）与之对应。为每个可能的值创建一个分支是不合理的，你可以定义一个默认分支来覆盖没有单独处理的其他所有值。这个默认分支使用 default 关键字声明，并且必须放在最后。 下面例子使用 switch 语句匹配名为 someCharacter 的单个小写字符：12345678910let someCharacter: Character = "z"switch someCharacter &#123;case "a": print("The first letter of the alphabet")case "z": print("The last letter of the alphabet")default: print("Some other character")&#125;// 打印 "The last letter of the alphabet" 不存在隐式的贯穿与 C 语言和 Objective-C 中的 switch 语句相反，Swift 中的 switch 语句在执行完一个分支后不会「贯穿」到下一个分支。相反，整个 switch 语句一旦完成第一个匹配的 switch 分支就会结束，而不需要明确的 break 语句。这使得 Swift 中的 switch 语句比 C 语言中的更加安全、易用，并且避免了错误地执行多个 switch 分支的情况。 注意虽然在 Swift 中 break 不是必须的，你可以使用 break 语句来匹配和忽略特定的分支或者或者在分支全部执行前跳出。更多细节，查看 Switch 语句中的 Break。 区间匹配 switch 中分支匹配的值也可以是一个区间。这个例子使用数字区间来匹配任意数字对应的自然语言格式：12345678910111213141516171819let approximateCount = 62let countedThings = "moons orbiting Saturn"let naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = "no"case 1..&lt;5: naturalCount = "a few"case 5..&lt;12: naturalCount = "several"case 12..&lt;100: naturalCount = "dozens of"case 100..&lt;1000: naturalCount = "hundreds of"default: naturalCount = "many"&#125;print("There are \(naturalCount) \(countedThings).")// Prints "There are dozens of moons orbiting Saturn." 元组你可以使用元组在同一个 switch 语句中测试多个值。可以针对不同的值或值的间隔来测试元组的每个元素。或者使用下划线（_）来匹配任何可能的值，这也被称为通配符模式。 下面的示例声明了一个 (x, y) 点，该变量是类型为 (Int, Int) 的元组，并将其显示在示例后面的图上。1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print("\(somePoint) is at the origin")case (_, 0): print("\(somePoint) is on the x-axis")case (0, _): print("\(somePoint) is on the y-axis")case (-2...2, -2...2): print("\(somePoint) is inside the box")default: print("\(somePoint) is outside of the box")&#125;// 打印 "(1, 1) is inside the box" 与 C 语言不同，Swift 允许同一个值符合多个 switch 分支。实际上，在这个例子中，点 (0, 0) 匹配所有四个分支。但是，如果匹配多个分支，则始终使用第一个匹配的分支。点 (0, 0) 首先匹配 case (0, 0)，因此所有其他的匹配分支都被忽略。 值绑定switch 分支可以将其匹配的一个值或多个值赋值给临时的常量或变量，常量或变量可以在 case 主体中使用。这个行为被称为值绑定，因为值在 case 主体中被绑定给临时的常量或变量。 下面的示例声明了一个 (x, y) 点，其类型为 (Int, Int) 的元组，并且该点展示在示例后面的图上：12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125;// 打印 "on the x-axis with an x value of 2" 三个 switch 分支声明了占位符常量 x 和 y，暂时从 anotherPoint 中获取一个或多个元组值。第一个分支 case (let x, 0) 匹配任何 y 值为 0 的点，并把 x 的值赋值给临时常量 x。同样地，第二个分支 case (0, let y) 匹配任何 x 值为 0 的点，并把 y 的值赋值给临时常量 y。 在声明临时常量之后，可以在 case 代码块中使用该常量。这里，它们用来打印点的分类。 这个 switch 语句没有 default 分支。在最后一个分支 case let (x, y) 中，声明了一个可以匹配任何值的有两个占位符常量的元组。因为 anotherPoint 是有两个值的元组，这个分支可以匹配剩余的任何值，并不需要 default 分支来使 switch 语句穷举。 Whereswitch 分支中可以使用 where 子句来检测额外的条件。12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("(\(x), \(y)) is just some arbitrary point")&#125;// 打印 "(1, -1) is on the line x == -y" 三个 switch 分支声明了占位符常量 x 和 y，它们从 yetAnotherPoint 中获取两个元组值。这些常量用作 where 子句的一部分，用来创建一个动态分类器。只有当 where 子句满足计算值为 true 时，switch 分支才匹配当前的 point。 与前一个示例一样，最后一个 case 匹配所有剩余的值，所以不需要 default 分支来使 switch 语句穷举。 复合分支在 case 后面写多个模式可以把多个分支共享在同一个主体中，每个模式用逗号隔开。如果任何一个模式匹配，那么这个分支就是匹配的。如果模式太多，可以把模式写为多行。比如：1234567891011let someCharacter: Character = "e"switch someCharacter &#123;case "a", "e", "i", "o", "u": print("\(someCharacter) is a vowel")case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z": print("\(someCharacter) is a consonant")default: print("\(someCharacter) is not a vowel or a consonant")&#125;// 打印 "e is a vowel" switch 语句的第一个分支匹配英语中的所有五个小写元音。同样，第二个分支匹配所有的小写辅音。最后，default 分支匹配其余字符。 复合分支也可以包含值绑定。复合分支的所有模式必须包含在同一组值绑定中，并且每个绑定必须从复合分支的所有模式中获取相同类型的值。这样确保无论复合分支中哪个部分匹配，分支主体的代码总是可以访问绑定的值，并且确保值总是有相同的类型。12345678let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print("On an axis, \(distance) from the origin")default: print("Not on an axis")&#125;// 打印 "On an axis, 9 from the origin" 上面的 case 中有两个模式：(let distance, 0) 匹配 x 轴上的点，(0, let distance) 匹配 y 轴上的点。两种模式都包含 distance 的绑定，distance 在两种模式中是一个整数，这意味着 case 主体中的代码总是可以访问 distance 的值。 控制转移语句控制转移语句通过将控制从一段代码转移到另一段代码来改变代码的执行顺序。Swift 中有五个控制转移语句： continue break fallthrough return throw Continuecontinue 语句告诉循环停止正在做的事情，并在循环的下一次迭代开始时再启动。它仿佛在说「我完成了当前的循环迭代」而没有完全离开循环。 下面的示例从小写字符串中删除所有的元音和空格，并创建一个神秘的谜语：123456789101112let puzzleInput = "great minds think alike"var puzzleOutput = ""let charactersToRemove: [Character] = ["a", "e", "i", "o", "u", " "]for character in puzzleInput &#123; if charactersToRemove.contains(character) &#123; continue &#125; else &#123; puzzleOutput.append(character) &#125;&#125;print(puzzleOutput)// 打印 "grtmndsthnklk" 上面的代码只要匹配到元音或空格时就调用 continue 关键字，使循环的本次迭代立即结束并跳到下一次迭代的开始。 Breakbreak 语句立即结束整个控制流语句的执行，当你想在 switch 或循环中提前结束时，可以在 switch 或循环中使用 break 语句。 在循环语句中使用 Break在循环语句中使用时，break 立即结束循环的执行，并把控制转移到循环右括号（}）后面的代码上。不执行来自当前循环迭代的下一步代码，并且不再开始循环的迭代。 在 Switch 语句中使用 Break在 switch 语句中使用时，break 会使 switch 语句立即结束执行，并把控制转移到 switch 语句的右括号（}）后面的代码上。 此行为可用于匹配和忽略 switch 语句中的一个或多个分支。 因为 Swift 的 switch 语句是穷举的并且不允许空分支，所以有时需要故意匹配并忽略一个分支使你的意图明确。 你可以将 break 语句作为要忽略的分支的整个主体来使用。当该分支与 switch 语句匹配时，分支中的 break 语句使 switch 语句立即结束执行。 注意如果 switch 分支只包含注释会报编译时错误。 注释不是语句，不会使 switch 分支被忽略。总是使用 break 语句来忽略 switch 分支。 贯穿在 Swift 中， switch 语句的每个分支在判断结束后不会「贯穿」到下一个分支。即，整个 switch 语句会在第一个匹配的分支语句执行完成后终止。相反地，C 语言明确要求在每个 switch 分支结束时手动添加 break 语句来防止贯穿。相对而言，默认没有贯穿使得 Swift 中的 switch 语句更加简洁，可读性更强，并可以因此避免错误地执行多个 switch 分支。 如果需要像 C 语言中那样的贯穿行为，你可以在分支中逐个添加 fallthrough 关键字。 下面这个例子就利用了贯穿 fallthrough 来给数字添加描述。1234567891011let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;print(description)// 打印 "The number 5 is a prime number, and also an integer." 注意 fallthrough 关键字不会检查 switch 语句中下一个分支的条件，它只是让代码在执行的过程中直接进入下一个分支 (或 default 分支) 中的语句, 就像 C 语言中 switch 语句的标准行为。 带标签语句在 Swift 中，你可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用 break 语句来提前结束整个代码块。因此，显式地指明 break 语句想要终止的是哪个循环体或者条件语句，会很有用。类似地，如果你有许多嵌套的循环体，显式指明 continue 语句想要影响哪一个循环体也会非常有用。 为了实现这个目的，你可以使用标签（ statement label ）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用 break 加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用 break 或者 continue 加标签，来结束或者继续这条被标记语句的执行。 声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键字（ introducor keyword ），并且该标签后面跟随一个冒号。下面是一个针对 while 循环体的标签语法，同样的规则适用于所有的循环体和条件语句。123label name: while condition &#123; statements&#125; 提前退出guard 语句和 if 语句一样，根据表达式的布尔值执行语句。 使用 guard 语句要求条件必须为真才能执行 guard 语句之后的代码。 和 if 语句不同，guard 语句总是有一个 else 分支 — 如果条件不为真，则执行 else 分支中的代码。123456789101112131415161718192021func greet(person: [String: String]) &#123; guard let name = person["name"] else &#123; return &#125; print("Hello \(name)!") guard let location = person["location"] else &#123; print("I hope the weather is nice near you.") return &#125; print("I hope the weather is nice in \(location).")&#125;greet(person: ["name": "John"])// 打印 "Hello John!"// 打印 "I hope the weather is nice near you."greet(person: ["name": "Jane", "location": "Cupertino"])// 打印 "Hello Jane!"// 打印 "I hope the weather is nice in Cupertino." 如果满足 guard 语句的条件，则在 guard 声明的结束括号后继续执行代码。 当任何变量或常量在使用可选绑定作为条件被赋值后，它的值都可用于 guard 语句后的其余代码块。 如果不满足该条件，则执行 else 分支内的代码。 该分支必须转移控制以退出 guard 语句后的代码块。 它可以通过控制转移语句来执行此操作，例如 return ， break ， continue 或 throw ，也可以调用一个无返回值的函数或方法，例如 fatalError(_:file:line:) 。 相比于使用 if 语句进行判断，使用 guard 语句可以提高代码的可读性。 它可以让你编写出连贯执行的代码，而不必将其包装在 else 块中，并且让你更加从容地处理异常代码。 检测 API 可用性Swift 内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的 API。 编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。 我们在 if 或 guard 语句中使用 可用性条件（availability condition)去有条件的执行一段代码，来在运行时判断调用的 API 是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。12345if #available(iOS 10, macOS 10.12, *) &#123; // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API&#125; else &#123; // 使用先前版本的 iOS 和 macOS 的 API&#125; 以上可用性条件指定， if 语句的代码块仅仅在 iOS 10 或 macOS 10.12 及更高版本才运行。最后一个参数，*，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本， if 语句的代码块将会运行。 在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是 iOS , macOS , watchOS , 和 tvOS —请访问声明属性来获取完整列表。 请参阅 Declaration Attributes。除了指定像 iOS 8 或 macOS 10.10 的大版本号，也可以指定像 iOS 11.2.6 以及 macOS 10.13.3 的小版本号。12345if #available(platform name version, ..., *) &#123; APIs 可用，语句将执行&#125; else &#123; APIs 不可用，语句将不执行&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 集合类型]]></title>
    <url>%2F2018%2F10%2F08%2FSwift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 注意Swift 的 Arrays、Sets 和 Dictionaries 类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章节。 集合的可变性如果创建一个 Arrays、Sets 或 Dictionaries 并且把它分配成一个变量，这个集合将会是可变的。这意味着你可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 Arrays、Sets 或 Dictionaries 分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。 注意在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。 数组数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。 注意Swift 的 Array 类型被桥接到 Foundation 中的 NSArray 类。 创建一个空数组我们可以使用构造语法来创建一个由特定数据类型构成的空数组：123var someInts = [Int]()print("someInts is of type [Int] with \(someInts.count) items.")// 打印 "someInts is of type [Int] with 0 items." 创建一个带有默认值的数组Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（ count）和适当类型的初始值（ repeating）传入数组构造函数：12var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0] 通过两个数组相加创建一个数组我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：12345var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 用数组字面量构造数组我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：1[value 1, value 2, value 3] 访问和修改数组我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。 可以使用数组的只读属性 count 来获取数组中的数据项数量：123var shoppingList = ["Eggs", "Milk"]print("The shopping list contains \(shoppingList.count) items.")// 输出 "The shopping list contains 2 items."（这个数组有2个项） 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0：123456if shoppingList.isEmpty &#123; print("The shopping list is empty.")&#125; else &#123; print("The shopping list is not empty.")&#125;// 打印 "The shopping list is not empty."（shoppinglist 不是空的） 也可以使用 append(_:) 方法在数组后面添加新的数据项：12shoppingList.append("Flour")// shoppingList 现在有3个数据项，有人在摊煎饼 除此之外，使用加法赋值运算符（+=）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：1234shoppingList += ["Baking Powder"]// shoppingList 现在有四项了shoppingList += ["Chocolate Spread", "Cheese", "Butter"]// shoppingList 现在有七项了 可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：12var firstItem = shoppingList[0]// 第一项是 "Eggs" 您也可以使用下标语法来同时更改一系列值，即使替换值集的长度与所替换的范围不同。下面的例子用 Bananas 和 Apples 取代了Chocolate Spread，Cheese 和 Butter：12shoppingList[4...6] = ["Bananas", "Apples"]// shoppingList 现在有6项 调用数组的 insert(_:at:) 方法来在某个具体索引值之前添加数据项：123shoppingList.insert("Maple Syrup", at: 0)// shoppingList 现在有7项// "Maple Syrup" 现在是这个列表中的第一项 类似的我们可以使用 remove(at:) 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：1234let mapleSyrup = shoppingList.remove(at: 0)// 索引值为0的数据项被移除// shoppingList 现在只有6项，而且不包括 Maple Syrup// mapleSyrup 常量的值等于被移除数据项的值 "Maple Syrup" 注意如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的 count 属性进行比较来在使用某个索引之前先检验是否有效。除了当 count 等于 0 时（说明这是个空数组），最大索引值一直是 count -1 ，因为数组都是零起索引。 如果我们只想把数组中的最后一项移除，可以使用 removeLast() 方法而不是 remove(at:) 方法来避免我们需要获取数组的 count 属性。就像后者一样，前者也会返回被移除的数据项，类似于remove(at:)方法,removeLast()返回被删除的项。1234let apples = shoppingList.removeLast()// 数组的最后一项被移除了// shoppingList 现在只有5项，不包括 Apples// apples 常量的值现在等于 "Apples" 字符串 数组的遍历我们可以使用 for-in 循环来遍历所有数组中的数据项：123for item in shoppingList &#123; print(item)&#125; 如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。 enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：12345678for (index, value) in shoppingList.enumerated() &#123; print("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 集合（Sets）集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。 注意Swift 的 Set 类型被桥接到 Foundation’s 中的 NSSet 类。关于使用 Foundation 和 Cocoa 中 Set的知识，参见Bridging Between Set and NSSet。 集合类型的哈希值一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 Int 类型的，相等的对象哈希值必须相同，比如 a == b ,因此必须 a.hashValue == b.hashValue。 Swift 的所有基本类型（比如 String、Int、Double 和 Bool ）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值（在枚举有讲述）默认也是可哈希化的。(https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html) 注意你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 Hashable 协议。符合 Hashable 协议的类型需要提供一个类型为 Int 的可读属性 Hashable 。由类型的 Hashable 属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。因为 Hashable 协议符合 Equatable 协议，所以遵循该协议的类型也必须提供一个是否相等运算符（==）的实现。这个 Equatable 协议要求任何符合 == 实现的实例间都是一种相等的关系。也就是说，对于 a, b, c三个值来说，== 的实现必须满足下面三种情况：a == a (自反性)a == b 意味着 b == a (对称性)a == b &amp;&amp; b == c 意味着 a == c (传递性) 集合类型语法Swift 中的 Set 类型被写为 Set&lt;Element&gt; ，这里的 Element 表示 Set 中允许存储的类型，和数组不同的是，集合没有等价的简化形式。 创建和构造一个空的集合你可以通过构造器语法创建一个特定类型的空集合：123var letters = Set&lt;Character&gt;()print("letters is of type Set&lt;Character&gt; with \(letters.count) items.")// 打印 "letters is of type Set&lt;Character&gt; with 0 items." 此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的 Set：1234letters.insert("a")// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型 用数组字面量创建集合你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。 下面的例子创建一个称之为 FavoriteGenres 的集合来存储 String 类型的值：12var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"]// favoriteGenres 被构造成含有三个初始值的集合 由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个 Set 并且该数组字面量中的所有元素类型相同，那么你无须写出 Set 的具体类型。 FavoriteGenres 的构造形式可以采用简化的方式代替：1var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"] 访问和修改一个集合你可以通过 Set 的属性和方法来访问和修改一个 Set。 为了找出一个 Set 中元素的数量，可以使用其只读属性 count 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 你可以通过调用 Set 的 insert(_:) 方法来添加一个新元素 你可以通过调用 Set 的 remove(_:) 方法去删除一个元素，如果该值是该 Set 的一个元素则删除该元素并且返回被删除的元素值，否则如果该 Set 不包含该值，则返回 nil 。另外，Set 中的所有元素可以通过它的 removeAll() 方法删除。 使用 contains(_:) 方法去检查 Set 中是否包含一个特定的值 遍历一个集合你可以在一个 for-in 循环中遍历一个 Set 中的所有值。 Swift 的 Set 类型没有确定的顺序，为了按照特定顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符&lt;对元素进行比较的结果来确定。 集合操作你可以高效地完成 Set 的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。 基本集合操作下面的插图描述了两个集合a和b以及通过阴影部分的区域显示集合各种操作的结果。 使用 intersection(_:) 方法根据两个集合中都包含的值创建的一个新的集合。 使用 symmetricDifference(_:) 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。 使用 union(_:) 方法根据两个集合的值创建一个新的集合。 使用 subtracting(_:) 方法根据不在该集合中的值创建一个新的集合。123456789101112let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9] 集合成员关系和相等下面的插图描述了三个集合 a 、 b 和 c ,以及通过重叠区域表述集合间共享的元素。集合 a 是集合 b 的父集合，因为 a 包含了 b 中所有的元素，相反的，集合 b 是集合 a 的子集合，因为属于 b 的元素也被 a 包含。集合 b 和集合 c 彼此不关联，因为它们之间没有共同的元素。 使用是否相等运算符（==）来判断两个集合是否包含全部相同的值。 使用 isSubset(of:) 方法来判断一个集合中的值是否也被包含在另外一个集合中。 使用 isSuperset(of:) 方法来判断一个集合中包含另一个集合中所有的值。 使用 isStrictSubset(of:) 或 isStrictSuperset(of:) 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。 使用 isDisjoint(with:) 方法来判断两个集合是否不含有相同的值（是否没有交集）。 12345678910let houseAnimals: Set = ["🐶", "🐱"]let farmAnimals: Set = ["🐮", "🐔", "🐑", "🐶", "🐱"]let cityAnimals: Set = ["🐦", "🐭"]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true 字典字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。 注意Swift 的 Dictionary 类型被桥接到 Foundation 的 NSDictionary 类。更多关于在 Foundation 和 Cocoa 中使用 Dictionary 类型的信息，请参阅 Bridging Between Dictionary and NSDictionary. 字典类型简化语法Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型， Value 是字典中对应于这些键所存储值的数据类型。 注意一个字典的 Key 类型必须遵循 Hashable 协议，就像 Set 的值类型。 我们也可以用 [Key: Value] 这样简化的形式去创建一个字典类型。并且这也是我们的首选方式。 创建一个空字典我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：12var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典 如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作 [:] （中括号中放一个冒号）：1234namesOfIntegers[16] = "sixteen"// namesOfIntegers 现在包含 1 个键值对namesOfIntegers = [:]// namesOfIntegers 又是一个空的 [Int: String] 类型字典 用字典字面量创建字典一个键值对是一个 key 和一个 value 的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：1[key 1: value 1, key 2: value 2, key 3: value 3] 访问和修改字典我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。 和数组一样，我们可以通过字典的只读属性 count 来获取某个字典的数据项数量 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：123var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]airports["LHR"] = "London"// airports 字典现在包含 3 个元素 还可以使用下标语法来更改特定键相关联的值：12airports["LHR"] = "London Heathrow"// LHR 应的值被改为 "London Heathrow" 作为另一种下标方法，字典的 updateValue(_:forKey:) 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例， updateValue(_:forKey:) 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的， updateValue(_:forKey:) 这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。 updateValue(_:forKey:) 方法会返回对应值的类型的可选值。举例来说：对于存储 String 值的字典，这个函数会返回一个 String 或者可选 String 类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 nil。1234if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; print("The old value for DUB was \(oldValue).")&#125;// 打印 "The old value for DUB was Dublin." 我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回 nil：123456if let airportName = airports["DUB"] &#123; print("The name of the airport is \(airportName).")&#125; else &#123; print("That airport is not in the airports dictionary.")&#125;// 打印 "The name of the airport is Dublin Airport." 我们还可以使用下标语法来通过给某个键的对应值赋值为 nil 来从字典里移除一个键值对：1234airports["APL"] = "Apple International"//"Apple Internation" 不是真的 APL 机场，删除它airports["APL"] = nil// APL 现在被移除了 此外， removeValue(forKey:) 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回 nil ：123456if let removedValue = airports.removeValue(forKey: "DUB") &#123; print("The removed airport's name is \(removedValue).")&#125; else &#123; print("The airports dictionary does not contain a value for DUB.")&#125;// 打印 "The removed airport's name is Dublin Airport." 字典遍历我们可以使用 for-in 循环来遍历某个字典中的键值对。每一个字典中的数据项都以 (key, value) 元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：12345for (airportCode, airportName) in airports &#123; print("\(airportCode): \(airportName)")&#125;// YYZ: Toronto Pearson// LHR: London Heathrow 通过访问 keys 或者 values 属性，我们也可以遍历字典的键或者值：1234567891011for airportCode in airports.keys &#123; print("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123; print("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受 Array 实例的 API 的参数，可以直接使用 keys 或者 values 属性构造一个新数组：12345let airportCodes = [String](airports.keys)// airportCodes 是 ["YYZ", "LHR"]let airportNames = [String](airports.values)// airportNames 是 ["Toronto Pearson", "London Heathrow"] Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 keys 或 values 属性使用 sorted() 方法。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 字符串和字符]]></title>
    <url>%2F2018%2F10%2F07%2FSwift%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Swift中的字符串都是String类型的，字符是Character类型，看似简单，其中的细节可不少(•́ω•̀ ٥) Swift 字符串是由 String 类型来表示。 String 的内容可以用多种方式读取，包括作为一个 Character 值的集合。 注意Swift 的字符串类型与 Foundation 的 NSString 类型进行了无缝桥接。 Foundation 也可以对 String 进行扩展，暴露在 NSString 中定义的方法。 这就意味着，你可以不用进行类型转换，就能在 String 中调用 NSString 的这些方法。更多关于在 Foundation 和 Cocoa 中使用 String 的信息，查看 Bridging Between String and NSString 。 初始化一个空字符串创建一个空 String 有两种方式，给一个变量赋值一个空字符串或者使用下面的语法初始化一个 String 实例对象：123var emptyString = "" // 空字符串var anotherEmptyString = String() // 初始化语法//这是两个空字符串，他们等价 可以通过检查 String 的布尔类型的属性 isEmpty 来判断该字符串的值是否为空：1234if emptyString.isEmpty &#123; print("Nothing to see here")&#125;// 打印 "Nothing to see here" 字符串是值类型Swift 中的 String 类型是一种 值类型 。如果你创建了一个新的 String 值， String 值在传递给方法或者函数时会被 拷贝，在给常量或者变量赋值的时候也是一样。在任何情况下，都会对现存的 String 值创建新拷贝，并对新拷贝进行传递或赋值操作。值类型在 结构体和枚举是值类型 中有详细描述。 Swift 默认 String 拷贝的行为是为了保证在函数或方法中传递的是 String 值，不管该值是从哪里来，你都绝对拥有这个 String 值。你可以确定你传递的这个字符串不会被修改，除非你自己去修改它。 另一方面，Swift 编译器优化了字符串的使用，实际拷贝只会在需要的时候才进行。这意味着你把字符串当做值类型的同时也能够得到很棒的性能。 使用字符你可以使用 for-in 循环来遍历 String 中每个的 Character 的值：123for character in "Dog!🐶" &#123; print(character)&#125; 你可以使用 Character 类型声明，并赋值一个单字符值创建一个独立的字符常量或变量：1let exclamationMark: Character = "!" String 的值可以使用一个 Character 值类型的数组作为变量来进行初始化：1234let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]let catString = String(catCharacters)print(catString)// 输出 "Cat!🐱" 字符串和字符的拼接可以使用加号（ + ）将 String 的值加（或 拼接 ）在一起创造出一个新的值 你可以使用加等于赋值符号（ += ）将一个 String 的值追加到一个已经存在的 String 变量中 你可以使用 String 的 append() 方法将一个 Character 的值追加到一个 String 变量中 注意你不能将字符串 String 或字符 Character 拼接到 Character 变量中，因为 Character 的值只能包含单个字符。 字符计数在一个字符串中使用 count 属性去计算 Character 类型值个数 注意，Swift 对 Character 类型值使用了拓展字母集，意味着字符串的拼接和修改不一定会持续影响字符串字符个数。 例如，你初始化一个拥有四个字符的字符串 cafe，然后再追加一个 COMBINING ACUTE ACCENT (U+0301) 字符在末尾 ，最终形成的字符串还是拥有四个字符，并且最后一个字符是 é，而不是 e：12345678var word = "cafe"print("the number of characters in \(word) is \(word.count)")// 打印 "the number of characters in cafe is 4"word += "\u&#123;301&#125;" // 拼接重音符，U+0301print("the number of characters in \(word) is \(word.count)")// 打印 "the number of characters in café is 4" 注意拓展字母集可以由多个不同的 Unicode 标量组成，这就意味着相同字符和相同字符的不同表示需要占据不同的内存空间去存储，因此，在字符串的各种表示中 Swift 字符占据的内存并不一样。造成的结果就是，字符串的字符数量并不能通过遍历该字符串去计算，并用于确定该字符串的拓展字符集边界。如果你正在处理特别长的字符串，要意识到为了确定该字符串的字符个数， count 属性必须要遍历完整个字符串中的全部 Unicode 标量。 count 属性返回的字符个数不会一直都与包含相同字符的 NSString 的 length 属性返回的字符个数相同。 NSString 的长度是基于 UTF-16 表示的字符串所占据的 16 位代码单元的个数决定，而不是字符串中的拓展字母集个数决定。 访问和修改字符串你可以通过字符串的方法和属性来访问和修改它，或者通过下标语法。 字符串索引每个 String 值都有一个关联的 索引类型， String.Index，对应着字符串中每个 Character 的位置。 正如上面提到的，不同的字符可能需要不同大小的内存存储，所以为了确定每个 Character 的具体位置，你必须从 String 的开头遍历每个 Unicode 标量到结束。因此，Swift 字符串不能使用整型值索引。 使用 startIndex 属性可以访问 String 的第一个 Character 的位置。使用 endIndex 属性可以访问 String 的最后一个 Character 的位置。因此， endIndex 属性并不是字符串下标的有效参数。如果 String 是空串， startIndex 和 endIndex 就是相等的。 你可以通过使用 String 的 index(before:) 和 index(after:) 方法，访问给定索引的前一个和后一个索引。要访问离给定索引偏移较多的索引，你可以使用 index(_:offsetBy:) 方法，避免多次调用 index(before:) 和 index(after:) 方法。 使用 indices 属性会创建一个包含全部索引的范围，用来在一个字符串中访问单个字符。1234for index in greeting.indices &#123; print("\(greeting[index]) ", terminator: "")&#125;// 打印 "G u t e n T a g ! " 注意你可以在任意一个遵循 Collection 协议的类型里面，使用 startIndex 和 endIndex 属性或者 index(before:) ， index(after:) 和 index(_:offsetBy:) 方法。如上文所示是使用在 String 中，你也可以使用在 Array 、Dictionary 和 Set 中。 插入和删除在一个字符串指定位置插入单个字符，使用 insert(:at:) 方法，而要插入另一个字符串的内容时，使用 insert(contentsOf:at:) 方法。 删除一个字符串指定位置的单个字符，用 remove(at:) 方法，而要删除指定范围的子字符串时，用 removeSubrange(_:) 注意你可以在任何遵循 RangeReplaceableCollection 协议的类型上使用 insert(_:at:)， insert(contentsOf:at:)，remove(at:)，和 removeSubrange(_:) 方法。除了这里说到的 String，还包括 Array，Dictionary，和 Set 等集合类型。 子字符串当你从字符串中获取一个子字符串 —— 例如使用下标或者 prefix(_:) 之类的方法 —— 就可以得到一个 Substring 的 实例 ，而非另外一个 String 。Swift 里的 Substring 的绝大部分函数都跟 String 一样，意味着你可以使用同样的方式去操作 Substring 和 String 。然而，跟 String 不同的是，你只有在短时间内需要操作字符串时，才会使用 Substring 。当你需要长时间保存结果时，就把 Substring 转化为 String 的实例：1234567let greeting = "Hello, world!"let index = greeting.firstIndex(of: ",") ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值是 "Hello"// 把结果转化为 String 以便长期存储。let newString = String(beginning) 就像 String ，每一个 Substring 都会在内存里保存字符集。而 String 和 SubString 的区别在于性能优化上，Substring 可以重用原 String 的内存空间，或者另一个 Substring 的内存空间（String 也有同样的优化，但如果两个 String 共享内存的话，它们就会相等）。这一优化意味着你在修改 String 和 Substring 之前都不需要消耗性能在内存复制。就像前面说的那样，Substring 不适合长期存储 —— 因为它重用了原 String 的内存空间，原 String 的内存空间必须保留直到它的 Substring 不再被使用为止。 上面的例子， greeting 是一个 String，意味着它在内存里有一片空间保存字符集。而由于 beginning 是 greeting 的 Substring，它重用了 greeting 的内存空间。相反，newString 是一个 String —— 它是使用 Substring 创建的，拥有一片自己的内存空间。下面的图展示了他们之间的关系： 注意 String 和 Substring 都遵循 StringProtocol协议， 这意味着操作字符串的函数使用 StringProtocol 会更加方便。你可以传入 String 或 Substring 去调用函数。 比较字符串Swift 提供了三种方式来比较文本值: 字符串和字符相等、前缀相等、后缀相等。 字符串和字符相等如果他们的扩展字形集是 统一码等价，则这两个 String 值 (或者两个 Character 值) 被认为是等同的。如果它们具有相同的语言含义和外观，即使它们是由不同语义的 Unicode 标量组成，扩展字形集也是等同的。 例如，LATIN SMALL LETTER E WITH ACUTE (U+00E9) 在规范上等同于 LATIN SMALL LETTER E (U+0065) 加上 COMBINING ACUTE ACCENT (U+0301)。这两个扩展字形簇都是表示字符 é 的有效方法，因此它们被认为是规范等价的 相反，英文中的 LATIN CAPITAL LETTER A (U+0041，或 「A」)，和俄文中的 CYRILLIC CAPITAL LETTER A (U+0410, 或 「А」) 不相等。这两个字符在视觉上相似，但具有不同的语言含义 注意Swift 中的字符串和字符比较不是区域敏感的。 前缀和后缀比较可以使用字符串的 hasPrefix(_:) 和 hasSuffix(_:) 方法来检查一个字符串是否有特定的前缀、后缀。这两个方法接收一个 String 类型的参数返回一个布尔值。 注意 hasPrefix(_:) 和 hasSuffix(_:) 方法都是在每个字符串的扩展字符集中逐个字符进行比较， 如本文所述 字符串和字符的比较。 字符串的 Unicode 表示形式当一个 Unicode 字符串被写入文本文件或者一些其他存储时，字符串中的 Unicode 标量会用 Unicode 定义的几种 编码格式 编码。每一个字符串中的小块编码都叫做 代码单元。这些包括 UTF-8 编码格式 (编码字符串为 8 位的代码单元），UTF-16 编码格式 (编码字符串为16位的代码单元) ， 以及 UTF-32 编码格式 (编码字符串32位的代码单元) 。 Swift 提供几种不同的方式来访问字符串的 Unicode 表现形式。 你可以使用 for - in 对字符串进行便利， 进而访问其中单个 Character 字符值作为 Unicode 扩展的字符群集。 这个过程描述在 使用字符。 另外，也可以通过其他三种 Unicode 兼容的方式访问字符串的值： UTF-8 代码单元集合（利用字符串的 utf8 属性进行访问） UTF-16 代码单元集合 （利用字符串的 utf16 属性进行访问） 21 位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式（利用字符串的 unicodeScalars 属性进行访问）下面有 D ，o ，g , !! （DOUBLE EXCLAMATION MARK ，或Unicode 标量 U+203C ）和 🐶（DOG FACE，Unicode 标量为 U+1F436）组成的字符串中的每一个字符代表着一种不同的表示：1let dogString = "Dog‼🐶" UTF-8 表示形式你可以通过遍历 String 的 utf8 属性来访问他的 UTF-8 表示。这个属性是 string.UTF8View 类型的，UTF8View 是无符号 8 位（ UInt8 ）值得集合，每一个字节都对应一个字符串的 UTF-8 的表现形式： 12345for codeUnit in dogString.utf8 &#123; print("\(codeUnit) ", terminator: "")&#125;print("")// 打印 "68 111 103 226 128 188 240 159 144 182 " 上面的例子中，前三个 10 进制 codeUnit 值（68，111，103）代表了字符 D o 和 g ，他们的 UTF-8 表示和 ASCII 表示相同。接下来的三个 10 进制 codeUnit 值（226，128, 188）是 DOUBLE EXCLAMATION MARK 的 3 字节 UTF-8 表示形式。 最后四个 codeUnit 值 (240, 159, 144, 182) 是 DOG FACE 的 4 字节 UTF-8 表示形式。 UTF-16 表示形式你可以通过遍历 String 的 utf16 属性来访问它的 UTF-16 表示形式。它是 String.UTF16View 类型的属性, 它是一个无符号 16 位 (UInt16) 值的集合，每一个 UInt16 都是一个字符的 UTF-16 表示形式: 12345for codeUnit in dogString.utf16 &#123; print("\(codeUnit) ", terminator: "")&#125;print("")// 打印 "68 111 103 8252 55357 56374 " 同样，前三个 codeUnit 值 (68, 111, 103) 代表了字符 D, o, 和 g, 他们的 UTF-16 代码单元和 UTF-8 完全相同 (因为这些 Unicode 标量表示 ASCII 字符)。 第四个 codeUnit 值 (8252) 是一个等于十六进制 203C 的十进制值，这代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量值 U+203C 。这个字符在 UTF-16 中可以用一个代码单元表示。 第五个和第六个 codeUnit 值 (55357 和 56374) 是 DOG FACE 字符的 UTF-16 表示形式。 第一个值为 U+D83D (十进制值为 55357 ) 第二个值为 U+DC36 (十进制值为 56374 )。 Unicode 标量表示形式你可以通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示。 它是一个 UnicodeScalarView 类型的属性, UnicodeScalarView 是 UnicodeScalar 类型的值得集合。 每一个 UnicodeScalar都有一个 value属性，可以返回对应的 21 位数值，用 UInt32 值来表示: 12345for scalar in dogString.unicodeScalars &#123; print("\(scalar.value) ", terminator: "")&#125;print("")// 打印 "68 111 103 8252 128054 " 前三个 UnicodeScalar 值 (68, 111, 103) 的 Value 属性依旧代表着字符 D, o, and g。 第四个 codeUnit 值 (8252) 依旧是一个等于十六进制 203C 的十进制值, 这代表了 DOUBLE EXCLAMATION MARK字符的 Unicode 标量 U+203C。 第五个 UnicodeScalar 值的 Value 属性, 128054, 是一个十六进制 1F436 的十进制表现, 它代表 DOG FACE 字符的 Unicode 标量 U+1F436。 作为查询他们的 value属性的一种替代方法, 每一个 UnicodeScalar 值也可以用来构建一个新的 String 值, 比如在字符串插值中使用:12345678for scalar in dogString.unicodeScalars &#123; print("\(scalar) ")&#125;// D// o// g// ‼// 🐶]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>字符串</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 基本运算符]]></title>
    <url>%2F2018%2F10%2F06%2FSwift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Swift 支持大多数标准 C 语言运算符，并改进了一些功能，很简单(´･(00)･｀) 基本运算符Swift 支持大多数标准 C 语言运算符，并改进了一些功能以消除常见的编码错误。为防止误用等号运算符 (==)， 赋值运算符 (=)并不返回值。为了避免数值在计算时超出它们类型允许值的范围，出现意外结果，算术运算符 (+, -, *, /, % 等) 会检测且不允许值溢出。你可以使用 Swift 值溢出运算符来选择值溢出行为，相关描述请参见 溢出运算符。 Swift 还提供了 C 语言中不存在的范围运算符，如 a..&lt;b 和 a...b ，作为表示区间值的快捷方式。 术语运算符分为一元的、二元的和三元的： 一元 运算符运算单个目标值（例如 -a ）。一元 前缀 运算符显示在目标值之前（例如 !b），而一元 后缀 运算符显示在目标值之后（例如 c!）。 二元 运算符运算两个目标值（例如 2 + 3）并且是 中缀的 因为它们显示在两个目标值之间。 三元 运算三个目标值。像 C ， Swift 只有一个三元运算符，就是三元条件运算符（a ? b : c）。 被运算符影响的值叫做 操作数 。在表达式 1 + 2 中， + 号是二元运算符， 1 和 2 是它的两个操作数。 赋值运算符与 C 和 Objective-C 中的赋值运算符不同，Swift 的赋值运算符本身不返回值。下方的语句是无效的：123if x = y &#123; // 这是无效的，因为 x = y 不返回值&#125; 算术运算符与 C 以及 Objective-C 不同的是， 在 Swift 中, 默认情况下算术运算符不允许值溢出。但是你能通过用 Swift 的溢出符号 (正如 a &amp;+ b)去加入值溢出的行为。参考 Overflow Operators。加号同样支持String的连接：1"hello, " + "world" // 等于 "hello, world" 取余运算符注意取余运算符 (%) 在别的一些语言中的意思是 模运算符 。不过，严格意义上在 Swift 中，对于负数来说它是取余运算而不是模运算。 一元减号运算符123let three = 3let minusThree = -three // minusThree 等于 -3let plusThree = -minusThree // plusThree 等于 3, or "--3" 一元加号运算符1let c = a + b 复合赋值运算符和 C 类似：123var a = 1a += 2// a 现在等于 3 注意复合赋值运算符没有返回值。例如，你不能这么写 let b = a += 2。 比较运算符Swift 支持所有的标准 C 系比较运算符 注意Swift 还提供了两个恒等运算符（=== 和 !==），你可以用它们来判断两个对象引用是否指向同一个实例。 如果两个元组有着相同数量和类型的元素，你就可以比较它们。元组的比较是从左向右，逐个比较的，直到遇到不相等的元素为止。也就是说，每次元素比较的返回值都决定着整个元组比较的结果。如果所有对应元素都相等，那么这两个元组就是相等的。比如：123(1, "zebra") &lt; (2, "apple") // true，因为 1 小于 2，"zebra" 和 "apple" 没有被比较。(3, "apple") &lt; (3, "bird") // true，因为 3 等于 3，而且 "apple" 小于 "bird"。(4, "dog") == (4, "dog") // true，因为 4 等于 4，而且 "dog" 等于 "dog"。 如果一个操作符可以被用来比较两个元组的每个对应元素，那么它就可以被用来比较这两个元组。比如像以下代码演示的那样，你可以比较两个类型为 (String, Int) 的元组，因为 String 和 Int 类型的值都可以用 &lt; 操作符比较。与之形成对比的是，两个 (String, Bool) 类型的元组不能用 &lt; 比较，因为 &lt; 运算符在 Bool 上没有定义。12("blue", -1) &lt; ("purple", 1) // 正确，比较的结果为 true("blue", false) &lt; ("purple", true) // 错误，因为两个布尔类型的值不能用 &lt; 比较。 注意Swift 标准库只定义了用于比较拥有七个以内元素的元组的操作符，如果想要比较两个拥有七个或更多元素的元组，你就需要自己来实现该运算符。 三元运算符它的形式是 question ? answer1 : answer2 空合运算符空合运算符 (a ?? b) 在可选型 a 有值的时候就为它解包，在 a 为 nil 的时候就返回默认值 b 。表达式 a 一定要是可选型。表达式 b 和 a 存储的值类型一定要一致。 空合运算符是下面代码的简写：1a != nil ? a! : b 注意如果 a 的值不是 nil ，那么 b 的值将不会被计算。这就是 短路求值。 区间运算符Swift 包含的一些 区间运算符，其实是数值区间表达式的缩写。 闭合区间运算符闭合区间运算符 (a...b) 表示从 a 到 b 的区间，并且包含 a 和 b。a 一定不能大于 b。 当你想遍历一个区间中的值加以利用时，那么闭合区间运算符就在合适不过了，比如在用 for-in 循环的时候：12345678for index in 1...5 &#123; print("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 半开区间运算符半开区间运算符（a..&lt;b）定义了一个从 a 到 b 但不包括 b 的区间。之所以称之为半开，是因为该区间只包含第一个值，而不包含最后一个值。与闭区间运算符一样，a 绝不可以大于 b。如果 a 等于 b 的话，就表示该区间为空。 当你作用于一个索引从 0 开始的列表（比如数组）时，如果你想要从 0 开始，一直数到（但不过包括）列表的长度，半开区间就显得非常有用了:123456789let names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; print("Person \(i + 1) is called \(names[i])")&#125;// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack 单侧区间闭区间运算符还有另外一种形式，表示向一个方向尽可能地延伸——例如在数组中，一个包含了从索引为 2 开始一直到结尾的所有元素的区间。在这些情况下，你可以省去该区间操作符一侧的值。因为这种区间只有一侧有值，所以它们叫作 单侧区间，例如：123456789101112for name in names[2...] &#123; print(name)&#125;// Brian// Jackfor name in names[...2] &#123; print(name)&#125;// Anna// Alex// Brian 半开区间操作符如果只保留其终值就是它的单侧形式了。就像它的完全形式一样，终值本身并不是该区间的一部分，例如：12345for name in names[..&lt;2] &#123; print(name)&#125;// Anna// Alex 单侧区间不仅仅能被用于下标，还能用于一些其它情况。你无法遍历省略了初始值的单侧区间，因为那种形式没有明确指出遍历应该从哪儿开始。不过你可以遍历没有终值的单侧区间；需要注意的是，因为区间的延伸特性，请务必确保你的遍历循环里有一个清晰的用于结束循环的条件。你还可以检查一个单侧区间是否包含某个特定的值，就像下边代码展示的那样。1234let range = ...5range.contains(7) // falserange.contains(4) // truerange.contains(-1) // true 逻辑运算符Swift 支持基于 C 语言中的 3 种标准逻辑运算符 逻辑非（!a） 逻辑与（a &amp;&amp; b） 逻辑或（a || b） 混合逻辑运算你可以组合多个逻辑运算符来创建更长的复合表达式：123456if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123; print("Welcome!")&#125; else &#123; print("ACCESS DENIED")&#125;// 打印 "Welcome!" 注意Swift 逻辑运算符 &amp;&amp; 和 || 都是左关联的，这意味着具有多个逻辑运算符的复合表达式首先判断最左边的子表达式。 显性括号括号清楚地表明了前两个值被视为整体逻辑中独立可能状态的一部分。这个复合表达式的结果并没有改变，但是其整体的意图对于读者来说更加清晰了。易读性总是优先于简洁性；在可以帮助你明确意图的地方，使用括号吧。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>基本运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2（基础篇要点）]]></title>
    <url>%2F2018%2F10%2F05%2FSwift%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Swift4.2基础篇摘要ʕ•͡ω•ʔ 本章节只是简单的摘录文档里的重要内容（或者是没记住的- -）如果想从头开始看Swift还是直接看官方文档比较好 高级类型除了属性的类型，Swift引入了Objective-C中没有的高级类型，比如元组。元组可以让你创建与传递值的分组。你可以使用元组将函数中的多个值作为单个复合值返回。 可选类型Swift 还引入了可以处理缺省值的可选类型。可选类型表示「要么 有 值，并且等于 X」，「要么 没有 值」 。使用可选类型与在 Objective-C 中将指针和 nil 一起使用很相似，但是，可选类型适用于任何类型，不仅仅是类。可选类型不仅比 Objective-C 中的 nil 指针更安全，更具表现力，它还是 Swift 众多强大特性中的核心。 类型安全Swift 是一门 类型安全 的语言，这意味着它有助于明确代码中的值的类型。如果代码中需要一个 String，类型安全可以防止你错误地传递给它一个 Int。同样的，类型安全可以防止你意外地将一个可选的 String 传递给一个需要非可选 String 的代码片段。在开发过程中，类型安全可以帮你尽早捕捉并修复错误。 注释Swift 中的多行注释可以相互嵌套使用 浮点数Double 类型可以精确到小数点后15位，而 Float 类型只有6位。如果两种类型都能使用的情况下，优先使用 Double 类型 。 类型推断因为有了类型推断，Swift 和 C 以及 Objective-C 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。Swift 在推断浮点值的时候始终会选择 Double （而不是Float）。 数值型字面量整数型字面量可以写作： 十进制数，没有前缀 二进制数，前缀为 0b 八进制数，前缀为 0o 十六进制数，前缀为 0x 类型转换SomeType(ofInitialValue) 是 Swift 中初始化一个对象的默认方式，在这个过程中需要传入一个初始值。而在底层实现中，UInt16 有一个接收 UInt8 类型的初始化构造器，所以这个构造器是用来转换 UInt8 类型 到 UInt16 类型 的。你不能在这传入 任何 类型，因为必须是 UInt16 初始化构造器允许的类型才可以。扩展现有类型的初始化构造器，让其接收新的类型（包括你自己自定义的类型）的内容在 Extensions 中可以找到。 类型别名类型别名 就是给现有类型定义了一个另外的名字。你可以使用 typealias 关键字来声明类型别名。 布尔值Swift 有一个基础 布尔 类型 Bool. 布尔值也被称为 逻辑值, 因为它们只能是真或假。 Swift 提供两个布尔常量，true 和 false 。 元组元组 将多个值组合在一起成为一个复合值。元组里面的值可以是任何类型，不需要是相同的类型。你可以将一个元组的内容 分解 为单独的常量或变量，然后你就可以正常使用它们了：1234567let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String), 等于 (404, "Not Found")let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// 打印 "The status code is 404"print("The status message is \(statusMessage)")// 打印 "The status message is Not Found" 如果你只需要元组里的一部分值的话，分解元组的时候使用一个下划线（_） 来忽略元组里面的值：123let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// 打印 "The status code is 404" 此外，使用从零开始的下标来访问元组里单个元素的值：1234print("The status code is \(http404Error.0)")// 打印 "The status code is 404"print("The status message is \(http404Error.1)")// 打印 "The status message is Not Found" 定义元组时，你可以为元组中的单个元素命名：1let http200Status = (statusCode: 200, description: "OK") 如果你在元组里为元素命名了，那么你就可以通过元素名称去获取元素的值：\1234print("The status code is \(http200Status.statusCode)")// 打印 "The status code is 200"print("The status message is \(http200Status.description)")// 打印 "The status message is OK" 元组作为函数的返回值的时候十分有用。一个尝试获取一个网页的函数可能会返回一个 (Int, String) 类型来表示结果的成功或失败。相比于返回一个类型的单个值作为结果，通过返回包含两个不同类型值的一个元组作为返回值，这个函数让自己的返回值提供了更多有用的信息。更多信息，参考 函数参数与返回值 注意元组在临时组织的值的时候很有用。元组并不适合用于创建复杂数据结构。如果你的数据结构比较持久而不是临时使用的话，使用类或者结构体，而不是元组。更多信息，参考 结构体和类. 可选类型注意C 和 Objective-C 中没有可选类型的概念。最接近的是Objective-C 中的一个方法除了返回对象之外还会返回nil 的能力，nil表示缺省一个合法的对象。然而，这仅仅对对象起作用 — 对结构体，基本C 类型或者枚举类型并不起作用。对于这些类型，Objective-C 的方法通常会返回一个特殊的值(比如 NSNotFound)来表示值缺省的情况。这种方式假设方法的调用者知道和记得对特殊值进行处理和检查。Swift 的可选类型可以让你表明任何类型的值缺省的情况，而不需要特殊值。 非可选状态下的常量或变量不能使用 nil 。在某些特定条件下，如果你代码中的常量或变量需要指定为空值，则始终将其声明为适当类型的可选值。 如果你定义了一个可选变量但没有赋值，变量将自动设置为 nil 注意Swift 里的 nil 不同于 Objective-C 里的 nil 。 在 Objective-C 里, nil 是一个指向空对象的指针。在 Swift 里， nil 不是指针，而是某种特定类型值的缺失。 任意 类型都可以设置为 nil, 而不仅仅是对象类型。 if 语句和强制解析你可以在通过一个 if 语句里比较可选项和 nil 的方式来确定其是否包含确定值 。执行比较需要用到“等于”操作符 == ，或者“不等于”操作符!=。 如果一个可选项包含值，那么它就被认为不等于 nil:1234if convertedNumber != nil &#123; print("convertedNumber contains some integer value.")&#125;// 打印 "convertedNumber 包含整型值." 一旦你确认可选项包含值，你就可以通过使用在可选项名称后添加!的方式来访问它的值。感叹号的含义是：“我知道这个可选项绝对有值，请使用它。”这就是对可选项值的强制解析。1234if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).")&#125;// 打印 "convertedNumber 包含整型值 123." 可选绑定使用可选绑定 optional binding 来判断一个可选类型是否包含值，如果包含就赋给一个临时的常量或者变量使这个值可用。可选绑定可以被用到if和while语句中，用来检差一个值是否是可选类型， 并且将值提取为一个常量或者变量。 if 语句的可选绑定可以写成如下这样：123if let constantName = someOptional &#123; statements&#125; 你可以使用可选绑定而不是强制解包来重写 可选类型 章节的 possibleNumber 例子：123456if let actualNumber = Int(possibleNumber) &#123; print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")&#125; else &#123; print("\"\(possibleNumber)\" could not be converted to an integer")&#125;// Prints ""123" has an integer value of 123" 上面的代码可以被理解为： “如果通过 Int(possibleNumber)返回的可选 Int 类型包含一个值，那么就创建一个名为 actualNumber 的新的常量并把可选类型中的值赋给它。” 如果转换成功，常量 actualNumber 可以被用在 if 语句的第一个分支中。它已经被可选类型 包含的 值初始化，因此不再需要使用后缀 ! 来获取它的值。在这个例子中，actualNumber 被简单地用来打印转换的结果。 注意在 if 语句中使用可选绑定的常量和变量仅在 if 语句内可用。相反，在 guard 语句中创建的常量和变量在 guard语句后的代码中也可以使用，如上所述 Early Exit. 隐式展开可选项通过在声明的类型后边添加一个叹号 String! 而非问号 String? 来书写隐式展开可选项。隐式展开可选项是后台中通用的可选项，但是同样也可以像非可选值来使用，每次访问的时候不需要展开。接下来的例子中展示了在访问被明确为 String 的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：12345let possibleString: String? = "An optional string."let forcedString: String = possibleString! //要求使用感叹号let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要使用感叹号 你可以把隐式展开可选项当做在每次访问他的时候被给与了自动进行展开的权限。相比于在每次调用他的时候添加一个叹号，你可以再声明的时候呀添加一个叹号。 错误处理相比于可选项的通过值是否缺失来判断程序的执行正确与否，错误处理机制能允许你判断错误的形成原因，如果需要的话，还能将你的代码中的错误传递到程序的其他地方。当一个函数遇到错误情况，他或 抛出 错误。这个函数的访问者会 捕捉 到这个错误并且做出适当的反应。123func canThrowAnError() throws &#123; // 这个函数可能会出错也可能不会出错&#125; 通过在函数声明过程中加入 throws 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，你需要再表达式前预置 try 关键字。 Swift 会自动将错误传递到他们的生效范围之内，直到他们被 catch 分局处理。123456do &#123; try canThrowAnError() // 无错误抛出&#125; catch &#123; // 有错误抛出&#125; do 语句创建了一个新的容器范围，可以让错误被传递到不止一个的 catch 分句处理。 下面的例子演示了如何利用错误处理机制处理不同的错误情况：123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 本例中，如果没有干净的盘子或某个原料缺失的话，makeASandwich() 函数会抛出一个错误。因为 makeASandwich() 函数抛出了错误，所以对它的调用被包裹在一个 try 表达式里。将函数调用包裹进一个 do 的语句里，任何抛出的错误都会被传播到提供的 catch 从句里。 如果没有抛出错误，eatASandwich() 方法将会被调用。如果抛出了错误，并且匹配到了 outOfCleanDishes 条件的话，washDishes() 函数就会被调用。如果匹配到了 SandwichError.missingIngredients 条件，buyGroceries(_:) 函数就会被调用，并且使用 catch 捕获的关联 String 值作为参数。 断言与先决条件断言 和 先决条件 是程序运行时发生的检查动作。你可以使用它们来检查代码被执行之前的一些必要条件是否被满足。如果断言或先决条件中布尔值的条件等于 true，代码将会像平常一样继续执行下去。如果条件等于 false，当前程序的状态将会是无效的，并且会导致代码执行停止，程序被终止。 断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。 调试断言使用 Swift 标准库中的 assert(_:_:file:line:) 函数来声明一个断言语句。可以向这个函数传入一个值为 true 或 false 的表达式以及如果条件为 false 的情况下的提示性信息。如下所示：123let age = -3assert(age &gt;= 0, "A person's age can't be less than zero.")// 因为 -3 小于 0，所以这个断言失败了 上面的例子中，如果 age &gt;= 0 语句结果为 true，代码将继续执行下去，也就是说 age 的值是非负的。如果 age 的值是负数，那么上面的代码中的 age &gt;= 0 语句将返回 false，这将导致断言失败，程序终止。 你可以省略断言提示信息 — 比如下面的代码，仅仅是单调地重复一下条件语句。1assert(age &gt;= 0) 如果代码中已经检查了条件的话，可以使用 assertionFailure(_:file:line:) 函数来表明断言已经失败。如下所示：1234567if age &gt; 10 &#123; print("You can ride the roller-coaster or the ferris wheel.")&#125; else if age &gt; 0 &#123; print("You can ride the ferris wheel.")&#125; else &#123; assertionFailure("A person's age can't be less than zero.")&#125; 强制执行先决条件只要条件可能会为 false 的时候，就使用先决条件。但代码必须 肯定 为 true 才能继续执行下去。例如，使用先决条件去检查下标是否越界或检查函数是否传入了合法的参数值。 通过调用 precondition(_:_:file:line:) 函数来声明一个先决条件。你可以向一个先决条件传入结果为 true 或 false 的表达式和当结果为 false 时的提示信息。例如：12// 判断下标...precondition(index &gt; 0, "Index must be greater than zero.") 你也可以使用 preconditionFailure(_:file:line:) 函数来表明执行的失败 — 例如，如果一个 switch 语句的默认条件命中了，但是所有有效的输入数据只会被其他条件处理。 注意如果你以不检查的编译模式( Ounchecked )模式进行编译，先决条件将不会起作用。编译器会假设先决条件总是为真，并会根据你的代码做相应的优化。然而，无论优化设置如何，fatalError(_:file:line:) 函数总会停止程序的执行。你可以在原型设计和开发的早期过程中使用 fatalError(_:file:line:) 函数来创建尚未实现的功能的存根，编写 fatalError(&quot;Unimplemented&quot;) 作为存根的实现。因为 fatal error 永远不会被优化，与断言和先决条件不同的是，你可以确保程序总是在遇到存根实现时停止。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2光速入门٩(๑>◡]]></title>
    <url>%2F2018%2F10%2F03%2FSwift%2F</url>
    <content type="text"><![CDATA[9月25日，Xcode10发布了！支持swift3和swift4，而如今swift也日趋成熟，使用swift开发的项目也越来越多。ʕ•̀ω•́ʔ✧是时候学swift了，一起来光速入门吧~ 版本兼容性swift采用了现代编程模式，以避免大量常见的低级编程错误： 变量永远会在被使用前完成初始化 对数组的索引操作会自动检查是否出现越界错误 整型数值会自动检查是否溢出 可选值确保nil值被正确处理 内存被自动管理 错误处理允许从异常故障控制恢复 当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享： 子字符串的操作返回的实例是Substring类型而不是String 在较少的地方会隐性增加@objc属性 同一文件中类型的拓展可以访问该类型中的私有成员 概述首先，从hello world开始用swift实现可太tm简单了用xcode创建一个swift blank项目，在playground中输入一句话1print("hello world!") 全局作用域中的代码会自动作为程序的入口，因此；不需要main()函数，同样的，你也不需要写;了。 简单值 lei声明常量var声明变量 123var num = 1num = 2let number = 3 swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，num是个整数，因为它的初始值是一个整数。 如果没有初始值，你又想声明类型，你只要在变量后声明类型，用:分割。 1let num3:Double = 1 swift有一种更简单的方式让值转为字符串：把值写在()内，在括号之前再加一个\1234567let str = "girlfriend"let sum1 = 1let sum2 = 0print("I used to have \(sum1) \(str)")print("and now I have \(sum1*sum2) \(str)")print("pretty girl check your wechat number and send it to me pls:)") 对于占用多行的字符串可以使用三个引号&quot;&quot;&quot;每行的来头缩进要和右引号的缩进相同12345let string = """hello~this my wechat number"""print(string) 使用[]来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号12345678var arr = ["my","name","is","hades"]arr[3] = "whz"var dic = [ "key1":"value1", "key2":"valeu2"]dic["key2"] = "value change" 使用初始化语法来创建一个空数组或者字典12let emptyArr = [String]()let emptyDic = [String:String]() 如果类型能被推断，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）12arr = []dic = [:] 控制流 使用if和switch来创建条件语句，使用for-in,while，以及repeat-while来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。123456789101112let numArr = [123,13,4,13,43,65]var totalNum = 0for tempNum in numArr &#123; if tempNum &lt; 50 &#123; totalNum -= 1 &#125; else&#123; totalNum += 1 &#125; print(totalNum)&#125;print("end of totalnum = \(totalNum)") 在if语句中，条件语句必须是布尔表达式，可以使用if和let来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为nil表示值缺失。在值得类型后面跟随一个?则表示这个值是可选的。12345678910111213141516var exampleStr:String? = "hello"print(exampleStr == nil)var name:String? = "hades"var greeting = "hello~"//name = "xiye"//name = nilif let nameTemp = name &#123; //如果类型转换成功，则将值赋值给nameTemp直接使用 greeting = "hello~ \(nameTemp)" print("nameTemp = \(nameTemp) name = \(name!)") print("( let nameTemp = name ) = true");&#125;else&#123; print("name = nil ") //强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有 print("( let nameTemp = name ) = false");&#125; 如果可选值为nil，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给let后的常量，这样代码中就可以使用这个值。 处理可选值得另一种方法是使用??操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。 1234567var nickName: String? = nil //"whz"let fullName: String = "hades"//nickName = "whz"//nickName = nillet informalGreeting = "hi~ \(nickName ?? fullName)"print(informalGreeting) oc中的nil和swift中的nilObjective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) ‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。1234567891011var people = "ex"switch people &#123;case "girl": print("hey~ could you give me your wechat number?")case "man","boy": print("oh...next pls")case let x where x.hasSuffix("x")://hasSuffix以指定后缀结束，hasPrefix以指定前缀开始 print("if time can come back...")default: print("hello stranger.")&#125; 在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。你可以为字典中的键值对起一组名字，并用for in语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。1234567891011121314151617let someNumbers = [ "key1":[2,4,1,5,31], "key2":[2,43,2,5,1,53], "key3":[2345,13,1,3,13,65]]var maxNum = 0;var maxName:String = ""for (keyInSomeNumbers,valueInSomeNumbers) in someNumbers &#123; for values in valueInSomeNumbers &#123; if values &gt; maxNum &#123; maxNum = values maxName = "\(keyInSomeNumbers)" &#125; &#125;&#125;print("\(maxName) \(maxNum)") 使用while来循环执行代码12345678910111213var n = 0while n &lt; 100 &#123; n = n*n + 1&#125;print(n)var m = 0repeat&#123; m = m + 1 print("m = \(m)")&#125;while m &lt; 10print(m) 可以使用..&lt;来限定索引范围，并在循环中遍历该索引范围12345var total = 0for i in 1..&lt;4 &#123; total += i&#125;print(total) 函数和闭包使用func来声明一个函数。使用函数名和参数名来调用函数。使用-&gt;来指定函数返回值类型。1234func greet (person:String,day:String)-&gt; String&#123; return "Hello \(person),today is \(day)"&#125;print(greet(person: "whz", day: "thuesday")) 默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用_来表示来不使用参数标签。1234func greet(_ preson:String,on day:String)-&gt; String&#123; return "hello \(preson),today is \(day)"&#125;print(greet("hades", on: "friday")) 使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。1234567891011121314151617181920func function(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else&#123; min = score &#125; sum = sum + score &#125; return (min,max,sum)&#125;let result = function(scores: [1,31,413,356,1,376,463])print(result.max)print(result)print(result.2) 函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。123456789func returnFifteen()-&gt; Int &#123; var x = 10 func add()&#123; x += 5 &#125; add() return x&#125;print(returnFifteen()) 函数是一个类型。意味着函数可以作为其他函数的返回值。12345678func returnOneFunction() -&gt; ((Int) -&gt; Int)&#123; func returnOneInt(number:Int) -&gt; Int&#123; return number + 1 &#125; return returnOneInt&#125;var anotherFunction = returnOneFunction()print(anotherFunction(3)) 一个函数也可以作为参数传入另一个函数1234567891011121314func hasAnyMatches(list:[Int],condition:(Int)-&gt;Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; print(item) return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型与闭包函数体分离。12345678var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen)numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number print(111) return result&#125;) 写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。12345var temp = [3,41,5,1,51]let temp1 = temp.map&#123; num in num + 1&#125; swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写1234print(temp1)let temp2 = temp.map&#123; $0 + 1&#125; 对象和类通过在类名前加class关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 通过在类名称后面插入括号来创建类的实例。使用.语法的方式来访问实例中的属性和方法。1234var shape = Shape()shape.numberOfSides = 9var shapeDescription = shape.simpleDescription()print(shapeDescription) 当一个类的属性没有初始值，你就需要使用init来创建一个构造器。1234567891011class NamedShape &#123; var numberOfSides:Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func description() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 这里的self被用来区分name属性和构造器的name参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。如果你需要在对象被释放前执行一些清理的行为，可以使用deinit来创建一个折构器。 子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。 子类如果需要重写父类的方法，则需要使用override来标记—不使用override关键字来标记会导致编译器报错。编译器同样也会检查override标记的方法是否存在父类当中。1234567891011121314151617181920class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 5 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func description() -&gt; String &#123; return "A square with sides of length \(sideLength)" &#125;&#125;let test = Square(sideLength: 4.1, name: "test square")print(test.area())print(test.description()) 除了存储简单的属性，属性还可以拥有getter和setter123456789101112131415161718192021222324252627class EquilaterTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength = newValue / 3.0 &#125; &#125; override func description() -&gt; String &#123; return "this is a triangle with sides of length \(sideLength)" &#125;&#125;var triangle = EquilaterTriangle(sideLength: 4.3, name: "a triangle")print(triangle.perimeter)triangle.perimeter = 9print(triangle.sideLength) 在perimeter的setter中，新值被隐式的命名为newValue。你可以在set的括号后面，显式的提供一个名字。 注意EquilateralTriangle类的初始化有三个不同的步骤：- 1 设定子类的声明的属性值- 2 调用父类的构造器- 3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。 如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用willSet和didSet。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。123456789101112131415161718192021class TriangleAndSquare &#123; var triangle: EquilaterTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square:Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square = Square(sideLength: size, name: name) triangle = EquilaterTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: "test")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 40, name: "larger square")print(triangleAndSquare.triangle.sideLength) 在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用?。如果?前的值是nil,则?后面的所有内容都会被忽略，且整个表达式为nil。否则，可选项的值将被展开，然后?后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。12let optionalSquare: Square? = Square(sideLength: 2.3, name: "optional square")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。123456789101112131415161718192021enum Rank: Int &#123; case ace = 1 case two,three,four,five,six,seven,eight,nine,ten case jack,queen,king func simpleDescription() -&gt; String &#123; switch self &#123; case .ace: return "ace" case .jack: return "jack" case .queen: return "queen" case .king: return "king" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue 默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，Ace的原始值被显示赋值为1，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器来创建一个拥有原始值得枚举实例。如果在Rank中有与该原始值相匹配的枚举实例则返回该实例，没有则返回nil。123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。1234567891011121314151617enum Suit &#123; case spades,hearts,diamonds,clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .spades: return "spades" case .hearts: return "hearts" case .diamonds: return "diamonds" case .clubs: return "clubs" &#125; &#125;&#125;let hearts = Suit.heartslet haartsDescriotion = hearts.simpleDescription() 注意在上面例子中用了两种方法来调用hearts成员：给hearts指定一个常量时，枚举成员Suit.hearts需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式.hearts被调用，因为self的值已经确定是Suit类型。在值得类型已经被明确的情况下可以使用缩写。 如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。12345678910111213enum ServerResponse &#123; case result(String,String) case failure(String)&#125;let success = ServerResponse.result("6:00 am","8:00 pm")let failure = ServerResponse.failure("fail")switch success &#123;case let .result(sunrise,sunset): print(" sunrise is at \(sunrise) and sunset is at\(sunset)")case let .failure(message): print("fail - \(message)")&#125; 注意日出日落时间是如何从ServerResponse值中进行提取，并与 switch cases 相匹配的。 使用struct来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" &#125;&#125;let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用protocol来声明一个协议。mutating关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量1234protocol ExampleProtocol &#123; var simpleDescription: String&#123; get &#125; mutating func adjust()&#125; 类、枚举和结构都可以遵循协议12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = "a simple class" var anotherPriperty: Int = 69105 func adjust() &#123; simpleDescription += "now 100% adjusted" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct simpleStructure: ExampleProtocol &#123; var simpleDescription: String = "a simple sturcture" mutating func adjust() &#123; simpleDescription += "(adjusted)" &#125;&#125;var b = simpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明SimpleStructure时使用了关键字mutating来标记一个可以修改结构体的方法。而声明SimpleClass时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。 使用extension可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。 123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return "the number \(self)" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) 你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。 1234let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)//下面这句会报错print(protocolValue.anotherProperty) 尽管变量protocolValue在运行时类型为SimpleClass，但编译器依旧会把它的类型当做ExampleProtocol。这也就意味着，你不能随意访问在协议外的方法或属性。 错误处理你可以使用任何遵循Error协议的类型来表示错误。12345enum PrintError: Error &#123; case outOfPaper case noToner case onFire&#125; 使用throw跑出异常并且用throws来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。123456func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == "Never Has Toner" &#123; throw PrintError.noToner &#125; return "Job sent"&#125; 这里有几种方法可以处理异常。一种是使用do-catch。在do代码块里，你可以是用try在抛出的异常的函数前标记。在catch代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为error。123456do &#123; let printerResponse = try send(job: 1040, toPrinter: "Never Has Toner") print(printerResponse)&#125; catch&#123; print(error)&#125; 你可以提供多个catch代码块来处理特定的错误。你可以在catch后面一个一个模式，就像switch语句里面的case一样。12345678910 do &#123; let printerResponse = try send(job: 1440, toPrinter: "Gutenberg") print(printerResponse)&#125; catch PrintError.onFire &#123; print("I'll just put this over here, with the rest of the fire.")&#125; catch let printerError as PrintError &#123; print("Printer error: \(printerError)")&#125; catch &#123; print(error)&#125; 另外一种处理错误的方法是用try?去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为nil。否则，结果是一个包含了函数返回值的和选项。12let printerSuccess = try? send(job: 1883, toPrinter: "Mergenthaler")let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner") 使用defer来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用defer来简化代码。1234567891011121314var fridgeIsOpen = falselet fridgeContent = ["milk","eggs","leftovers"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result&#125;fridgeContains("milk")print(fridgeIsOpen) defer常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候defer会在该当前声明的作用域结束的时候执行优先级： 局部优先、同级自下而上12345678910111213141516171819func firstProcesses(_ isOpen: Bool) &#123; //作用域1 整个函数作用域 defer&#123; print("推迟操作🐢") &#125; print("😳") if isOpen == true &#123; //作用域2 if的作用域 defer&#123; print("推迟操作🐌") &#125; print("😁") &#125; print(111)&#125;firstProcesses(true) 泛型把名字写在尖括号里来创建一个泛型方法或者类型。12345678func makeArray&lt;Item&gt;(repeating item: Item,numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;makeArray(repeating: "knock", numberOfTimes: 4) 你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。123456enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100) 在类型名称后紧接where来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。1234567891011func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T,_ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1,2,3], [3]) 以上就是Swift4.2的概述，看完这些写一个简单的app已经不是难事了~但简单的app可不是我们的目标，还有很多语法上的细节需要深入研究学习，在后面的文章我会逐步更新语法上的细节ʕु•̫͡•ʔु ✧]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM是什么( ´ﾟωﾟ)？]]></title>
    <url>%2F2018%2F08%2F23%2FLLVM%2F</url>
    <content type="text"><![CDATA[LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙 简述LLVM 一个开源编译器架构，目前Xcode采用的就是LLVM架构。 Clang 由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。 GCC GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GNU GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。 在Xcode上使用GCC Xcode在C和C++上是支持使用GCC的，如下：具体参数的使用请参考：stackoverflow:Xcode上的GNU GCC 更多概念LLVM全名：Low Level Virtual Machine 直译：底层虚拟机/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.- 来自LLVM官网的介绍 LLVM官网 LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。 LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。 - 来自维基百科 LLVM on wiki 简单来说 LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。编译器是Clang，GCC，ICC，VC++等。 Xcode和LLVM Xcode3之前，用的是GCCXcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能Xcode4.6,LLVM升级到4.2版本Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成 ClangClang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang项目包括Clang前端和Clang静态分析器等。- 来自维基百科 Clang on wiki GCCGCC官网GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。 原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。 许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。- 来自维基百科 GCC on wiki GNUGNU官网GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。 作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。- 来自维基百科 GNU on wiki LLDBLLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。 GDBGNU Debugger 顾名思义支持编程语言有C、C++、Pascal以及FORTRAN在许多的类UNIX操作系统上都可以使用 词法分析lexical analysis /ˈlɛksɪkəl/词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。 语法分析syntactic analysis，也叫 parsing/sɪnˈtæktɪk əˈnæləsəs/ /ˈpɑːzɪŋ/语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述. 语法分析器parser通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。 源语言&amp;源程序Source language&amp;Source program被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。 目标语言&amp;目标程序Object language or Target language &amp; Object program or Target program编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。 中间语言（中间表示）Intermediate language（representation）在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。 文法Grammars/ˈgræməz/文法是用于描述语言的语法结构的形式规则。 token是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。 抽象语法树abstract syntax tree或者缩写为AST/ˈæbstrækt ˈsɪnˌtæks tri/抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。 具体CMD+BObjective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。 在使用Xcode按下cmd+B后，会经过以下流程：预处理（Pre-process）：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。 词法分析 （Lexical Analysis）：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 语法分析（Semantic Analysis）：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。 静态分析（Static Analysis）：使用它来表示用于分析源代码以便自动发现错误。 中间代码生成（Code Generation）：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。 优化（Optimize）：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。 生成目标文件（Assemble）：生成Target相关Object(Mach-o) 。 链接（Link）：生成 Executable 可执行文件。 关于此过程的详细测试，参考掘金 LLVM的具体操作请参考关于LLVM，这些东西你必须知道！ 基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 a+b 改为 a-(-b)将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。 所以基于LLVM可以完成： 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。 编写ClangPlugin，命名规范，代码规范，扩展功能。 编写Pass，代码混淆优化。 使用Clang进行开发详细参考IBM developerWorks Clang的特性相比于 GCC，Clang 具有如下优点： 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强： 支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。 支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。 以下是目前GCC和Clang对C++支持的情况： 更多参考C++ 编译器支持情况表 使用LLVM创建一个编译器首先参考这篇文章来写一个helloworldIBM developerWorks 关于LLVM IR的生成与创建IBM developerWorks]]></content>
      <categories>
        <category>编译相关</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
        <tag>GNU</tag>
        <tag>GCC</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本的入门（一）]]></title>
    <url>%2F2018%2F08%2F15%2FShell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。 Simple BB 为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。获取目标资源的路径，根据A中的行数进行循环find查找，找到就用cp命令替换，未找到的重定向输出到临时文件B最后打印B的内容，remove临时文件。其中对文本的处理使用了awk命令 脚本下载地址在我的github上 资源替换脚本 Shell介绍 Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。而我使用shell只是因为我用的mac - - Shell的工作原理 Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。 Shell的创建 1.打开文本编辑工具，输入一下内容#!/bin/bash echo &quot;Hello World&quot;2.保存为 hello world.sh在目录 A3.在终端cd到目录 A4.终端输入chmod +x ./hello world.sh （这一步是给脚本添加权限）5.执行脚本 ./hello world.sh 或者 直接把 hello world.sh拖入终端 这很简单，无图。 Shell中的变量变量的定义1example="a1" 或者 1example=a1 但是example=a 1 并不等同于 example=&quot;a 1&quot;因为&quot; &quot;（空格）在shell中用作指令的间隔example=a 1 其实只是将a负责给example 然后在输入了个1 这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！ 变量的访问在变量前加上$ 1echo $example Shell中的四则运算1234$a + $b$a - $b$a \* $b$a / $b 注意 乘法的时候需要进行转义= 赋值时，前后无空格而运算符号前后必须有空格 Shell中的其他运算符 =、==、!=、！、-o、-a 12-o 或-a 与 关系运算符 -eq 两个数相等返回true-ne 两个数不相等返回true-gt 左侧数大于右侧数返回true-It 左侧数小于右侧数返回true-ge 左侧数大于等于右侧数返回true-le 左侧数小于等于右侧数返回true 字符串运算符 = 两个字符串相等返回true!= 两个字符串不相等返回true-z 字符串长度为0返回true-n 字符串长度不为0返回true-d file 检测文件是否是目录，如果是，则返回 true-r file 检测文件是否可读，如果是，则返回 true-w file 检测文件是否可写，如果是，则返回 true-x file 检测文件是否可执行，如果是，则返回 true-s file 检测文件是否为空（文件大小是否大于0，不为空返回 true-e file 检测文件（包括目录）是否存在，如果是，则返回 true Shell字符串操作123456mtext="hello" #定义字符串mtext2="world"mtext3=$mtext" "$mtext2 #字符串的拼接echo $mtext3 #输出字符串echo $&#123;#mtext3&#125; #输出字符串长度echo $&#123;mtext3:1:4&#125; #截取字符串 Shell数组12345678array=(1 2 3 4 5) #定义数组array2=(aa bb cc dd ee) #定义数组value=$&#123;array[3]&#125; #找到某一个下标的数，然后赋值echo $value #打印value2=$&#123;array2[3]&#125; #找到某一个下标的数，然后赋值echo $value2 #打印length=$&#123;#array[* ]&#125; #获取数组长度echo $length Shell输出1echo Shell的判断12345678910111213141516171819202122232425262728a=10b=20if [ $a == $b ]thenecho "true"fiif [ $a == $b ]thenecho "true"elseecho "false"fiif [ $a == $b ]thenecho "a is equal to b"elif [ $a -gt $b ]thenecho "a is greater than b"elif [ $a -lt $b ]thenecho "a is less than b"elseecho "None of the condition met"fi Shell中的test命令12345678910 test $[num1] -eq $[num2] #判断两个变量是否相等 test num1=num2 #判断两个数字是否相等-e file 文件存在则返回真-r file 文件存在并且可读则返回真-w file 文件存在并且可写则返回真-x file 文件存在并且可执行则返回真-s file 文件存在并且内容不为空则返回真-d file 文件目录存在则返回真 Shell中的循环for循环123456789101112131415161718192021for ((i=1;i&lt;=10;i++))doecho $idonefor i in &#123;1..5&#125;doecho $idonefor i in 5 6 7 8 9doecho $idonefor FILE in $HOME/.bash*doecho $FILEdone while循环123456789101112while [ $COUNTER -lt 5 ]doCOUNTER=`expr $COUNTER + 1`echo $COUNTERdoneecho '请输入。。。'echo 'ctrl + d 即可停止该程序'while read FILMdoecho "Yeah! great film the $FILM"done 跳出循环123break #跳出所有循环break n #跳出第n层f循环continue #跳出当前循环 Shell中的函数 无参数无返回值 12345678910111213141516171819202122232425262728293031 sysout()&#123; echo "hello world" &#125; sysout &lt;/code&gt;&lt;/pre&gt;&gt; 无参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; aNum=3 anotherNum=5 return $(($aNum+$anotherNum)) &#125; test result=$? echo $result&lt;/code&gt;&lt;/pre&gt;&gt; 有参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; echo $1 #接收第一个参数 echo $2 #接收第二个参数 echo $3 #接收第三个参数 echo $# #接收到参数的个数 echo $* #接收到的所有参数 &#125; test aa bb cc Shell中的重定向123$echo result &gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写$echo result &gt;&gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写echo input &lt; file #获取输入流 Shell中的变量操作 awk 指令获取指定行数的资源名字1sourceNameTemp=$(awk 'NR=="'$i'" &#123;print;exit&#125;' $OutputFile) 获取对应文件名1temp=$&#123;temp##*/&#125; 清空文件1: &gt; "$OutputFile" 常用的Linux命令awk命令 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 基本结构1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中 工作原理 第一步：执行BEGIN{ commands }语句块中的语句；第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。第三步：当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 获取指定行数的文本1awk 'NR=="'$i'" &#123;print;exit&#125;' file 获取文件的行数1awk '&#123;print NR&#125;' "file"|tail -n1 关于awk的详细用法请参考 awk命令]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
