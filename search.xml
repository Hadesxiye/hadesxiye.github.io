<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift4.2 函数]]></title>
    <url>%2F2018%2F10%2F10%2FSwift%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 是执行一个具体任务的一段独立代码块，你可以通过为函数命名来标识其任务功能，当需要执行这个任务时，函数名就可以用来「调用」该函数。 Swift 的统一的函数语法非常灵活，以致于从一个简单、无参数名的 C 风格函数，到一个复杂、多参数名的 Objective-C 风格方法都可以灵活表达。参数可以通过设置一个默认值，以简化函数的调用。 也可以传递可修改参数，一旦函数完成执行，传递的参数值就会被修改。 Swift 中的函数类型由参数值类型和返回值类型共同组成。你可以像其它类型一样来使用这个类型，这样把一个函数做为参数传递给另一个函数就会非常容易，并且可以从其它函数来返回函数。另外，一个封装了具体功能的函数能直接嵌套在另一个函数的代码块中。 函数的定义和调用在定义一个函数时，你可以可选地提供一个或多个输入值作为参数。当函数执行完成时，你也能可选地提供一个值作为返回值。 每一个函数的 函数名 描述了这个这个函数需要做的事情。你可以通过这个函数名去调用它并为它提供符合参数类型的参数值。 函数的实参值必须按形参的参数列表顺序依次传入。 下面我们定义一个 greet(person:) 方法 , 它表示向一个人打招呼， 它接受一个 String 类型的值做为输入并返回一个 String 类型的值 。1234func greet(person: String) -&gt; String &#123; let greeting = "Hello, " + person + "!" return greeting&#125; 函数名的定义应该清晰地指明这个函数的功能，函数的函数名前面必须要加 func 关键字。函数 -&gt; (向右的箭头) 后面是返回值，-&gt; 后面跟返回值的类型。 上面方法的方法名描述了这个方法要做的事情、需要的参数值和当执行完成时返回的值。在其他地方调用时，这个方法清晰的表达了它的作用1234print(greet(person: "Anna"))// Prints "Hello, Anna!"print(greet(person: "Brian"))// Prints "Hello, Brian!" 为了简化函数体书写，我们可以把消息的创建和返回合并在一条语句中:12345func greetAgain(person: String) -&gt; String &#123; return "Hello again, " + person + "!"&#125;print(greetAgain(person: "Anna"))// Prints "Hello again, Anna!" 函数的参数和返回值在 Swift 中，函数的参数和返回值是非常灵活的。你能定义任何事 无论是一个单一参数的简单函数 还是有着多个参数和不同参数选项的复杂函数。 无参函数函数可以没有参数。 下面是一个没有参数的函数，当调用时，它总是返回同一个 String 类型的值：12345func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125;print(sayHelloWorld())// Prints "hello, world" 多个参数函数也可以有多个参数，这些参数写在函数名后面的 () 内，参数之间通过 , 逗号分隔。 下面方法接受一个 String 类型的人名值和是否已经打过招呼的 Bool 值作为输入，返回一个给这个人打招呼的信息：123456789func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return greetAgain(person: person) &#125; else &#123; return greet(person: person) &#125;&#125;print(greet(person: "Tim", alreadyGreeted: true))// Prints "Hello again, Tim!" 无返回值函数函数也可以没有返回值。这个 greet(person:) 函数版本就没有返回值，而是将结果直接打印出来：12345func greet(person: String) &#123; print("Hello, \(person)!")&#125;greet(person: "Dave")// Prints "Hello, Dave!" 注意严格意义来说, greet(person:) 函数 仍然 返回一个值，只是这个返回值没有被定义。函数返回值没有定义时，默认是返回 Void 类型。它是一个简单的空元祖，可以被写做 () 。 调用函数时，它的返回值可以被忽略：1234567891011func printAndCount(string: String) -&gt; Int &#123; print(string) return string.count&#125;func printWithoutCounting(string: String) &#123; let _ = printAndCount(string: string)&#125;printAndCount(string: "hello, world")// prints "hello, world" and returns a value of 12printWithoutCounting(string: "hello, world")// prints "hello, world" but does not return a value 第一个函数 printAndCount(string:) 打印一个字符串，然后返回这个字符串的字符集数量。 第二个函数 printWithoutCounting(string:) 调用第一个函数，忽略了第一个函数的返回值。 所以当调用第二个函数时， 信息仍然被第一个函数打印了，但第一个函数的返回值确没被使用。 注意返回值可以被忽略， 但函数的返回值还是需要接收。 一个有返回值的函数的返回值不允许直接丢弃不接收，如果你尝试这样做，编译器将给你抛出错误。 多返回值函数你可以用一个元祖类型包装多个值来作为一个函数的返回值。 下面这个 minMax(array:) 函数，它找出参数数组中的最大整数和最小整数：123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 这个 minMax(array:) 函数返回一个包含了两个整型 Int 的元祖。 它们的键名分别是 Max 和 Min，所以你可以通过这个键名来访问这两个值。 minMax(array:) 方法先定义了两个变量 currentMin 和 currentMax ，分别存储这数组中第一个元素。 然后迭代数组，检查每一个值是否比最小值小或比最大值大，如果是则分别记录这个值。 最后，找出的最小值和最大值被包装在一个元祖中返回。因为这个元祖的成员值被作为函数返回值的一部分，最大值和最小值能通过点语法来直接被访问。123let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)")// Prints "min is -6 and max is 109" 注意这个从函数返回的元祖的成员不需要在被指定键名，因为它们的键名已经被作为函数返回类型的一部分而指定。 可选元祖返回类型如果从函数返回的元祖类型有可能为空， 你可以用一个可选元祖来指示这个返回值可能为 nil 。你可以在元祖返回类型后面加上一个 ? 问号来表示返回值可能为空， 例如 (Int, Int)? 或 (String, Int, Bool)?。 注意一个可选的元祖类型例如 (Int, Int)? 和元祖值可选例如 (Int?, Int?) 是不同的。 对于前者是整个元祖可能为空，而后者则是元祖内每一个独立的元素可能为空。 上面这个 minMax(array:) 函数返回了一个包含两个 Int 值的元祖。然而，这个函数没有对传递进来的数组进行任何安全性的检查。 如果这个数组为空， 这个 minMax(array:) 函数在尝试访问数组第一个元素时，将在运行时触发一个数组越界的错误。 为了处理空数组这种情况，将 minMax(array:) 方法的返回值标记为可选类型。如果数组为空，将返回 nil ：12345678910111213func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 你也能用可选值绑定的方法来检查 minMax(array:) 方法是否返回一个有效值：1234if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125;// Prints "min is -6 and max is 109" 函数的参数标签和参数名每一个参数都由一个 参数标签 和一个 参数名 构成。 参数标签被用在调这个方法时； 每一个参数标签写在参数的前面。参数名被用在函数的具体实现中。 默认参数的参数标签可以不写，用参数名来作为参数标签。1234func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // 在函数体内， 变量 firstParameterName 和 变量 secondParameterName 所对应的值分别是第一个和第二个参数传递进来的&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 所有的参数必须有一个唯一的名称。 尽管多个参数可以有相同的参数标签， 但唯一的参数标签将使你的代码可读性更好。 明确参数标签参数标签在参数名前面， 通过一个空格 来分隔：123func someFunction(argumentLabel parameterName: Int) &#123; // 在函数体内，变量 parameterName 的值对应是参数传递进来的&#125; 参数标签省略如果一个参数不需要参数标签，可以用下划线_ 来代替之前的参数标签。1234func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123; // 在函数体中，变量 firstParameterName 和 secondParameterName 分别对应第一个和第二个参数的值&#125;someFunction(1, secondParameterName: 2) 参数默认值你可以给函数的任何参数提供一个默认值，通过写在参数类型后面。 如果提供了默认值，你就可以在调用时省略给这个参数传值。12345func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // 调用时如果你没有给第二个参数传值，那么变量 parameterWithDefault 的值默认就是 12 。&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // 变量 parameterWithDefault 的值是 6someFunction(parameterWithoutDefault: 4) // 变量 parameterWithDefault 的值是 12 可变参数可变参数 接受 0 个或多个具体相同类型的值。调用时，你可以用一个可变参数来代表这些有着不确定数量的多个参数。在参数类型后面跟上 3 个点 ... 来表示参数的数量可变。 传入函数体内的可变参数可以被当做一个数组类型来使用。 下面这个例子中，变量名 numbers 表示的一系列可变参数（每一个的类型为 Double ）被合并成更合适的数组类型 [Double] 。 函数 arithmeticMean() 为传入的一系列数字计算出平均值：1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3，5 个数的平均值是 3arithmeticMean(3, 8.25, 18.75)// returns 10.0，3 个数的平均值是 10.0 注意一个函数至多只能有一个可变参数。 传入传出参数函数参数默认是常量，不能直接修改其值。编译器会报错如果你尝试在函数体内修改传入参数的值。 但如果你执意要修改这个参数值， 并希望在函数执行完成后修改的值仍然有效， 那么用 传入传出参数 来代替普通参数。 传入传出参数通过在参数类型前加上 inout 关键字来定义。传入传出参数可以有一个初始值， 传入函数后值将被修改，在函数执行完传出后，这个变量的初始值就会被替换完成。 更多有关传出传出参数的行为和编译器优化的详细讨论，请移步In-Out Parameters。 传入传出参数只支持变量。常量或字面量将不被允许做为参数传递，因为它们都不能被修改。 传值时，在参数名前面加上 &amp; 符号，来表示它能在函数体内被修改。 注意传入传出参数不能有默认值，并且可变参数也不能被标记 inout 。 下面这个 swapTwoInts(_:_:) 函数，有两个参数名分别为 a 和 b 的传入传出参数：12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoInts(_:_:) 函数简单地交换两个传入参数 a 和 b 的值。 首先将参数 a 的值存储于临时变量 temporaryA中，然后将 b 的值赋值给 a ， 最后将临时变量 temporaryA 的值再赋值给 b。 你可以通过传递两个Int类型的参数来调用swapTwoInts(_:_:)函数来交换彼此的值。 需要注意的是， 在调用 swapTwoInts(_:_:)方法时，变量 someInt 和 anotherInt 需要加上 &amp; 符号：12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// 打印 "someInt is now 107, and anotherInt is now 3" 上面这个例子中，即便变量 someInt 和 anotherInt 被定义在函数体外部，但通过参数传递，swapTwoInts(_:_:) 函数还是修改了彼此的初始值。 注意在同一个函数中，传入传出参数和返回值不一定要同时存在。上面这个例子中， swapTwoInts 函数没有返回值， 但变量 someInt 和 anotherInt 的初始值仍然被修改了。 传入传出参数为函数影响函数体外部的作用域提供了一种可选的方式。 函数类型每个函数的具体 函数类型 由它的参数类型和返回类型共同决定。 举个例子：123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 使用函数类型Swift 中，函数类型的使用和其他类型一样。 举个例子， 你可以定义 一个函数类型的常量或变量，并给其赋一个函数类型的值：1var mathFunction: (Int, Int) -&gt; Int = addTwoInts 你可以理解为： 『 定义了一个函数类型的 mathFunction 变量，「 它接收两个 Int 类型的参数，并返回一个 Int 值。」并把 addTwoInts 函数关联给这个变量。』 mathFunction 的类型和 addTwoInts(_:_:) 函数的类型相同，所以Swift 的类型检查器将允许这样的赋值。 现在，你就可以用 mathFunction 变量来调用 addTwoInts(_:_:) 函数了：12print("Result: \(mathFunction(2, 3))")// 打印 "Result: 5" 有着相同类型的不同方法可以赋值给同一个变量：123mathFunction = multiplyTwoIntsprint("Result: \(mathFunction(2, 3))")// 打印 "Result: 6" 像其他类型一样，当然你给一个变量或常量赋一个函数类型的值时， Swift 将帮你自动推导出值的真实类型：12let anotherMathFunction = addTwoInts// anotherMathFunction 被会自动推导成 `(Int, Int) -&gt; Int` 类型 函数类型作为参数你可以把 (Int, Int) -&gt; Int 类型的函数作为一个参数传递给另一个函数。 当这个函数被调用时，这使得具体实现逻辑被当做一个函数传递给了这个函数的调用者。 下面这个例子，打印 math functions 函数相加后的结果：12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// 打印 "Result: 8" 这个例子中， 定义了一个 printMathResult(_:_:_:) 的函数，它接收三个参数。第一个参数是一个叫 mathFunction的函数，其类型是 (Int, Int) -&gt; Int。 你可以为第一个参数传递一个类型是 (Int, Int) -&gt; Int 的函数作为参数。 第二个和第三个参数 a 和 b 都是 Int 类型。这两个变量被当做第一个函数参数的输入值传入给了第一个参数。 当调用 printMathResult(_:_:_:) 时，分别传递 addTwoInts(_:_:) 函数 和另外两个值 3 和 5。 3 和 5 被当做第一个函数的参数传递给它做了相加，最终打印结果 8。 函数 printMathResult(_:_:_:) 的作用是打印 addTwoInts(_:_:) 函数的返回值。 它不关心传入函数的具体实现 — 只关心传入函数的正确类型。 这使得 printMathResult(_:_:_:) 函数把一些具体的功能逻辑实现推给了它的调用者。 返回类型为函数类型你可以把一个函数类型作为另一个函数的返回类型。在这个返回箭头后面 (-&gt;) 跟上你要返回的具体函数类型。 下面这个例子分别定义了两个 stepForward(_:) 和 stepBackward(_:) 简单的函数。 stepForward(_:) 函数返回一个在其输入值上 +1 后的值， stepBackward(_:) 方法返回一个在其输入值上-1 后的值，两个方法的函数类型都是 (Int) -&gt; Int ：123456func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125; chooseStepFunction(backward:) 函数的返回类型是 (Int) -&gt; Int。 该函数根据一个 Bool 类型值来判断是返回 stepForward(_:) 还是 stepBackward(_:) 函数：123func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 现在你可以通过调用 chooseStepFunction(backward:) 并为其输入一个 Bool 类型的值来获得一个递增或递减的函数:123var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// 变量 moveNearerToZero 现在引用着 stepBackward() 函数 在上面这个例子中，最终返回递增还是递减函数由 currentValue 变量的值来决定。 变量 currentValue 的初始值是 3 ， currentValue &gt; 0 比较结果就为 true，所以调用 chooseStepFunction(backward:) 后返回 stepBackward(_:) 函数。 常量 moveNearerToZero存储着该函数的返回函数。 现在 moveNearerToZero 表示这个递减函数，从输入值递减至 0 ：1234567891011print("Counting to zero:")// Counting to zero:while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// 3...// 2...// 1...// zero! 嵌套函数到目前为止，在本章中你遇到的这些函数例子都是 全局函数 ， 它们被定义在全局作用域上。 当然，你也可以在函数体内定义一个函数，来做为该函数的 嵌套函数 。 虽然嵌套函数默认对函数体外部是透明的，但仍然可以被该函数调用。 函数也可以通过返回其内部的嵌套函数来使这个被嵌套的函数在外部作用域可以被使用。 你可以重写上面的 chooseStepFunction(backward:) 函数，来返回和使用其内部的嵌套函数：123456789101112131415161718func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// `moveNearerToZero` 变量引用着 `stepForward()` 函数while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// -4...// -3...// -2...// -1...// zero!]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 控制流]]></title>
    <url>%2F2018%2F10%2F09%2FSwift%E6%8E%A7%E5%88%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Swift 提供了多种控制流结构。其中包含 while 循环来执行多次任务； if、 guard 和 switch 语句来执行特定条件下不同的代码分支； 还有 break 和 continue 语句使控制流跳转到你代码中的其他位置。 Swift 还提供了 for-in 循环用来更简便的遍历数组（arrays）， 字典（dictionaries），区间（ranges），字符串（strings），和其他序列类型。 Swift 的 switch 语句比其他的类 C 语言更加强大。case 可以匹配多种不同的模式，包括间隔匹配（interval matches），元祖（tuples），和转换到特定类型。switch 语句的 case 体中匹配的值可以绑定临时常量或变量，在每个 case 中也可以使用 where 来实现更复杂的匹配情况。 For-In 循环可以使用 for-in 循环来遍历序列中的所有元素，例如数组中的所有元素，数字的范围，或者字符串的字符。 你也可以通过遍历一个字典来访问它的键值对。遍历字典时其中的每个元素都会返回成 (key, value) 元组（Tuple）的形式， 你也可以在 for-in 循环中显式的命名常量来分解 (key, value)元组。 在下面的例子中，字典中的值（Key）被分解为 animalName 常量，字典中的值（Value）被分解为 legCount 常量。1234567let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]for (animalName, legCount) in numberOfLegs &#123; print("\(animalName)s have \(legCount) legs")&#125;// ants have 6 legs// cats have 4 legs// spiders have 8 legs 上面的例子中，常数 index 的值在每次循环开始时都会自动赋值。因此，index 不需要在使用前进行声明。只要声明循环时，包含了该常量，就会对其进行隐式声明，不需要使用声明关键词 let 。 如果你不需要使用区间中的所有值，你可以使用 - 替代变量名来忽略对应的值。12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print("\(base) to the power of \(power) is \(answer)")// Prints "3 to the power of 10 is 59049" 在一些情况中你可能不想使用包含两个端点的闭区间。想象在手表表面上画每分钟的刻度标记。你想要从 0 分钟开始画 60 个刻度标记。可以使用半开区间操作符（..&lt;）来包含下界但不包含上界。1234let minutes = 60for tickMark in 0..&lt;minutes &#123; // 每分钟渲染一个刻度线（60 次）&#125; 一些用户在他们的界面上可能想要更少的刻度标记。他们可能更喜欢每 5 分钟一个刻度。使用 stride(from:to:by:) 函数可以跳过不需要的标记。1234let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) &#123; // 每 5 分钟打一个标记（0, 5, 10, 15 ... 45, 50, 55）&#125; 通过 stride(from:through:by:) 使用闭区间也是可以的：12345let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) &#123; // 每 3 小时打一个标记（3, 6, 9, 12）&#125; While 循环一个 while 循环会一直执行一组语句直到条件变为 false 。这类循环最适合第一次循环前不知道循环的次数的情况。Swift 提供两种类型的 while 循环： while 在每次循环开始时判断条件。 repeat-while 在每次循环结束时判断条件。 下方是 repeat-while 循环的一般形式：123repeat &#123; statements&#125; while condition 条件语句Swift 提供两种条件语句：if 语句和 switch 语句。通常，使用 if 语句来执行结果可能性较少的简单条件；switch 语句则更适合于有较多组合的更复杂的条件，而且，当需要使用模式匹配来判断执行合适的代码段时，switch 语句会更有用。 Ifif 语句最简单的形式只有一个 if 条件，而且只有当这个条件为 true 时才会执行对应的代码。 Switchswitch 语句会将某一个值与其它几种可能匹配的模式进行比较，然后它会执行第一个匹配成功的模式下对应的代码块。当可能的情形非常多时，应该使用 switch 语句替代 if 语句。 switch 语句最简单的形式是将一个值和另外一个或几个同类型的值进行比较。123456789switch some value to consider &#123;case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else&#125; 每个 switch 语句必须是 可穷尽的。 也就是说，判断的类型的每个可能的值都要有一个 switch 的分支（case）与之对应。为每个可能的值创建一个分支是不合理的，你可以定义一个默认分支来覆盖没有单独处理的其他所有值。这个默认分支使用 default 关键字声明，并且必须放在最后。 下面例子使用 switch 语句匹配名为 someCharacter 的单个小写字符：12345678910let someCharacter: Character = "z"switch someCharacter &#123;case "a": print("The first letter of the alphabet")case "z": print("The last letter of the alphabet")default: print("Some other character")&#125;// 打印 "The last letter of the alphabet" 不存在隐式的贯穿与 C 语言和 Objective-C 中的 switch 语句相反，Swift 中的 switch 语句在执行完一个分支后不会「贯穿」到下一个分支。相反，整个 switch 语句一旦完成第一个匹配的 switch 分支就会结束，而不需要明确的 break 语句。这使得 Swift 中的 switch 语句比 C 语言中的更加安全、易用，并且避免了错误地执行多个 switch 分支的情况。 注意虽然在 Swift 中 break 不是必须的，你可以使用 break 语句来匹配和忽略特定的分支或者或者在分支全部执行前跳出。更多细节，查看 Switch 语句中的 Break。 区间匹配 switch 中分支匹配的值也可以是一个区间。这个例子使用数字区间来匹配任意数字对应的自然语言格式：12345678910111213141516171819let approximateCount = 62let countedThings = "moons orbiting Saturn"let naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = "no"case 1..&lt;5: naturalCount = "a few"case 5..&lt;12: naturalCount = "several"case 12..&lt;100: naturalCount = "dozens of"case 100..&lt;1000: naturalCount = "hundreds of"default: naturalCount = "many"&#125;print("There are \(naturalCount) \(countedThings).")// Prints "There are dozens of moons orbiting Saturn." 元组你可以使用元组在同一个 switch 语句中测试多个值。可以针对不同的值或值的间隔来测试元组的每个元素。或者使用下划线（_）来匹配任何可能的值，这也被称为通配符模式。 下面的示例声明了一个 (x, y) 点，该变量是类型为 (Int, Int) 的元组，并将其显示在示例后面的图上。1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print("\(somePoint) is at the origin")case (_, 0): print("\(somePoint) is on the x-axis")case (0, _): print("\(somePoint) is on the y-axis")case (-2...2, -2...2): print("\(somePoint) is inside the box")default: print("\(somePoint) is outside of the box")&#125;// 打印 "(1, 1) is inside the box" 与 C 语言不同，Swift 允许同一个值符合多个 switch 分支。实际上，在这个例子中，点 (0, 0) 匹配所有四个分支。但是，如果匹配多个分支，则始终使用第一个匹配的分支。点 (0, 0) 首先匹配 case (0, 0)，因此所有其他的匹配分支都被忽略。 值绑定switch 分支可以将其匹配的一个值或多个值赋值给临时的常量或变量，常量或变量可以在 case 主体中使用。这个行为被称为值绑定，因为值在 case 主体中被绑定给临时的常量或变量。 下面的示例声明了一个 (x, y) 点，其类型为 (Int, Int) 的元组，并且该点展示在示例后面的图上：12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125;// 打印 "on the x-axis with an x value of 2" 三个 switch 分支声明了占位符常量 x 和 y，暂时从 anotherPoint 中获取一个或多个元组值。第一个分支 case (let x, 0) 匹配任何 y 值为 0 的点，并把 x 的值赋值给临时常量 x。同样地，第二个分支 case (0, let y) 匹配任何 x 值为 0 的点，并把 y 的值赋值给临时常量 y。 在声明临时常量之后，可以在 case 代码块中使用该常量。这里，它们用来打印点的分类。 这个 switch 语句没有 default 分支。在最后一个分支 case let (x, y) 中，声明了一个可以匹配任何值的有两个占位符常量的元组。因为 anotherPoint 是有两个值的元组，这个分支可以匹配剩余的任何值，并不需要 default 分支来使 switch 语句穷举。 Whereswitch 分支中可以使用 where 子句来检测额外的条件。12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("(\(x), \(y)) is just some arbitrary point")&#125;// 打印 "(1, -1) is on the line x == -y" 三个 switch 分支声明了占位符常量 x 和 y，它们从 yetAnotherPoint 中获取两个元组值。这些常量用作 where 子句的一部分，用来创建一个动态分类器。只有当 where 子句满足计算值为 true 时，switch 分支才匹配当前的 point。 与前一个示例一样，最后一个 case 匹配所有剩余的值，所以不需要 default 分支来使 switch 语句穷举。 复合分支在 case 后面写多个模式可以把多个分支共享在同一个主体中，每个模式用逗号隔开。如果任何一个模式匹配，那么这个分支就是匹配的。如果模式太多，可以把模式写为多行。比如：1234567891011let someCharacter: Character = "e"switch someCharacter &#123;case "a", "e", "i", "o", "u": print("\(someCharacter) is a vowel")case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z": print("\(someCharacter) is a consonant")default: print("\(someCharacter) is not a vowel or a consonant")&#125;// 打印 "e is a vowel" switch 语句的第一个分支匹配英语中的所有五个小写元音。同样，第二个分支匹配所有的小写辅音。最后，default 分支匹配其余字符。 复合分支也可以包含值绑定。复合分支的所有模式必须包含在同一组值绑定中，并且每个绑定必须从复合分支的所有模式中获取相同类型的值。这样确保无论复合分支中哪个部分匹配，分支主体的代码总是可以访问绑定的值，并且确保值总是有相同的类型。12345678let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print("On an axis, \(distance) from the origin")default: print("Not on an axis")&#125;// 打印 "On an axis, 9 from the origin" 上面的 case 中有两个模式：(let distance, 0) 匹配 x 轴上的点，(0, let distance) 匹配 y 轴上的点。两种模式都包含 distance 的绑定，distance 在两种模式中是一个整数，这意味着 case 主体中的代码总是可以访问 distance 的值。 控制转移语句控制转移语句通过将控制从一段代码转移到另一段代码来改变代码的执行顺序。Swift 中有五个控制转移语句： continue break fallthrough return throw Continuecontinue 语句告诉循环停止正在做的事情，并在循环的下一次迭代开始时再启动。它仿佛在说「我完成了当前的循环迭代」而没有完全离开循环。 下面的示例从小写字符串中删除所有的元音和空格，并创建一个神秘的谜语：123456789101112let puzzleInput = "great minds think alike"var puzzleOutput = ""let charactersToRemove: [Character] = ["a", "e", "i", "o", "u", " "]for character in puzzleInput &#123; if charactersToRemove.contains(character) &#123; continue &#125; else &#123; puzzleOutput.append(character) &#125;&#125;print(puzzleOutput)// 打印 "grtmndsthnklk" 上面的代码只要匹配到元音或空格时就调用 continue 关键字，使循环的本次迭代立即结束并跳到下一次迭代的开始。 Breakbreak 语句立即结束整个控制流语句的执行，当你想在 switch 或循环中提前结束时，可以在 switch 或循环中使用 break 语句。 在循环语句中使用 Break在循环语句中使用时，break 立即结束循环的执行，并把控制转移到循环右括号（}）后面的代码上。不执行来自当前循环迭代的下一步代码，并且不再开始循环的迭代。 在 Switch 语句中使用 Break在 switch 语句中使用时，break 会使 switch 语句立即结束执行，并把控制转移到 switch 语句的右括号（}）后面的代码上。 此行为可用于匹配和忽略 switch 语句中的一个或多个分支。 因为 Swift 的 switch 语句是穷举的并且不允许空分支，所以有时需要故意匹配并忽略一个分支使你的意图明确。 你可以将 break 语句作为要忽略的分支的整个主体来使用。当该分支与 switch 语句匹配时，分支中的 break 语句使 switch 语句立即结束执行。 注意如果 switch 分支只包含注释会报编译时错误。 注释不是语句，不会使 switch 分支被忽略。总是使用 break 语句来忽略 switch 分支。 贯穿在 Swift 中， switch 语句的每个分支在判断结束后不会「贯穿」到下一个分支。即，整个 switch 语句会在第一个匹配的分支语句执行完成后终止。相反地，C 语言明确要求在每个 switch 分支结束时手动添加 break 语句来防止贯穿。相对而言，默认没有贯穿使得 Swift 中的 switch 语句更加简洁，可读性更强，并可以因此避免错误地执行多个 switch 分支。 如果需要像 C 语言中那样的贯穿行为，你可以在分支中逐个添加 fallthrough 关键字。 下面这个例子就利用了贯穿 fallthrough 来给数字添加描述。1234567891011let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;print(description)// 打印 "The number 5 is a prime number, and also an integer." 注意 fallthrough 关键字不会检查 switch 语句中下一个分支的条件，它只是让代码在执行的过程中直接进入下一个分支 (或 default 分支) 中的语句, 就像 C 语言中 switch 语句的标准行为。 带标签语句在 Swift 中，你可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用 break 语句来提前结束整个代码块。因此，显式地指明 break 语句想要终止的是哪个循环体或者条件语句，会很有用。类似地，如果你有许多嵌套的循环体，显式指明 continue 语句想要影响哪一个循环体也会非常有用。 为了实现这个目的，你可以使用标签（ statement label ）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用 break 加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用 break 或者 continue 加标签，来结束或者继续这条被标记语句的执行。 声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键字（ introducor keyword ），并且该标签后面跟随一个冒号。下面是一个针对 while 循环体的标签语法，同样的规则适用于所有的循环体和条件语句。123label name: while condition &#123; statements&#125; 提前退出guard 语句和 if 语句一样，根据表达式的布尔值执行语句。 使用 guard 语句要求条件必须为真才能执行 guard 语句之后的代码。 和 if 语句不同，guard 语句总是有一个 else 分支 — 如果条件不为真，则执行 else 分支中的代码。123456789101112131415161718192021func greet(person: [String: String]) &#123; guard let name = person["name"] else &#123; return &#125; print("Hello \(name)!") guard let location = person["location"] else &#123; print("I hope the weather is nice near you.") return &#125; print("I hope the weather is nice in \(location).")&#125;greet(person: ["name": "John"])// 打印 "Hello John!"// 打印 "I hope the weather is nice near you."greet(person: ["name": "Jane", "location": "Cupertino"])// 打印 "Hello Jane!"// 打印 "I hope the weather is nice in Cupertino." 如果满足 guard 语句的条件，则在 guard 声明的结束括号后继续执行代码。 当任何变量或常量在使用可选绑定作为条件被赋值后，它的值都可用于 guard 语句后的其余代码块。 如果不满足该条件，则执行 else 分支内的代码。 该分支必须转移控制以退出 guard 语句后的代码块。 它可以通过控制转移语句来执行此操作，例如 return ， break ， continue 或 throw ，也可以调用一个无返回值的函数或方法，例如 fatalError(_:file:line:) 。 相比于使用 if 语句进行判断，使用 guard 语句可以提高代码的可读性。 它可以让你编写出连贯执行的代码，而不必将其包装在 else 块中，并且让你更加从容地处理异常代码。 检测 API 可用性Swift 内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的 API。 编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。 我们在 if 或 guard 语句中使用 可用性条件（availability condition)去有条件的执行一段代码，来在运行时判断调用的 API 是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。12345if #available(iOS 10, macOS 10.12, *) &#123; // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API&#125; else &#123; // 使用先前版本的 iOS 和 macOS 的 API&#125; 以上可用性条件指定， if 语句的代码块仅仅在 iOS 10 或 macOS 10.12 及更高版本才运行。最后一个参数，*，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本， if 语句的代码块将会运行。 在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是 iOS , macOS , watchOS , 和 tvOS —请访问声明属性来获取完整列表。 请参阅 Declaration Attributes。除了指定像 iOS 8 或 macOS 10.10 的大版本号，也可以指定像 iOS 11.2.6 以及 macOS 10.13.3 的小版本号。12345if #available(platform name version, ..., *) &#123; APIs 可用，语句将执行&#125; else &#123; APIs 不可用，语句将不执行&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>控制流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 集合类型]]></title>
    <url>%2F2018%2F10%2F08%2FSwift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。 注意Swift 的 Arrays、Sets 和 Dictionaries 类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章节。 集合的可变性如果创建一个 Arrays、Sets 或 Dictionaries 并且把它分配成一个变量，这个集合将会是可变的。这意味着你可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 Arrays、Sets 或 Dictionaries 分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。 注意在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。 数组数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。 注意Swift 的 Array 类型被桥接到 Foundation 中的 NSArray 类。 创建一个空数组我们可以使用构造语法来创建一个由特定数据类型构成的空数组：123var someInts = [Int]()print("someInts is of type [Int] with \(someInts.count) items.")// 打印 "someInts is of type [Int] with 0 items." 创建一个带有默认值的数组Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（ count）和适当类型的初始值（ repeating）传入数组构造函数：12var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0] 通过两个数组相加创建一个数组我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：12345var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 用数组字面量构造数组我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：1[value 1, value 2, value 3] 访问和修改数组我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。 可以使用数组的只读属性 count 来获取数组中的数据项数量：123var shoppingList = ["Eggs", "Milk"]print("The shopping list contains \(shoppingList.count) items.")// 输出 "The shopping list contains 2 items."（这个数组有2个项） 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0：123456if shoppingList.isEmpty &#123; print("The shopping list is empty.")&#125; else &#123; print("The shopping list is not empty.")&#125;// 打印 "The shopping list is not empty."（shoppinglist 不是空的） 也可以使用 append(_:) 方法在数组后面添加新的数据项：12shoppingList.append("Flour")// shoppingList 现在有3个数据项，有人在摊煎饼 除此之外，使用加法赋值运算符（+=）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：1234shoppingList += ["Baking Powder"]// shoppingList 现在有四项了shoppingList += ["Chocolate Spread", "Cheese", "Butter"]// shoppingList 现在有七项了 可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：12var firstItem = shoppingList[0]// 第一项是 "Eggs" 您也可以使用下标语法来同时更改一系列值，即使替换值集的长度与所替换的范围不同。下面的例子用 Bananas 和 Apples 取代了Chocolate Spread，Cheese 和 Butter：12shoppingList[4...6] = ["Bananas", "Apples"]// shoppingList 现在有6项 调用数组的 insert(_:at:) 方法来在某个具体索引值之前添加数据项：123shoppingList.insert("Maple Syrup", at: 0)// shoppingList 现在有7项// "Maple Syrup" 现在是这个列表中的第一项 类似的我们可以使用 remove(at:) 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：1234let mapleSyrup = shoppingList.remove(at: 0)// 索引值为0的数据项被移除// shoppingList 现在只有6项，而且不包括 Maple Syrup// mapleSyrup 常量的值等于被移除数据项的值 "Maple Syrup" 注意如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的 count 属性进行比较来在使用某个索引之前先检验是否有效。除了当 count 等于 0 时（说明这是个空数组），最大索引值一直是 count -1 ，因为数组都是零起索引。 如果我们只想把数组中的最后一项移除，可以使用 removeLast() 方法而不是 remove(at:) 方法来避免我们需要获取数组的 count 属性。就像后者一样，前者也会返回被移除的数据项，类似于remove(at:)方法,removeLast()返回被删除的项。1234let apples = shoppingList.removeLast()// 数组的最后一项被移除了// shoppingList 现在只有5项，不包括 Apples// apples 常量的值现在等于 "Apples" 字符串 数组的遍历我们可以使用 for-in 循环来遍历所有数组中的数据项：123for item in shoppingList &#123; print(item)&#125; 如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。 enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：12345678for (index, value) in shoppingList.enumerated() &#123; print("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 集合（Sets）集合（Set）用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。 注意Swift 的 Set 类型被桥接到 Foundation’s 中的 NSSet 类。关于使用 Foundation 和 Cocoa 中 Set的知识，参见Bridging Between Set and NSSet。 集合类型的哈希值一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 Int 类型的，相等的对象哈希值必须相同，比如 a == b ,因此必须 a.hashValue == b.hashValue。 Swift 的所有基本类型（比如 String、Int、Double 和 Bool ）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值（在枚举有讲述）默认也是可哈希化的。(https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html) 注意你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 Hashable 协议。符合 Hashable 协议的类型需要提供一个类型为 Int 的可读属性 Hashable 。由类型的 Hashable 属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。因为 Hashable 协议符合 Equatable 协议，所以遵循该协议的类型也必须提供一个是否相等运算符（==）的实现。这个 Equatable 协议要求任何符合 == 实现的实例间都是一种相等的关系。也就是说，对于 a, b, c三个值来说，== 的实现必须满足下面三种情况：a == a (自反性)a == b 意味着 b == a (对称性)a == b &amp;&amp; b == c 意味着 a == c (传递性) 集合类型语法Swift 中的 Set 类型被写为 Set&lt;Element&gt; ，这里的 Element 表示 Set 中允许存储的类型，和数组不同的是，集合没有等价的简化形式。 创建和构造一个空的集合你可以通过构造器语法创建一个特定类型的空集合：123var letters = Set&lt;Character&gt;()print("letters is of type Set&lt;Character&gt; with \(letters.count) items.")// 打印 "letters is of type Set&lt;Character&gt; with 0 items." 此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的 Set：1234letters.insert("a")// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型 用数组字面量创建集合你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。 下面的例子创建一个称之为 FavoriteGenres 的集合来存储 String 类型的值：12var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"]// favoriteGenres 被构造成含有三个初始值的集合 由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个 Set 并且该数组字面量中的所有元素类型相同，那么你无须写出 Set 的具体类型。 FavoriteGenres 的构造形式可以采用简化的方式代替：1var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"] 访问和修改一个集合你可以通过 Set 的属性和方法来访问和修改一个 Set。 为了找出一个 Set 中元素的数量，可以使用其只读属性 count 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 你可以通过调用 Set 的 insert(_:) 方法来添加一个新元素 你可以通过调用 Set 的 remove(_:) 方法去删除一个元素，如果该值是该 Set 的一个元素则删除该元素并且返回被删除的元素值，否则如果该 Set 不包含该值，则返回 nil 。另外，Set 中的所有元素可以通过它的 removeAll() 方法删除。 使用 contains(_:) 方法去检查 Set 中是否包含一个特定的值 遍历一个集合你可以在一个 for-in 循环中遍历一个 Set 中的所有值。 Swift 的 Set 类型没有确定的顺序，为了按照特定顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符&lt;对元素进行比较的结果来确定。 集合操作你可以高效地完成 Set 的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。 基本集合操作下面的插图描述了两个集合a和b以及通过阴影部分的区域显示集合各种操作的结果。 使用 intersection(_:) 方法根据两个集合中都包含的值创建的一个新的集合。 使用 symmetricDifference(_:) 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。 使用 union(_:) 方法根据两个集合的值创建一个新的集合。 使用 subtracting(_:) 方法根据不在该集合中的值创建一个新的集合。123456789101112let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9] 集合成员关系和相等下面的插图描述了三个集合 a 、 b 和 c ,以及通过重叠区域表述集合间共享的元素。集合 a 是集合 b 的父集合，因为 a 包含了 b 中所有的元素，相反的，集合 b 是集合 a 的子集合，因为属于 b 的元素也被 a 包含。集合 b 和集合 c 彼此不关联，因为它们之间没有共同的元素。 使用是否相等运算符（==）来判断两个集合是否包含全部相同的值。 使用 isSubset(of:) 方法来判断一个集合中的值是否也被包含在另外一个集合中。 使用 isSuperset(of:) 方法来判断一个集合中包含另一个集合中所有的值。 使用 isStrictSubset(of:) 或 isStrictSuperset(of:) 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。 使用 isDisjoint(with:) 方法来判断两个集合是否不含有相同的值（是否没有交集）。 12345678910let houseAnimals: Set = ["🐶", "🐱"]let farmAnimals: Set = ["🐮", "🐔", "🐑", "🐶", "🐱"]let cityAnimals: Set = ["🐦", "🐭"]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true 字典字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。 注意Swift 的 Dictionary 类型被桥接到 Foundation 的 NSDictionary 类。更多关于在 Foundation 和 Cocoa 中使用 Dictionary 类型的信息，请参阅 Bridging Between Dictionary and NSDictionary. 字典类型简化语法Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义，其中 Key 是字典中键的数据类型， Value 是字典中对应于这些键所存储值的数据类型。 注意一个字典的 Key 类型必须遵循 Hashable 协议，就像 Set 的值类型。 我们也可以用 [Key: Value] 这样简化的形式去创建一个字典类型。并且这也是我们的首选方式。 创建一个空字典我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：12var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典 如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作 [:] （中括号中放一个冒号）：1234namesOfIntegers[16] = "sixteen"// namesOfIntegers 现在包含 1 个键值对namesOfIntegers = [:]// namesOfIntegers 又是一个空的 [Int: String] 类型字典 用字典字面量创建字典一个键值对是一个 key 和一个 value 的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：1[key 1: value 1, key 2: value 2, key 3: value 3] 访问和修改字典我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。 和数组一样，我们可以通过字典的只读属性 count 来获取某个字典的数据项数量 使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：123var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]airports["LHR"] = "London"// airports 字典现在包含 3 个元素 还可以使用下标语法来更改特定键相关联的值：12airports["LHR"] = "London Heathrow"// LHR 应的值被改为 "London Heathrow" 作为另一种下标方法，字典的 updateValue(_:forKey:) 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例， updateValue(_:forKey:) 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的， updateValue(_:forKey:) 这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。 updateValue(_:forKey:) 方法会返回对应值的类型的可选值。举例来说：对于存储 String 值的字典，这个函数会返回一个 String 或者可选 String 类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 nil。1234if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; print("The old value for DUB was \(oldValue).")&#125;// 打印 "The old value for DUB was Dublin." 我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回 nil：123456if let airportName = airports["DUB"] &#123; print("The name of the airport is \(airportName).")&#125; else &#123; print("That airport is not in the airports dictionary.")&#125;// 打印 "The name of the airport is Dublin Airport." 我们还可以使用下标语法来通过给某个键的对应值赋值为 nil 来从字典里移除一个键值对：1234airports["APL"] = "Apple International"//"Apple Internation" 不是真的 APL 机场，删除它airports["APL"] = nil// APL 现在被移除了 此外， removeValue(forKey:) 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回 nil ：123456if let removedValue = airports.removeValue(forKey: "DUB") &#123; print("The removed airport's name is \(removedValue).")&#125; else &#123; print("The airports dictionary does not contain a value for DUB.")&#125;// 打印 "The removed airport's name is Dublin Airport." 字典遍历我们可以使用 for-in 循环来遍历某个字典中的键值对。每一个字典中的数据项都以 (key, value) 元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：12345for (airportCode, airportName) in airports &#123; print("\(airportCode): \(airportName)")&#125;// YYZ: Toronto Pearson// LHR: London Heathrow 通过访问 keys 或者 values 属性，我们也可以遍历字典的键或者值：1234567891011for airportCode in airports.keys &#123; print("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123; print("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受 Array 实例的 API 的参数，可以直接使用 keys 或者 values 属性构造一个新数组：12345let airportCodes = [String](airports.keys)// airportCodes 是 ["YYZ", "LHR"]let airportNames = [String](airports.values)// airportNames 是 ["Toronto Pearson", "London Heathrow"] Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 keys 或 values 属性使用 sorted() 方法。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 字符串和字符]]></title>
    <url>%2F2018%2F10%2F07%2FSwift%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Swift中的字符串都是String类型的，字符是Character类型，看似简单，其中的细节可不少(•́ω•̀ ٥) Swift 字符串是由 String 类型来表示。 String 的内容可以用多种方式读取，包括作为一个 Character 值的集合。 注意Swift 的字符串类型与 Foundation 的 NSString 类型进行了无缝桥接。 Foundation 也可以对 String 进行扩展，暴露在 NSString 中定义的方法。 这就意味着，你可以不用进行类型转换，就能在 String 中调用 NSString 的这些方法。更多关于在 Foundation 和 Cocoa 中使用 String 的信息，查看 Bridging Between String and NSString 。 初始化一个空字符串创建一个空 String 有两种方式，给一个变量赋值一个空字符串或者使用下面的语法初始化一个 String 实例对象：123var emptyString = "" // 空字符串var anotherEmptyString = String() // 初始化语法//这是两个空字符串，他们等价 可以通过检查 String 的布尔类型的属性 isEmpty 来判断该字符串的值是否为空：1234if emptyString.isEmpty &#123; print("Nothing to see here")&#125;// 打印 "Nothing to see here" 字符串是值类型Swift 中的 String 类型是一种 值类型 。如果你创建了一个新的 String 值， String 值在传递给方法或者函数时会被 拷贝，在给常量或者变量赋值的时候也是一样。在任何情况下，都会对现存的 String 值创建新拷贝，并对新拷贝进行传递或赋值操作。值类型在 结构体和枚举是值类型 中有详细描述。 Swift 默认 String 拷贝的行为是为了保证在函数或方法中传递的是 String 值，不管该值是从哪里来，你都绝对拥有这个 String 值。你可以确定你传递的这个字符串不会被修改，除非你自己去修改它。 另一方面，Swift 编译器优化了字符串的使用，实际拷贝只会在需要的时候才进行。这意味着你把字符串当做值类型的同时也能够得到很棒的性能。 使用字符你可以使用 for-in 循环来遍历 String 中每个的 Character 的值：123for character in "Dog!🐶" &#123; print(character)&#125; 你可以使用 Character 类型声明，并赋值一个单字符值创建一个独立的字符常量或变量：1let exclamationMark: Character = "!" String 的值可以使用一个 Character 值类型的数组作为变量来进行初始化：1234let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]let catString = String(catCharacters)print(catString)// 输出 "Cat!🐱" 字符串和字符的拼接可以使用加号（ + ）将 String 的值加（或 拼接 ）在一起创造出一个新的值 你可以使用加等于赋值符号（ += ）将一个 String 的值追加到一个已经存在的 String 变量中 你可以使用 String 的 append() 方法将一个 Character 的值追加到一个 String 变量中 注意你不能将字符串 String 或字符 Character 拼接到 Character 变量中，因为 Character 的值只能包含单个字符。 字符计数在一个字符串中使用 count 属性去计算 Character 类型值个数 注意，Swift 对 Character 类型值使用了拓展字母集，意味着字符串的拼接和修改不一定会持续影响字符串字符个数。 例如，你初始化一个拥有四个字符的字符串 cafe，然后再追加一个 COMBINING ACUTE ACCENT (U+0301) 字符在末尾 ，最终形成的字符串还是拥有四个字符，并且最后一个字符是 é，而不是 e：12345678var word = "cafe"print("the number of characters in \(word) is \(word.count)")// 打印 "the number of characters in cafe is 4"word += "\u&#123;301&#125;" // 拼接重音符，U+0301print("the number of characters in \(word) is \(word.count)")// 打印 "the number of characters in café is 4" 注意拓展字母集可以由多个不同的 Unicode 标量组成，这就意味着相同字符和相同字符的不同表示需要占据不同的内存空间去存储，因此，在字符串的各种表示中 Swift 字符占据的内存并不一样。造成的结果就是，字符串的字符数量并不能通过遍历该字符串去计算，并用于确定该字符串的拓展字符集边界。如果你正在处理特别长的字符串，要意识到为了确定该字符串的字符个数， count 属性必须要遍历完整个字符串中的全部 Unicode 标量。 count 属性返回的字符个数不会一直都与包含相同字符的 NSString 的 length 属性返回的字符个数相同。 NSString 的长度是基于 UTF-16 表示的字符串所占据的 16 位代码单元的个数决定，而不是字符串中的拓展字母集个数决定。 访问和修改字符串你可以通过字符串的方法和属性来访问和修改它，或者通过下标语法。 字符串索引每个 String 值都有一个关联的 索引类型， String.Index，对应着字符串中每个 Character 的位置。 正如上面提到的，不同的字符可能需要不同大小的内存存储，所以为了确定每个 Character 的具体位置，你必须从 String 的开头遍历每个 Unicode 标量到结束。因此，Swift 字符串不能使用整型值索引。 使用 startIndex 属性可以访问 String 的第一个 Character 的位置。使用 endIndex 属性可以访问 String 的最后一个 Character 的位置。因此， endIndex 属性并不是字符串下标的有效参数。如果 String 是空串， startIndex 和 endIndex 就是相等的。 你可以通过使用 String 的 index(before:) 和 index(after:) 方法，访问给定索引的前一个和后一个索引。要访问离给定索引偏移较多的索引，你可以使用 index(_:offsetBy:) 方法，避免多次调用 index(before:) 和 index(after:) 方法。 使用 indices 属性会创建一个包含全部索引的范围，用来在一个字符串中访问单个字符。1234for index in greeting.indices &#123; print("\(greeting[index]) ", terminator: "")&#125;// 打印 "G u t e n T a g ! " 注意你可以在任意一个遵循 Collection 协议的类型里面，使用 startIndex 和 endIndex 属性或者 index(before:) ， index(after:) 和 index(_:offsetBy:) 方法。如上文所示是使用在 String 中，你也可以使用在 Array 、Dictionary 和 Set 中。 插入和删除在一个字符串指定位置插入单个字符，使用 insert(:at:) 方法，而要插入另一个字符串的内容时，使用 insert(contentsOf:at:) 方法。 删除一个字符串指定位置的单个字符，用 remove(at:) 方法，而要删除指定范围的子字符串时，用 removeSubrange(_:) 注意你可以在任何遵循 RangeReplaceableCollection 协议的类型上使用 insert(_:at:)， insert(contentsOf:at:)，remove(at:)，和 removeSubrange(_:) 方法。除了这里说到的 String，还包括 Array，Dictionary，和 Set 等集合类型。 子字符串当你从字符串中获取一个子字符串 —— 例如使用下标或者 prefix(_:) 之类的方法 —— 就可以得到一个 Substring 的 实例 ，而非另外一个 String 。Swift 里的 Substring 的绝大部分函数都跟 String 一样，意味着你可以使用同样的方式去操作 Substring 和 String 。然而，跟 String 不同的是，你只有在短时间内需要操作字符串时，才会使用 Substring 。当你需要长时间保存结果时，就把 Substring 转化为 String 的实例：1234567let greeting = "Hello, world!"let index = greeting.firstIndex(of: ",") ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值是 "Hello"// 把结果转化为 String 以便长期存储。let newString = String(beginning) 就像 String ，每一个 Substring 都会在内存里保存字符集。而 String 和 SubString 的区别在于性能优化上，Substring 可以重用原 String 的内存空间，或者另一个 Substring 的内存空间（String 也有同样的优化，但如果两个 String 共享内存的话，它们就会相等）。这一优化意味着你在修改 String 和 Substring 之前都不需要消耗性能在内存复制。就像前面说的那样，Substring 不适合长期存储 —— 因为它重用了原 String 的内存空间，原 String 的内存空间必须保留直到它的 Substring 不再被使用为止。 上面的例子， greeting 是一个 String，意味着它在内存里有一片空间保存字符集。而由于 beginning 是 greeting 的 Substring，它重用了 greeting 的内存空间。相反，newString 是一个 String —— 它是使用 Substring 创建的，拥有一片自己的内存空间。下面的图展示了他们之间的关系： 注意 String 和 Substring 都遵循 StringProtocol协议， 这意味着操作字符串的函数使用 StringProtocol 会更加方便。你可以传入 String 或 Substring 去调用函数。 比较字符串Swift 提供了三种方式来比较文本值: 字符串和字符相等、前缀相等、后缀相等。 字符串和字符相等如果他们的扩展字形集是 统一码等价，则这两个 String 值 (或者两个 Character 值) 被认为是等同的。如果它们具有相同的语言含义和外观，即使它们是由不同语义的 Unicode 标量组成，扩展字形集也是等同的。 例如，LATIN SMALL LETTER E WITH ACUTE (U+00E9) 在规范上等同于 LATIN SMALL LETTER E (U+0065) 加上 COMBINING ACUTE ACCENT (U+0301)。这两个扩展字形簇都是表示字符 é 的有效方法，因此它们被认为是规范等价的 相反，英文中的 LATIN CAPITAL LETTER A (U+0041，或 「A」)，和俄文中的 CYRILLIC CAPITAL LETTER A (U+0410, 或 「А」) 不相等。这两个字符在视觉上相似，但具有不同的语言含义 注意Swift 中的字符串和字符比较不是区域敏感的。 前缀和后缀比较可以使用字符串的 hasPrefix(_:) 和 hasSuffix(_:) 方法来检查一个字符串是否有特定的前缀、后缀。这两个方法接收一个 String 类型的参数返回一个布尔值。 注意 hasPrefix(_:) 和 hasSuffix(_:) 方法都是在每个字符串的扩展字符集中逐个字符进行比较， 如本文所述 字符串和字符的比较。 字符串的 Unicode 表示形式当一个 Unicode 字符串被写入文本文件或者一些其他存储时，字符串中的 Unicode 标量会用 Unicode 定义的几种 编码格式 编码。每一个字符串中的小块编码都叫做 代码单元。这些包括 UTF-8 编码格式 (编码字符串为 8 位的代码单元），UTF-16 编码格式 (编码字符串为16位的代码单元) ， 以及 UTF-32 编码格式 (编码字符串32位的代码单元) 。 Swift 提供几种不同的方式来访问字符串的 Unicode 表现形式。 你可以使用 for - in 对字符串进行便利， 进而访问其中单个 Character 字符值作为 Unicode 扩展的字符群集。 这个过程描述在 使用字符。 另外，也可以通过其他三种 Unicode 兼容的方式访问字符串的值： UTF-8 代码单元集合（利用字符串的 utf8 属性进行访问） UTF-16 代码单元集合 （利用字符串的 utf16 属性进行访问） 21 位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式（利用字符串的 unicodeScalars 属性进行访问）下面有 D ，o ，g , !! （DOUBLE EXCLAMATION MARK ，或Unicode 标量 U+203C ）和 🐶（DOG FACE，Unicode 标量为 U+1F436）组成的字符串中的每一个字符代表着一种不同的表示：1let dogString = "Dog‼🐶" UTF-8 表示形式你可以通过遍历 String 的 utf8 属性来访问他的 UTF-8 表示。这个属性是 string.UTF8View 类型的，UTF8View 是无符号 8 位（ UInt8 ）值得集合，每一个字节都对应一个字符串的 UTF-8 的表现形式： 12345for codeUnit in dogString.utf8 &#123; print("\(codeUnit) ", terminator: "")&#125;print("")// 打印 "68 111 103 226 128 188 240 159 144 182 " 上面的例子中，前三个 10 进制 codeUnit 值（68，111，103）代表了字符 D o 和 g ，他们的 UTF-8 表示和 ASCII 表示相同。接下来的三个 10 进制 codeUnit 值（226，128, 188）是 DOUBLE EXCLAMATION MARK 的 3 字节 UTF-8 表示形式。 最后四个 codeUnit 值 (240, 159, 144, 182) 是 DOG FACE 的 4 字节 UTF-8 表示形式。 UTF-16 表示形式你可以通过遍历 String 的 utf16 属性来访问它的 UTF-16 表示形式。它是 String.UTF16View 类型的属性, 它是一个无符号 16 位 (UInt16) 值的集合，每一个 UInt16 都是一个字符的 UTF-16 表示形式: 12345for codeUnit in dogString.utf16 &#123; print("\(codeUnit) ", terminator: "")&#125;print("")// 打印 "68 111 103 8252 55357 56374 " 同样，前三个 codeUnit 值 (68, 111, 103) 代表了字符 D, o, 和 g, 他们的 UTF-16 代码单元和 UTF-8 完全相同 (因为这些 Unicode 标量表示 ASCII 字符)。 第四个 codeUnit 值 (8252) 是一个等于十六进制 203C 的十进制值，这代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量值 U+203C 。这个字符在 UTF-16 中可以用一个代码单元表示。 第五个和第六个 codeUnit 值 (55357 和 56374) 是 DOG FACE 字符的 UTF-16 表示形式。 第一个值为 U+D83D (十进制值为 55357 ) 第二个值为 U+DC36 (十进制值为 56374 )。 Unicode 标量表示形式你可以通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示。 它是一个 UnicodeScalarView 类型的属性, UnicodeScalarView 是 UnicodeScalar 类型的值得集合。 每一个 UnicodeScalar都有一个 value属性，可以返回对应的 21 位数值，用 UInt32 值来表示: 12345for scalar in dogString.unicodeScalars &#123; print("\(scalar.value) ", terminator: "")&#125;print("")// 打印 "68 111 103 8252 128054 " 前三个 UnicodeScalar 值 (68, 111, 103) 的 Value 属性依旧代表着字符 D, o, and g。 第四个 codeUnit 值 (8252) 依旧是一个等于十六进制 203C 的十进制值, 这代表了 DOUBLE EXCLAMATION MARK字符的 Unicode 标量 U+203C。 第五个 UnicodeScalar 值的 Value 属性, 128054, 是一个十六进制 1F436 的十进制表现, 它代表 DOG FACE 字符的 Unicode 标量 U+1F436。 作为查询他们的 value属性的一种替代方法, 每一个 UnicodeScalar 值也可以用来构建一个新的 String 值, 比如在字符串插值中使用:12345678for scalar in dogString.unicodeScalars &#123; print("\(scalar) ")&#125;// D// o// g// ‼// 🐶]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>字符串</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2 基本运算符]]></title>
    <url>%2F2018%2F10%2F06%2FSwift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Swift 支持大多数标准 C 语言运算符，并改进了一些功能，很简单(´･(00)･｀) 基本运算符Swift 支持大多数标准 C 语言运算符，并改进了一些功能以消除常见的编码错误。为防止误用等号运算符 (==)， 赋值运算符 (=)并不返回值。为了避免数值在计算时超出它们类型允许值的范围，出现意外结果，算术运算符 (+, -, *, /, % 等) 会检测且不允许值溢出。你可以使用 Swift 值溢出运算符来选择值溢出行为，相关描述请参见 溢出运算符。 Swift 还提供了 C 语言中不存在的范围运算符，如 a..&lt;b 和 a...b ，作为表示区间值的快捷方式。 术语运算符分为一元的、二元的和三元的： 一元 运算符运算单个目标值（例如 -a ）。一元 前缀 运算符显示在目标值之前（例如 !b），而一元 后缀 运算符显示在目标值之后（例如 c!）。 二元 运算符运算两个目标值（例如 2 + 3）并且是 中缀的 因为它们显示在两个目标值之间。 三元 运算三个目标值。像 C ， Swift 只有一个三元运算符，就是三元条件运算符（a ? b : c）。 被运算符影响的值叫做 操作数 。在表达式 1 + 2 中， + 号是二元运算符， 1 和 2 是它的两个操作数。 赋值运算符与 C 和 Objective-C 中的赋值运算符不同，Swift 的赋值运算符本身不返回值。下方的语句是无效的：123if x = y &#123; // 这是无效的，因为 x = y 不返回值&#125; 算术运算符与 C 以及 Objective-C 不同的是， 在 Swift 中, 默认情况下算术运算符不允许值溢出。但是你能通过用 Swift 的溢出符号 (正如 a &amp;+ b)去加入值溢出的行为。参考 Overflow Operators。加号同样支持String的连接：1"hello, " + "world" // 等于 "hello, world" 取余运算符注意取余运算符 (%) 在别的一些语言中的意思是 模运算符 。不过，严格意义上在 Swift 中，对于负数来说它是取余运算而不是模运算。 一元减号运算符123let three = 3let minusThree = -three // minusThree 等于 -3let plusThree = -minusThree // plusThree 等于 3, or "--3" 一元加号运算符1let c = a + b 复合赋值运算符和 C 类似：123var a = 1a += 2// a 现在等于 3 注意复合赋值运算符没有返回值。例如，你不能这么写 let b = a += 2。 比较运算符Swift 支持所有的标准 C 系比较运算符 注意Swift 还提供了两个恒等运算符（=== 和 !==），你可以用它们来判断两个对象引用是否指向同一个实例。 如果两个元组有着相同数量和类型的元素，你就可以比较它们。元组的比较是从左向右，逐个比较的，直到遇到不相等的元素为止。也就是说，每次元素比较的返回值都决定着整个元组比较的结果。如果所有对应元素都相等，那么这两个元组就是相等的。比如：123(1, "zebra") &lt; (2, "apple") // true，因为 1 小于 2，"zebra" 和 "apple" 没有被比较。(3, "apple") &lt; (3, "bird") // true，因为 3 等于 3，而且 "apple" 小于 "bird"。(4, "dog") == (4, "dog") // true，因为 4 等于 4，而且 "dog" 等于 "dog"。 如果一个操作符可以被用来比较两个元组的每个对应元素，那么它就可以被用来比较这两个元组。比如像以下代码演示的那样，你可以比较两个类型为 (String, Int) 的元组，因为 String 和 Int 类型的值都可以用 &lt; 操作符比较。与之形成对比的是，两个 (String, Bool) 类型的元组不能用 &lt; 比较，因为 &lt; 运算符在 Bool 上没有定义。12("blue", -1) &lt; ("purple", 1) // 正确，比较的结果为 true("blue", false) &lt; ("purple", true) // 错误，因为两个布尔类型的值不能用 &lt; 比较。 注意Swift 标准库只定义了用于比较拥有七个以内元素的元组的操作符，如果想要比较两个拥有七个或更多元素的元组，你就需要自己来实现该运算符。 三元运算符它的形式是 question ? answer1 : answer2 空合运算符空合运算符 (a ?? b) 在可选型 a 有值的时候就为它解包，在 a 为 nil 的时候就返回默认值 b 。表达式 a 一定要是可选型。表达式 b 和 a 存储的值类型一定要一致。 空合运算符是下面代码的简写：1a != nil ? a! : b 注意如果 a 的值不是 nil ，那么 b 的值将不会被计算。这就是 短路求值。 区间运算符Swift 包含的一些 区间运算符，其实是数值区间表达式的缩写。 闭合区间运算符闭合区间运算符 (a...b) 表示从 a 到 b 的区间，并且包含 a 和 b。a 一定不能大于 b。 当你想遍历一个区间中的值加以利用时，那么闭合区间运算符就在合适不过了，比如在用 for-in 循环的时候：12345678for index in 1...5 &#123; print("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 半开区间运算符半开区间运算符（a..&lt;b）定义了一个从 a 到 b 但不包括 b 的区间。之所以称之为半开，是因为该区间只包含第一个值，而不包含最后一个值。与闭区间运算符一样，a 绝不可以大于 b。如果 a 等于 b 的话，就表示该区间为空。 当你作用于一个索引从 0 开始的列表（比如数组）时，如果你想要从 0 开始，一直数到（但不过包括）列表的长度，半开区间就显得非常有用了:123456789let names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; print("Person \(i + 1) is called \(names[i])")&#125;// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack 单侧区间闭区间运算符还有另外一种形式，表示向一个方向尽可能地延伸——例如在数组中，一个包含了从索引为 2 开始一直到结尾的所有元素的区间。在这些情况下，你可以省去该区间操作符一侧的值。因为这种区间只有一侧有值，所以它们叫作 单侧区间，例如：123456789101112for name in names[2...] &#123; print(name)&#125;// Brian// Jackfor name in names[...2] &#123; print(name)&#125;// Anna// Alex// Brian 半开区间操作符如果只保留其终值就是它的单侧形式了。就像它的完全形式一样，终值本身并不是该区间的一部分，例如：12345for name in names[..&lt;2] &#123; print(name)&#125;// Anna// Alex 单侧区间不仅仅能被用于下标，还能用于一些其它情况。你无法遍历省略了初始值的单侧区间，因为那种形式没有明确指出遍历应该从哪儿开始。不过你可以遍历没有终值的单侧区间；需要注意的是，因为区间的延伸特性，请务必确保你的遍历循环里有一个清晰的用于结束循环的条件。你还可以检查一个单侧区间是否包含某个特定的值，就像下边代码展示的那样。1234let range = ...5range.contains(7) // falserange.contains(4) // truerange.contains(-1) // true 逻辑运算符Swift 支持基于 C 语言中的 3 种标准逻辑运算符 逻辑非（!a） 逻辑与（a &amp;&amp; b） 逻辑或（a || b） 混合逻辑运算你可以组合多个逻辑运算符来创建更长的复合表达式：123456if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123; print("Welcome!")&#125; else &#123; print("ACCESS DENIED")&#125;// 打印 "Welcome!" 注意Swift 逻辑运算符 &amp;&amp; 和 || 都是左关联的，这意味着具有多个逻辑运算符的复合表达式首先判断最左边的子表达式。 显性括号括号清楚地表明了前两个值被视为整体逻辑中独立可能状态的一部分。这个复合表达式的结果并没有改变，但是其整体的意图对于读者来说更加清晰了。易读性总是优先于简洁性；在可以帮助你明确意图的地方，使用括号吧。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
        <tag>基本运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2（基础篇要点）]]></title>
    <url>%2F2018%2F10%2F05%2FSwift%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Swift4.2基础篇摘要ʕ•͡ω•ʔ 本章节只是简单的摘录文档里的重要内容（或者是没记住的- -）如果想从头开始看Swift还是直接看官方文档比较好 高级类型除了属性的类型，Swift引入了Objective-C中没有的高级类型，比如元组。元组可以让你创建与传递值的分组。你可以使用元组将函数中的多个值作为单个复合值返回。 可选类型Swift 还引入了可以处理缺省值的可选类型。可选类型表示「要么 有 值，并且等于 X」，「要么 没有 值」 。使用可选类型与在 Objective-C 中将指针和 nil 一起使用很相似，但是，可选类型适用于任何类型，不仅仅是类。可选类型不仅比 Objective-C 中的 nil 指针更安全，更具表现力，它还是 Swift 众多强大特性中的核心。 类型安全Swift 是一门 类型安全 的语言，这意味着它有助于明确代码中的值的类型。如果代码中需要一个 String，类型安全可以防止你错误地传递给它一个 Int。同样的，类型安全可以防止你意外地将一个可选的 String 传递给一个需要非可选 String 的代码片段。在开发过程中，类型安全可以帮你尽早捕捉并修复错误。 注释Swift 中的多行注释可以相互嵌套使用 浮点数Double 类型可以精确到小数点后15位，而 Float 类型只有6位。如果两种类型都能使用的情况下，优先使用 Double 类型 。 类型推断因为有了类型推断，Swift 和 C 以及 Objective-C 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。Swift 在推断浮点值的时候始终会选择 Double （而不是Float）。 数值型字面量整数型字面量可以写作： 十进制数，没有前缀 二进制数，前缀为 0b 八进制数，前缀为 0o 十六进制数，前缀为 0x 类型转换SomeType(ofInitialValue) 是 Swift 中初始化一个对象的默认方式，在这个过程中需要传入一个初始值。而在底层实现中，UInt16 有一个接收 UInt8 类型的初始化构造器，所以这个构造器是用来转换 UInt8 类型 到 UInt16 类型 的。你不能在这传入 任何 类型，因为必须是 UInt16 初始化构造器允许的类型才可以。扩展现有类型的初始化构造器，让其接收新的类型（包括你自己自定义的类型）的内容在 Extensions 中可以找到。 类型别名类型别名 就是给现有类型定义了一个另外的名字。你可以使用 typealias 关键字来声明类型别名。 布尔值Swift 有一个基础 布尔 类型 Bool. 布尔值也被称为 逻辑值, 因为它们只能是真或假。 Swift 提供两个布尔常量，true 和 false 。 元组元组 将多个值组合在一起成为一个复合值。元组里面的值可以是任何类型，不需要是相同的类型。你可以将一个元组的内容 分解 为单独的常量或变量，然后你就可以正常使用它们了：1234567let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String), 等于 (404, "Not Found")let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// 打印 "The status code is 404"print("The status message is \(statusMessage)")// 打印 "The status message is Not Found" 如果你只需要元组里的一部分值的话，分解元组的时候使用一个下划线（_） 来忽略元组里面的值：123let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// 打印 "The status code is 404" 此外，使用从零开始的下标来访问元组里单个元素的值：1234print("The status code is \(http404Error.0)")// 打印 "The status code is 404"print("The status message is \(http404Error.1)")// 打印 "The status message is Not Found" 定义元组时，你可以为元组中的单个元素命名：1let http200Status = (statusCode: 200, description: "OK") 如果你在元组里为元素命名了，那么你就可以通过元素名称去获取元素的值：\1234print("The status code is \(http200Status.statusCode)")// 打印 "The status code is 200"print("The status message is \(http200Status.description)")// 打印 "The status message is OK" 元组作为函数的返回值的时候十分有用。一个尝试获取一个网页的函数可能会返回一个 (Int, String) 类型来表示结果的成功或失败。相比于返回一个类型的单个值作为结果，通过返回包含两个不同类型值的一个元组作为返回值，这个函数让自己的返回值提供了更多有用的信息。更多信息，参考 函数参数与返回值 注意元组在临时组织的值的时候很有用。元组并不适合用于创建复杂数据结构。如果你的数据结构比较持久而不是临时使用的话，使用类或者结构体，而不是元组。更多信息，参考 结构体和类. 可选类型注意C 和 Objective-C 中没有可选类型的概念。最接近的是Objective-C 中的一个方法除了返回对象之外还会返回nil 的能力，nil表示缺省一个合法的对象。然而，这仅仅对对象起作用 — 对结构体，基本C 类型或者枚举类型并不起作用。对于这些类型，Objective-C 的方法通常会返回一个特殊的值(比如 NSNotFound)来表示值缺省的情况。这种方式假设方法的调用者知道和记得对特殊值进行处理和检查。Swift 的可选类型可以让你表明任何类型的值缺省的情况，而不需要特殊值。 非可选状态下的常量或变量不能使用 nil 。在某些特定条件下，如果你代码中的常量或变量需要指定为空值，则始终将其声明为适当类型的可选值。 如果你定义了一个可选变量但没有赋值，变量将自动设置为 nil 注意Swift 里的 nil 不同于 Objective-C 里的 nil 。 在 Objective-C 里, nil 是一个指向空对象的指针。在 Swift 里， nil 不是指针，而是某种特定类型值的缺失。 任意 类型都可以设置为 nil, 而不仅仅是对象类型。 if 语句和强制解析你可以在通过一个 if 语句里比较可选项和 nil 的方式来确定其是否包含确定值 。执行比较需要用到“等于”操作符 == ，或者“不等于”操作符!=。 如果一个可选项包含值，那么它就被认为不等于 nil:1234if convertedNumber != nil &#123; print("convertedNumber contains some integer value.")&#125;// 打印 "convertedNumber 包含整型值." 一旦你确认可选项包含值，你就可以通过使用在可选项名称后添加!的方式来访问它的值。感叹号的含义是：“我知道这个可选项绝对有值，请使用它。”这就是对可选项值的强制解析。1234if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).")&#125;// 打印 "convertedNumber 包含整型值 123." 可选绑定使用可选绑定 optional binding 来判断一个可选类型是否包含值，如果包含就赋给一个临时的常量或者变量使这个值可用。可选绑定可以被用到if和while语句中，用来检差一个值是否是可选类型， 并且将值提取为一个常量或者变量。 if 语句的可选绑定可以写成如下这样：123if let constantName = someOptional &#123; statements&#125; 你可以使用可选绑定而不是强制解包来重写 可选类型 章节的 possibleNumber 例子：123456if let actualNumber = Int(possibleNumber) &#123; print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")&#125; else &#123; print("\"\(possibleNumber)\" could not be converted to an integer")&#125;// Prints ""123" has an integer value of 123" 上面的代码可以被理解为： “如果通过 Int(possibleNumber)返回的可选 Int 类型包含一个值，那么就创建一个名为 actualNumber 的新的常量并把可选类型中的值赋给它。” 如果转换成功，常量 actualNumber 可以被用在 if 语句的第一个分支中。它已经被可选类型 包含的 值初始化，因此不再需要使用后缀 ! 来获取它的值。在这个例子中，actualNumber 被简单地用来打印转换的结果。 注意在 if 语句中使用可选绑定的常量和变量仅在 if 语句内可用。相反，在 guard 语句中创建的常量和变量在 guard语句后的代码中也可以使用，如上所述 Early Exit. 隐式展开可选项通过在声明的类型后边添加一个叹号 String! 而非问号 String? 来书写隐式展开可选项。隐式展开可选项是后台中通用的可选项，但是同样也可以像非可选值来使用，每次访问的时候不需要展开。接下来的例子中展示了在访问被明确为 String 的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：12345let possibleString: String? = "An optional string."let forcedString: String = possibleString! //要求使用感叹号let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要使用感叹号 你可以把隐式展开可选项当做在每次访问他的时候被给与了自动进行展开的权限。相比于在每次调用他的时候添加一个叹号，你可以再声明的时候呀添加一个叹号。 错误处理相比于可选项的通过值是否缺失来判断程序的执行正确与否，错误处理机制能允许你判断错误的形成原因，如果需要的话，还能将你的代码中的错误传递到程序的其他地方。当一个函数遇到错误情况，他或 抛出 错误。这个函数的访问者会 捕捉 到这个错误并且做出适当的反应。123func canThrowAnError() throws &#123; // 这个函数可能会出错也可能不会出错&#125; 通过在函数声明过程中加入 throws 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，你需要再表达式前预置 try 关键字。 Swift 会自动将错误传递到他们的生效范围之内，直到他们被 catch 分局处理。123456do &#123; try canThrowAnError() // 无错误抛出&#125; catch &#123; // 有错误抛出&#125; do 语句创建了一个新的容器范围，可以让错误被传递到不止一个的 catch 分句处理。 下面的例子演示了如何利用错误处理机制处理不同的错误情况：123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 本例中，如果没有干净的盘子或某个原料缺失的话，makeASandwich() 函数会抛出一个错误。因为 makeASandwich() 函数抛出了错误，所以对它的调用被包裹在一个 try 表达式里。将函数调用包裹进一个 do 的语句里，任何抛出的错误都会被传播到提供的 catch 从句里。 如果没有抛出错误，eatASandwich() 方法将会被调用。如果抛出了错误，并且匹配到了 outOfCleanDishes 条件的话，washDishes() 函数就会被调用。如果匹配到了 SandwichError.missingIngredients 条件，buyGroceries(_:) 函数就会被调用，并且使用 catch 捕获的关联 String 值作为参数。 断言与先决条件断言 和 先决条件 是程序运行时发生的检查动作。你可以使用它们来检查代码被执行之前的一些必要条件是否被满足。如果断言或先决条件中布尔值的条件等于 true，代码将会像平常一样继续执行下去。如果条件等于 false，当前程序的状态将会是无效的，并且会导致代码执行停止，程序被终止。 断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。 调试断言使用 Swift 标准库中的 assert(_:_:file:line:) 函数来声明一个断言语句。可以向这个函数传入一个值为 true 或 false 的表达式以及如果条件为 false 的情况下的提示性信息。如下所示：123let age = -3assert(age &gt;= 0, "A person's age can't be less than zero.")// 因为 -3 小于 0，所以这个断言失败了 上面的例子中，如果 age &gt;= 0 语句结果为 true，代码将继续执行下去，也就是说 age 的值是非负的。如果 age 的值是负数，那么上面的代码中的 age &gt;= 0 语句将返回 false，这将导致断言失败，程序终止。 你可以省略断言提示信息 — 比如下面的代码，仅仅是单调地重复一下条件语句。1assert(age &gt;= 0) 如果代码中已经检查了条件的话，可以使用 assertionFailure(_:file:line:) 函数来表明断言已经失败。如下所示：1234567if age &gt; 10 &#123; print("You can ride the roller-coaster or the ferris wheel.")&#125; else if age &gt; 0 &#123; print("You can ride the ferris wheel.")&#125; else &#123; assertionFailure("A person's age can't be less than zero.")&#125; 强制执行先决条件只要条件可能会为 false 的时候，就使用先决条件。但代码必须 肯定 为 true 才能继续执行下去。例如，使用先决条件去检查下标是否越界或检查函数是否传入了合法的参数值。 通过调用 precondition(_:_:file:line:) 函数来声明一个先决条件。你可以向一个先决条件传入结果为 true 或 false 的表达式和当结果为 false 时的提示信息。例如：12// 判断下标...precondition(index &gt; 0, "Index must be greater than zero.") 你也可以使用 preconditionFailure(_:file:line:) 函数来表明执行的失败 — 例如，如果一个 switch 语句的默认条件命中了，但是所有有效的输入数据只会被其他条件处理。 注意如果你以不检查的编译模式( Ounchecked )模式进行编译，先决条件将不会起作用。编译器会假设先决条件总是为真，并会根据你的代码做相应的优化。然而，无论优化设置如何，fatalError(_:file:line:) 函数总会停止程序的执行。你可以在原型设计和开发的早期过程中使用 fatalError(_:file:line:) 函数来创建尚未实现的功能的存根，编写 fatalError(&quot;Unimplemented&quot;) 作为存根的实现。因为 fatal error 永远不会被优化，与断言和先决条件不同的是，你可以确保程序总是在遇到存根实现时停止。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2光速入门٩(๑>◡]]></title>
    <url>%2F2018%2F10%2F03%2FSwift%2F</url>
    <content type="text"><![CDATA[9月25日，Xcode10发布了！支持swift3和swift4，而如今swift也日趋成熟，使用swift开发的项目也越来越多。ʕ•̀ω•́ʔ✧是时候学swift了，一起来光速入门吧~ 版本兼容性swift采用了现代编程模式，以避免大量常见的低级编程错误： 变量永远会在被使用前完成初始化 对数组的索引操作会自动检查是否出现越界错误 整型数值会自动检查是否溢出 可选值确保nil值被正确处理 内存被自动管理 错误处理允许从异常故障控制恢复 当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享： 子字符串的操作返回的实例是Substring类型而不是String 在较少的地方会隐性增加@objc属性 同一文件中类型的拓展可以访问该类型中的私有成员 概述首先，从hello world开始用swift实现可太tm简单了用xcode创建一个swift blank项目，在playground中输入一句话1print("hello world!") 全局作用域中的代码会自动作为程序的入口，因此；不需要main()函数，同样的，你也不需要写;了。 简单值 lei声明常量var声明变量 123var num = 1num = 2let number = 3 swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，num是个整数，因为它的初始值是一个整数。 如果没有初始值，你又想声明类型，你只要在变量后声明类型，用:分割。 1let num3:Double = 1 swift有一种更简单的方式让值转为字符串：把值写在()内，在括号之前再加一个\1234567let str = "girlfriend"let sum1 = 1let sum2 = 0print("I used to have \(sum1) \(str)")print("and now I have \(sum1*sum2) \(str)")print("pretty girl check your wechat number and send it to me pls:)") 对于占用多行的字符串可以使用三个引号&quot;&quot;&quot;每行的来头缩进要和右引号的缩进相同12345let string = """hello~this my wechat number"""print(string) 使用[]来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号12345678var arr = ["my","name","is","hades"]arr[3] = "whz"var dic = [ "key1":"value1", "key2":"valeu2"]dic["key2"] = "value change" 使用初始化语法来创建一个空数组或者字典12let emptyArr = [String]()let emptyDic = [String:String]() 如果类型能被推断，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）12arr = []dic = [:] 控制流 使用if和switch来创建条件语句，使用for-in,while，以及repeat-while来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。123456789101112let numArr = [123,13,4,13,43,65]var totalNum = 0for tempNum in numArr &#123; if tempNum &lt; 50 &#123; totalNum -= 1 &#125; else&#123; totalNum += 1 &#125; print(totalNum)&#125;print("end of totalnum = \(totalNum)") 在if语句中，条件语句必须是布尔表达式，可以使用if和let来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为nil表示值缺失。在值得类型后面跟随一个?则表示这个值是可选的。12345678910111213141516var exampleStr:String? = "hello"print(exampleStr == nil)var name:String? = "hades"var greeting = "hello~"//name = "xiye"//name = nilif let nameTemp = name &#123; //如果类型转换成功，则将值赋值给nameTemp直接使用 greeting = "hello~ \(nameTemp)" print("nameTemp = \(nameTemp) name = \(name!)") print("( let nameTemp = name ) = true");&#125;else&#123; print("name = nil ") //强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有 print("( let nameTemp = name ) = false");&#125; 如果可选值为nil，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给let后的常量，这样代码中就可以使用这个值。 处理可选值得另一种方法是使用??操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。 1234567var nickName: String? = nil //"whz"let fullName: String = "hades"//nickName = "whz"//nickName = nillet informalGreeting = "hi~ \(nickName ?? fullName)"print(informalGreeting) oc中的nil和swift中的nilObjective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) ‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。1234567891011var people = "ex"switch people &#123;case "girl": print("hey~ could you give me your wechat number?")case "man","boy": print("oh...next pls")case let x where x.hasSuffix("x")://hasSuffix以指定后缀结束，hasPrefix以指定前缀开始 print("if time can come back...")default: print("hello stranger.")&#125; 在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。你可以为字典中的键值对起一组名字，并用for in语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。1234567891011121314151617let someNumbers = [ "key1":[2,4,1,5,31], "key2":[2,43,2,5,1,53], "key3":[2345,13,1,3,13,65]]var maxNum = 0;var maxName:String = ""for (keyInSomeNumbers,valueInSomeNumbers) in someNumbers &#123; for values in valueInSomeNumbers &#123; if values &gt; maxNum &#123; maxNum = values maxName = "\(keyInSomeNumbers)" &#125; &#125;&#125;print("\(maxName) \(maxNum)") 使用while来循环执行代码12345678910111213var n = 0while n &lt; 100 &#123; n = n*n + 1&#125;print(n)var m = 0repeat&#123; m = m + 1 print("m = \(m)")&#125;while m &lt; 10print(m) 可以使用..&lt;来限定索引范围，并在循环中遍历该索引范围12345var total = 0for i in 1..&lt;4 &#123; total += i&#125;print(total) 函数和闭包使用func来声明一个函数。使用函数名和参数名来调用函数。使用-&gt;来指定函数返回值类型。1234func greet (person:String,day:String)-&gt; String&#123; return "Hello \(person),today is \(day)"&#125;print(greet(person: "whz", day: "thuesday")) 默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用_来表示来不使用参数标签。1234func greet(_ preson:String,on day:String)-&gt; String&#123; return "hello \(preson),today is \(day)"&#125;print(greet("hades", on: "friday")) 使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。1234567891011121314151617181920func function(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else&#123; min = score &#125; sum = sum + score &#125; return (min,max,sum)&#125;let result = function(scores: [1,31,413,356,1,376,463])print(result.max)print(result)print(result.2) 函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。123456789func returnFifteen()-&gt; Int &#123; var x = 10 func add()&#123; x += 5 &#125; add() return x&#125;print(returnFifteen()) 函数是一个类型。意味着函数可以作为其他函数的返回值。12345678func returnOneFunction() -&gt; ((Int) -&gt; Int)&#123; func returnOneInt(number:Int) -&gt; Int&#123; return number + 1 &#125; return returnOneInt&#125;var anotherFunction = returnOneFunction()print(anotherFunction(3)) 一个函数也可以作为参数传入另一个函数1234567891011121314func hasAnyMatches(list:[Int],condition:(Int)-&gt;Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; print(item) return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型与闭包函数体分离。12345678var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen)numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number print(111) return result&#125;) 写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。12345var temp = [3,41,5,1,51]let temp1 = temp.map&#123; num in num + 1&#125; swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写1234print(temp1)let temp2 = temp.map&#123; $0 + 1&#125; 对象和类通过在类名前加class关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 通过在类名称后面插入括号来创建类的实例。使用.语法的方式来访问实例中的属性和方法。1234var shape = Shape()shape.numberOfSides = 9var shapeDescription = shape.simpleDescription()print(shapeDescription) 当一个类的属性没有初始值，你就需要使用init来创建一个构造器。1234567891011class NamedShape &#123; var numberOfSides:Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func description() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 这里的self被用来区分name属性和构造器的name参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。如果你需要在对象被释放前执行一些清理的行为，可以使用deinit来创建一个折构器。 子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。 子类如果需要重写父类的方法，则需要使用override来标记—不使用override关键字来标记会导致编译器报错。编译器同样也会检查override标记的方法是否存在父类当中。1234567891011121314151617181920class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 5 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func description() -&gt; String &#123; return "A square with sides of length \(sideLength)" &#125;&#125;let test = Square(sideLength: 4.1, name: "test square")print(test.area())print(test.description()) 除了存储简单的属性，属性还可以拥有getter和setter123456789101112131415161718192021222324252627class EquilaterTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength = newValue / 3.0 &#125; &#125; override func description() -&gt; String &#123; return "this is a triangle with sides of length \(sideLength)" &#125;&#125;var triangle = EquilaterTriangle(sideLength: 4.3, name: "a triangle")print(triangle.perimeter)triangle.perimeter = 9print(triangle.sideLength) 在perimeter的setter中，新值被隐式的命名为newValue。你可以在set的括号后面，显式的提供一个名字。 注意EquilateralTriangle类的初始化有三个不同的步骤：- 1 设定子类的声明的属性值- 2 调用父类的构造器- 3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。 如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用willSet和didSet。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。123456789101112131415161718192021class TriangleAndSquare &#123; var triangle: EquilaterTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square:Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square = Square(sideLength: size, name: name) triangle = EquilaterTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: "test")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 40, name: "larger square")print(triangleAndSquare.triangle.sideLength) 在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用?。如果?前的值是nil,则?后面的所有内容都会被忽略，且整个表达式为nil。否则，可选项的值将被展开，然后?后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。12let optionalSquare: Square? = Square(sideLength: 2.3, name: "optional square")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。123456789101112131415161718192021enum Rank: Int &#123; case ace = 1 case two,three,four,five,six,seven,eight,nine,ten case jack,queen,king func simpleDescription() -&gt; String &#123; switch self &#123; case .ace: return "ace" case .jack: return "jack" case .queen: return "queen" case .king: return "king" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue 默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，Ace的原始值被显示赋值为1，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器来创建一个拥有原始值得枚举实例。如果在Rank中有与该原始值相匹配的枚举实例则返回该实例，没有则返回nil。123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。1234567891011121314151617enum Suit &#123; case spades,hearts,diamonds,clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .spades: return "spades" case .hearts: return "hearts" case .diamonds: return "diamonds" case .clubs: return "clubs" &#125; &#125;&#125;let hearts = Suit.heartslet haartsDescriotion = hearts.simpleDescription() 注意在上面例子中用了两种方法来调用hearts成员：给hearts指定一个常量时，枚举成员Suit.hearts需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式.hearts被调用，因为self的值已经确定是Suit类型。在值得类型已经被明确的情况下可以使用缩写。 如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。12345678910111213enum ServerResponse &#123; case result(String,String) case failure(String)&#125;let success = ServerResponse.result("6:00 am","8:00 pm")let failure = ServerResponse.failure("fail")switch success &#123;case let .result(sunrise,sunset): print(" sunrise is at \(sunrise) and sunset is at\(sunset)")case let .failure(message): print("fail - \(message)")&#125; 注意日出日落时间是如何从ServerResponse值中进行提取，并与 switch cases 相匹配的。 使用struct来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" &#125;&#125;let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用protocol来声明一个协议。mutating关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量1234protocol ExampleProtocol &#123; var simpleDescription: String&#123; get &#125; mutating func adjust()&#125; 类、枚举和结构都可以遵循协议12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = "a simple class" var anotherPriperty: Int = 69105 func adjust() &#123; simpleDescription += "now 100% adjusted" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct simpleStructure: ExampleProtocol &#123; var simpleDescription: String = "a simple sturcture" mutating func adjust() &#123; simpleDescription += "(adjusted)" &#125;&#125;var b = simpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明SimpleStructure时使用了关键字mutating来标记一个可以修改结构体的方法。而声明SimpleClass时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。 使用extension可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。 123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return "the number \(self)" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) 你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。 1234let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)//下面这句会报错print(protocolValue.anotherProperty) 尽管变量protocolValue在运行时类型为SimpleClass，但编译器依旧会把它的类型当做ExampleProtocol。这也就意味着，你不能随意访问在协议外的方法或属性。 错误处理你可以使用任何遵循Error协议的类型来表示错误。12345enum PrintError: Error &#123; case outOfPaper case noToner case onFire&#125; 使用throw跑出异常并且用throws来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。123456func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == "Never Has Toner" &#123; throw PrintError.noToner &#125; return "Job sent"&#125; 这里有几种方法可以处理异常。一种是使用do-catch。在do代码块里，你可以是用try在抛出的异常的函数前标记。在catch代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为error。123456do &#123; let printerResponse = try send(job: 1040, toPrinter: "Never Has Toner") print(printerResponse)&#125; catch&#123; print(error)&#125; 你可以提供多个catch代码块来处理特定的错误。你可以在catch后面一个一个模式，就像switch语句里面的case一样。12345678910 do &#123; let printerResponse = try send(job: 1440, toPrinter: "Gutenberg") print(printerResponse)&#125; catch PrintError.onFire &#123; print("I'll just put this over here, with the rest of the fire.")&#125; catch let printerError as PrintError &#123; print("Printer error: \(printerError)")&#125; catch &#123; print(error)&#125; 另外一种处理错误的方法是用try?去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为nil。否则，结果是一个包含了函数返回值的和选项。12let printerSuccess = try? send(job: 1883, toPrinter: "Mergenthaler")let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner") 使用defer来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用defer来简化代码。1234567891011121314var fridgeIsOpen = falselet fridgeContent = ["milk","eggs","leftovers"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result&#125;fridgeContains("milk")print(fridgeIsOpen) defer常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候defer会在该当前声明的作用域结束的时候执行优先级： 局部优先、同级自下而上12345678910111213141516171819func firstProcesses(_ isOpen: Bool) &#123; //作用域1 整个函数作用域 defer&#123; print("推迟操作🐢") &#125; print("😳") if isOpen == true &#123; //作用域2 if的作用域 defer&#123; print("推迟操作🐌") &#125; print("😁") &#125; print(111)&#125;firstProcesses(true) 泛型把名字写在尖括号里来创建一个泛型方法或者类型。12345678func makeArray&lt;Item&gt;(repeating item: Item,numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;makeArray(repeating: "knock", numberOfTimes: 4) 你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。123456enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100) 在类型名称后紧接where来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。1234567891011func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T,_ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1,2,3], [3]) 以上就是Swift4.2的概述，看完这些写一个简单的app已经不是难事了~但简单的app可不是我们的目标，还有很多语法上的细节需要深入研究学习，在后面的文章我会逐步更新语法上的细节ʕु•̫͡•ʔु ✧]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM是什么( ´ﾟωﾟ)？]]></title>
    <url>%2F2018%2F08%2F23%2FLLVM%2F</url>
    <content type="text"><![CDATA[LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙 简述LLVM 一个开源编译器架构，目前Xcode采用的就是LLVM架构。 Clang 由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。 GCC GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GNU GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。 在Xcode上使用GCC Xcode在C和C++上是支持使用GCC的，如下：具体参数的使用请参考：stackoverflow:Xcode上的GNU GCC 更多概念LLVM全名：Low Level Virtual Machine 直译：底层虚拟机/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.- 来自LLVM官网的介绍 LLVM官网 LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。 LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。 - 来自维基百科 LLVM on wiki 简单来说 LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。编译器是Clang，GCC，ICC，VC++等。 Xcode和LLVM Xcode3之前，用的是GCCXcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能Xcode4.6,LLVM升级到4.2版本Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成 ClangClang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang项目包括Clang前端和Clang静态分析器等。- 来自维基百科 Clang on wiki GCCGCC官网GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。 原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。 许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。- 来自维基百科 GCC on wiki GNUGNU官网GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。 作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。- 来自维基百科 GNU on wiki LLDBLLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。 GDBGNU Debugger 顾名思义支持编程语言有C、C++、Pascal以及FORTRAN在许多的类UNIX操作系统上都可以使用 词法分析lexical analysis /ˈlɛksɪkəl/词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。 语法分析syntactic analysis，也叫 parsing/sɪnˈtæktɪk əˈnæləsəs/ /ˈpɑːzɪŋ/语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述. 语法分析器parser通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。 源语言&amp;源程序Source language&amp;Source program被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。 目标语言&amp;目标程序Object language or Target language &amp; Object program or Target program编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。 中间语言（中间表示）Intermediate language（representation）在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。 文法Grammars/ˈgræməz/文法是用于描述语言的语法结构的形式规则。 token是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。 抽象语法树abstract syntax tree或者缩写为AST/ˈæbstrækt ˈsɪnˌtæks tri/抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。 具体CMD+BObjective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。 在使用Xcode按下cmd+B后，会经过以下流程：预处理（Pre-process）：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。 词法分析 （Lexical Analysis）：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 语法分析（Semantic Analysis）：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。 静态分析（Static Analysis）：使用它来表示用于分析源代码以便自动发现错误。 中间代码生成（Code Generation）：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。 优化（Optimize）：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。 生成目标文件（Assemble）：生成Target相关Object(Mach-o) 。 链接（Link）：生成 Executable 可执行文件。 关于此过程的详细测试，参考掘金 LLVM的具体操作请参考关于LLVM，这些东西你必须知道！ 基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 a+b 改为 a-(-b)将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。 所以基于LLVM可以完成： 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。 编写ClangPlugin，命名规范，代码规范，扩展功能。 编写Pass，代码混淆优化。 使用Clang进行开发详细参考IBM developerWorks Clang的特性相比于 GCC，Clang 具有如下优点： 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强： 支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。 支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。 以下是目前GCC和Clang对C++支持的情况： 更多参考C++ 编译器支持情况表 使用LLVM创建一个编译器首先参考这篇文章来写一个helloworldIBM developerWorks 关于LLVM IR的生成与创建IBM developerWorks]]></content>
      <categories>
        <category>编译相关</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
        <tag>GNU</tag>
        <tag>GCC</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本的入门（一）]]></title>
    <url>%2F2018%2F08%2F15%2FShell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。 Simple BB 为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。获取目标资源的路径，根据A中的行数进行循环find查找，找到就用cp命令替换，未找到的重定向输出到临时文件B最后打印B的内容，remove临时文件。其中对文本的处理使用了awk命令 脚本下载地址在我的github上 资源替换脚本 Shell介绍 Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。而我使用shell只是因为我用的mac - - Shell的工作原理 Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。 Shell的创建 1.打开文本编辑工具，输入一下内容#!/bin/bash echo &quot;Hello World&quot;2.保存为 hello world.sh在目录 A3.在终端cd到目录 A4.终端输入chmod +x ./hello world.sh （这一步是给脚本添加权限）5.执行脚本 ./hello world.sh 或者 直接把 hello world.sh拖入终端 这很简单，无图。 Shell中的变量变量的定义1example="a1" 或者 1example=a1 但是example=a 1 并不等同于 example=&quot;a 1&quot;因为&quot; &quot;（空格）在shell中用作指令的间隔example=a 1 其实只是将a负责给example 然后在输入了个1 这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！ 变量的访问在变量前加上$ 1echo $example Shell中的四则运算1234$a + $b$a - $b$a \* $b$a / $b 注意 乘法的时候需要进行转义= 赋值时，前后无空格而运算符号前后必须有空格 Shell中的其他运算符 =、==、!=、！、-o、-a 12-o 或-a 与 关系运算符 -eq 两个数相等返回true-ne 两个数不相等返回true-gt 左侧数大于右侧数返回true-It 左侧数小于右侧数返回true-ge 左侧数大于等于右侧数返回true-le 左侧数小于等于右侧数返回true 字符串运算符 = 两个字符串相等返回true!= 两个字符串不相等返回true-z 字符串长度为0返回true-n 字符串长度不为0返回true-d file 检测文件是否是目录，如果是，则返回 true-r file 检测文件是否可读，如果是，则返回 true-w file 检测文件是否可写，如果是，则返回 true-x file 检测文件是否可执行，如果是，则返回 true-s file 检测文件是否为空（文件大小是否大于0，不为空返回 true-e file 检测文件（包括目录）是否存在，如果是，则返回 true Shell字符串操作123456mtext="hello" #定义字符串mtext2="world"mtext3=$mtext" "$mtext2 #字符串的拼接echo $mtext3 #输出字符串echo $&#123;#mtext3&#125; #输出字符串长度echo $&#123;mtext3:1:4&#125; #截取字符串 Shell数组12345678array=(1 2 3 4 5) #定义数组array2=(aa bb cc dd ee) #定义数组value=$&#123;array[3]&#125; #找到某一个下标的数，然后赋值echo $value #打印value2=$&#123;array2[3]&#125; #找到某一个下标的数，然后赋值echo $value2 #打印length=$&#123;#array[* ]&#125; #获取数组长度echo $length Shell输出1echo Shell的判断12345678910111213141516171819202122232425262728a=10b=20if [ $a == $b ]thenecho "true"fiif [ $a == $b ]thenecho "true"elseecho "false"fiif [ $a == $b ]thenecho "a is equal to b"elif [ $a -gt $b ]thenecho "a is greater than b"elif [ $a -lt $b ]thenecho "a is less than b"elseecho "None of the condition met"fi Shell中的test命令12345678910 test $[num1] -eq $[num2] #判断两个变量是否相等 test num1=num2 #判断两个数字是否相等-e file 文件存在则返回真-r file 文件存在并且可读则返回真-w file 文件存在并且可写则返回真-x file 文件存在并且可执行则返回真-s file 文件存在并且内容不为空则返回真-d file 文件目录存在则返回真 Shell中的循环for循环123456789101112131415161718192021for ((i=1;i&lt;=10;i++))doecho $idonefor i in &#123;1..5&#125;doecho $idonefor i in 5 6 7 8 9doecho $idonefor FILE in $HOME/.bash*doecho $FILEdone while循环123456789101112while [ $COUNTER -lt 5 ]doCOUNTER=`expr $COUNTER + 1`echo $COUNTERdoneecho '请输入。。。'echo 'ctrl + d 即可停止该程序'while read FILMdoecho "Yeah! great film the $FILM"done 跳出循环123break #跳出所有循环break n #跳出第n层f循环continue #跳出当前循环 Shell中的函数 无参数无返回值 12345678910111213141516171819202122232425262728293031 sysout()&#123; echo "hello world" &#125; sysout &lt;/code&gt;&lt;/pre&gt;&gt; 无参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; aNum=3 anotherNum=5 return $(($aNum+$anotherNum)) &#125; test result=$? echo $result&lt;/code&gt;&lt;/pre&gt;&gt; 有参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; echo $1 #接收第一个参数 echo $2 #接收第二个参数 echo $3 #接收第三个参数 echo $# #接收到参数的个数 echo $* #接收到的所有参数 &#125; test aa bb cc Shell中的重定向123$echo result &gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写$echo result &gt;&gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写echo input &lt; file #获取输入流 Shell中的变量操作 awk 指令获取指定行数的资源名字1sourceNameTemp=$(awk 'NR=="'$i'" &#123;print;exit&#125;' $OutputFile) 获取对应文件名1temp=$&#123;temp##*/&#125; 清空文件1: &gt; "$OutputFile" 常用的Linux命令awk命令 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 基本结构1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中 工作原理 第一步：执行BEGIN{ commands }语句块中的语句；第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。第三步：当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 获取指定行数的文本1awk 'NR=="'$i'" &#123;print;exit&#125;' file 获取文件的行数1awk '&#123;print NR&#125;' "file"|tail -n1 关于awk的详细用法请参考 awk命令]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
