<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift4.2 基本运算符]]></title>
    <url>%2F2018%2F10%2F06%2FSwift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Swift 支持大多数标准 C 语言运算符，并改进了一些功能，很简单(´･(00)･｀) 基本运算符Swift 支持大多数标准 C 语言运算符，并改进了一些功能以消除常见的编码错误。为防止误用等号运算符 (==)， 赋值运算符 (=)并不返回值。为了避免数值在计算时超出它们类型允许值的范围，出现意外结果，算术运算符 (+, -, *, /, % 等) 会检测且不允许值溢出。你可以使用 Swift 值溢出运算符来选择值溢出行为，相关描述请参见 溢出运算符。 Swift 还提供了 C 语言中不存在的范围运算符，如 a..&lt;b 和 a...b ，作为表示区间值的快捷方式。 术语运算符分为一元的、二元的和三元的： 一元 运算符运算单个目标值（例如 -a ）。一元 前缀 运算符显示在目标值之前（例如 !b），而一元 后缀 运算符显示在目标值之后（例如 c!）。 二元 运算符运算两个目标值（例如 2 + 3）并且是 中缀的 因为它们显示在两个目标值之间。 三元 运算三个目标值。像 C ， Swift 只有一个三元运算符，就是三元条件运算符（a ? b : c）。 被运算符影响的值叫做 操作数 。在表达式 1 + 2 中， + 号是二元运算符， 1 和 2 是它的两个操作数。 赋值运算符与 C 和 Objective-C 中的赋值运算符不同，Swift 的赋值运算符本身不返回值。下方的语句是无效的：123if x = y &#123; // 这是无效的，因为 x = y 不返回值&#125; 算术运算符与 C 以及 Objective-C 不同的是， 在 Swift 中, 默认情况下算术运算符不允许值溢出。但是你能通过用 Swift 的溢出符号 (正如 a &amp;+ b)去加入值溢出的行为。参考 Overflow Operators。加号同样支持String的连接：1"hello, " + "world" // 等于 "hello, world" 取余运算符注意取余运算符 (%) 在别的一些语言中的意思是 模运算符 。不过，严格意义上在 Swift 中，对于负数来说它是取余运算而不是模运算。 一元减号运算符123let three = 3let minusThree = -three // minusThree 等于 -3let plusThree = -minusThree // plusThree 等于 3, or "--3" 一元加号运算符1let c = a + b 复合赋值运算符和 C 类似：123var a = 1a += 2// a 现在等于 3 注意复合赋值运算符没有返回值。例如，你不能这么写 let b = a += 2。 比较运算符Swift 支持所有的标准 C 系比较运算符 注意Swift 还提供了两个恒等运算符（=== 和 !==），你可以用它们来判断两个对象引用是否指向同一个实例。 如果两个元组有着相同数量和类型的元素，你就可以比较它们。元组的比较是从左向右，逐个比较的，直到遇到不相等的元素为止。也就是说，每次元素比较的返回值都决定着整个元组比较的结果。如果所有对应元素都相等，那么这两个元组就是相等的。比如：123(1, "zebra") &lt; (2, "apple") // true，因为 1 小于 2，"zebra" 和 "apple" 没有被比较。(3, "apple") &lt; (3, "bird") // true，因为 3 等于 3，而且 "apple" 小于 "bird"。(4, "dog") == (4, "dog") // true，因为 4 等于 4，而且 "dog" 等于 "dog"。 如果一个操作符可以被用来比较两个元组的每个对应元素，那么它就可以被用来比较这两个元组。比如像以下代码演示的那样，你可以比较两个类型为 (String, Int) 的元组，因为 String 和 Int 类型的值都可以用 &lt; 操作符比较。与之形成对比的是，两个 (String, Bool) 类型的元组不能用 &lt; 比较，因为 &lt; 运算符在 Bool 上没有定义。12("blue", -1) &lt; ("purple", 1) // 正确，比较的结果为 true("blue", false) &lt; ("purple", true) // 错误，因为两个布尔类型的值不能用 &lt; 比较。 注意Swift 标准库只定义了用于比较拥有七个以内元素的元组的操作符，如果想要比较两个拥有七个或更多元素的元组，你就需要自己来实现该运算符。 三元运算符它的形式是 question ? answer1 : answer2 空合运算符空合运算符 (a ?? b) 在可选型 a 有值的时候就为它解包，在 a 为 nil 的时候就返回默认值 b 。表达式 a 一定要是可选型。表达式 b 和 a 存储的值类型一定要一致。 空合运算符是下面代码的简写：1a != nil ? a! : b 注意如果 a 的值不是 nil ，那么 b 的值将不会被计算。这就是 短路求值。 区间运算符Swift 包含的一些 区间运算符，其实是数值区间表达式的缩写。 闭合区间运算符闭合区间运算符 (a...b) 表示从 a 到 b 的区间，并且包含 a 和 b。a 一定不能大于 b。 当你想遍历一个区间中的值加以利用时，那么闭合区间运算符就在合适不过了，比如在用 for-in 循环的时候：12345678for index in 1...5 &#123; print("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 半开区间运算符半开区间运算符（a..&lt;b）定义了一个从 a 到 b 但不包括 b 的区间。之所以称之为半开，是因为该区间只包含第一个值，而不包含最后一个值。与闭区间运算符一样，a 绝不可以大于 b。如果 a 等于 b 的话，就表示该区间为空。 当你作用于一个索引从 0 开始的列表（比如数组）时，如果你想要从 0 开始，一直数到（但不过包括）列表的长度，半开区间就显得非常有用了:123456789let names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; print("Person \(i + 1) is called \(names[i])")&#125;// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack 单侧区间闭区间运算符还有另外一种形式，表示向一个方向尽可能地延伸——例如在数组中，一个包含了从索引为 2 开始一直到结尾的所有元素的区间。在这些情况下，你可以省去该区间操作符一侧的值。因为这种区间只有一侧有值，所以它们叫作 单侧区间，例如：123456789101112for name in names[2...] &#123; print(name)&#125;// Brian// Jackfor name in names[...2] &#123; print(name)&#125;// Anna// Alex// Brian 半开区间操作符如果只保留其终值就是它的单侧形式了。就像它的完全形式一样，终值本身并不是该区间的一部分，例如：12345for name in names[..&lt;2] &#123; print(name)&#125;// Anna// Alex 单侧区间不仅仅能被用于下标，还能用于一些其它情况。你无法遍历省略了初始值的单侧区间，因为那种形式没有明确指出遍历应该从哪儿开始。不过你可以遍历没有终值的单侧区间；需要注意的是，因为区间的延伸特性，请务必确保你的遍历循环里有一个清晰的用于结束循环的条件。你还可以检查一个单侧区间是否包含某个特定的值，就像下边代码展示的那样。1234let range = ...5range.contains(7) // falserange.contains(4) // truerange.contains(-1) // true 逻辑运算符Swift 支持基于 C 语言中的 3 种标准逻辑运算符 逻辑非（!a） 逻辑与（a &amp;&amp; b） 逻辑或（a || b） 混合逻辑运算你可以组合多个逻辑运算符来创建更长的复合表达式：123456if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123; print("Welcome!")&#125; else &#123; print("ACCESS DENIED")&#125;// 打印 "Welcome!" 注意Swift 逻辑运算符 &amp;&amp; 和 || 都是左关联的，这意味着具有多个逻辑运算符的复合表达式首先判断最左边的子表达式。 显性括号括号清楚地表明了前两个值被视为整体逻辑中独立可能状态的一部分。这个复合表达式的结果并没有改变，但是其整体的意图对于读者来说更加清晰了。易读性总是优先于简洁性；在可以帮助你明确意图的地方，使用括号吧。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2（基础篇要点）]]></title>
    <url>%2F2018%2F10%2F05%2FSwift%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Swift4.2基础篇摘要ʕ•͡ω•ʔ 本章节只是简单的摘录文档里的重要内容（或者是没记住的- -）如果想从头开始看Swift还是直接看官方文档比较好 高级类型除了属性的类型，Swift引入了Objective-C中没有的高级类型，比如元组。元组可以让你创建与传递值的分组。你可以使用元组将函数中的多个值作为单个复合值返回。 可选类型Swift 还引入了可以处理缺省值的可选类型。可选类型表示「要么 有 值，并且等于 X」，「要么 没有 值」 。使用可选类型与在 Objective-C 中将指针和 nil 一起使用很相似，但是，可选类型适用于任何类型，不仅仅是类。可选类型不仅比 Objective-C 中的 nil 指针更安全，更具表现力，它还是 Swift 众多强大特性中的核心。 类型安全Swift 是一门 类型安全 的语言，这意味着它有助于明确代码中的值的类型。如果代码中需要一个 String，类型安全可以防止你错误地传递给它一个 Int。同样的，类型安全可以防止你意外地将一个可选的 String 传递给一个需要非可选 String 的代码片段。在开发过程中，类型安全可以帮你尽早捕捉并修复错误。 注释Swift 中的多行注释可以相互嵌套使用 浮点数Double 类型可以精确到小数点后15位，而 Float 类型只有6位。如果两种类型都能使用的情况下，优先使用 Double 类型 。 类型推断因为有了类型推断，Swift 和 C 以及 Objective-C 相比，只需要少量的类型声明。其实常量和变量仍然需要明确的类型，但是大部分的声明工作 Swift 会帮你做。Swift 在推断浮点值的时候始终会选择 Double （而不是Float）。 数值型字面量整数型字面量可以写作： 十进制数，没有前缀 二进制数，前缀为 0b 八进制数，前缀为 0o 十六进制数，前缀为 0x 类型转换SomeType(ofInitialValue) 是 Swift 中初始化一个对象的默认方式，在这个过程中需要传入一个初始值。而在底层实现中，UInt16 有一个接收 UInt8 类型的初始化构造器，所以这个构造器是用来转换 UInt8 类型 到 UInt16 类型 的。你不能在这传入 任何 类型，因为必须是 UInt16 初始化构造器允许的类型才可以。扩展现有类型的初始化构造器，让其接收新的类型（包括你自己自定义的类型）的内容在 Extensions 中可以找到。 类型别名类型别名 就是给现有类型定义了一个另外的名字。你可以使用 typealias 关键字来声明类型别名。 布尔值Swift 有一个基础 布尔 类型 Bool. 布尔值也被称为 逻辑值, 因为它们只能是真或假。 Swift 提供两个布尔常量，true 和 false 。 元组元组 将多个值组合在一起成为一个复合值。元组里面的值可以是任何类型，不需要是相同的类型。你可以将一个元组的内容 分解 为单独的常量或变量，然后你就可以正常使用它们了：1234567let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String), 等于 (404, "Not Found")let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// 打印 "The status code is 404"print("The status message is \(statusMessage)")// 打印 "The status message is Not Found" 如果你只需要元组里的一部分值的话，分解元组的时候使用一个下划线（_） 来忽略元组里面的值：123let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// 打印 "The status code is 404" 此外，使用从零开始的下标来访问元组里单个元素的值：1234print("The status code is \(http404Error.0)")// 打印 "The status code is 404"print("The status message is \(http404Error.1)")// 打印 "The status message is Not Found" 定义元组时，你可以为元组中的单个元素命名：1let http200Status = (statusCode: 200, description: "OK") 如果你在元组里为元素命名了，那么你就可以通过元素名称去获取元素的值：\1234print("The status code is \(http200Status.statusCode)")// 打印 "The status code is 200"print("The status message is \(http200Status.description)")// 打印 "The status message is OK" 元组作为函数的返回值的时候十分有用。一个尝试获取一个网页的函数可能会返回一个 (Int, String) 类型来表示结果的成功或失败。相比于返回一个类型的单个值作为结果，通过返回包含两个不同类型值的一个元组作为返回值，这个函数让自己的返回值提供了更多有用的信息。更多信息，参考 函数参数与返回值 注意元组在临时组织的值的时候很有用。元组并不适合用于创建复杂数据结构。如果你的数据结构比较持久而不是临时使用的话，使用类或者结构体，而不是元组。更多信息，参考 结构体和类. 可选类型注意C 和 Objective-C 中没有可选类型的概念。最接近的是Objective-C 中的一个方法除了返回对象之外还会返回nil 的能力，nil表示缺省一个合法的对象。然而，这仅仅对对象起作用 — 对结构体，基本C 类型或者枚举类型并不起作用。对于这些类型，Objective-C 的方法通常会返回一个特殊的值(比如 NSNotFound)来表示值缺省的情况。这种方式假设方法的调用者知道和记得对特殊值进行处理和检查。Swift 的可选类型可以让你表明任何类型的值缺省的情况，而不需要特殊值。 非可选状态下的常量或变量不能使用 nil 。在某些特定条件下，如果你代码中的常量或变量需要指定为空值，则始终将其声明为适当类型的可选值。 如果你定义了一个可选变量但没有赋值，变量将自动设置为 nil 注意Swift 里的 nil 不同于 Objective-C 里的 nil 。 在 Objective-C 里, nil 是一个指向空对象的指针。在 Swift 里， nil 不是指针，而是某种特定类型值的缺失。 任意 类型都可以设置为 nil, 而不仅仅是对象类型。 if 语句和强制解析你可以在通过一个 if 语句里比较可选项和 nil 的方式来确定其是否包含确定值 。执行比较需要用到“等于”操作符 == ，或者“不等于”操作符!=。 如果一个可选项包含值，那么它就被认为不等于 nil:1234if convertedNumber != nil &#123; print("convertedNumber contains some integer value.")&#125;// 打印 "convertedNumber 包含整型值." 一旦你确认可选项包含值，你就可以通过使用在可选项名称后添加!的方式来访问它的值。感叹号的含义是：“我知道这个可选项绝对有值，请使用它。”这就是对可选项值的强制解析。1234if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).")&#125;// 打印 "convertedNumber 包含整型值 123." 可选绑定使用可选绑定 optional binding 来判断一个可选类型是否包含值，如果包含就赋给一个临时的常量或者变量使这个值可用。可选绑定可以被用到if和while语句中，用来检差一个值是否是可选类型， 并且将值提取为一个常量或者变量。 if 语句的可选绑定可以写成如下这样：123if let constantName = someOptional &#123; statements&#125; 你可以使用可选绑定而不是强制解包来重写 可选类型 章节的 possibleNumber 例子：123456if let actualNumber = Int(possibleNumber) &#123; print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")&#125; else &#123; print("\"\(possibleNumber)\" could not be converted to an integer")&#125;// Prints ""123" has an integer value of 123" 上面的代码可以被理解为： “如果通过 Int(possibleNumber)返回的可选 Int 类型包含一个值，那么就创建一个名为 actualNumber 的新的常量并把可选类型中的值赋给它。” 如果转换成功，常量 actualNumber 可以被用在 if 语句的第一个分支中。它已经被可选类型 包含的 值初始化，因此不再需要使用后缀 ! 来获取它的值。在这个例子中，actualNumber 被简单地用来打印转换的结果。 注意在 if 语句中使用可选绑定的常量和变量仅在 if 语句内可用。相反，在 guard 语句中创建的常量和变量在 guard语句后的代码中也可以使用，如上所述 Early Exit. 隐式展开可选项通过在声明的类型后边添加一个叹号 String! 而非问号 String? 来书写隐式展开可选项。隐式展开可选项是后台中通用的可选项，但是同样也可以像非可选值来使用，每次访问的时候不需要展开。接下来的例子中展示了在访问被明确为 String 的可选项展开值时，可选字符串和隐式展开可选字符串的行为区别：12345let possibleString: String? = "An optional string."let forcedString: String = possibleString! //要求使用感叹号let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要使用感叹号 你可以把隐式展开可选项当做在每次访问他的时候被给与了自动进行展开的权限。相比于在每次调用他的时候添加一个叹号，你可以再声明的时候呀添加一个叹号。 错误处理相比于可选项的通过值是否缺失来判断程序的执行正确与否，错误处理机制能允许你判断错误的形成原因，如果需要的话，还能将你的代码中的错误传递到程序的其他地方。当一个函数遇到错误情况，他或 抛出 错误。这个函数的访问者会 捕捉 到这个错误并且做出适当的反应。123func canThrowAnError() throws &#123; // 这个函数可能会出错也可能不会出错&#125; 通过在函数声明过程中加入 throws 关键字来表明这个函数会抛出一个错误。当你调用了一个可以抛出错误的函数时，你需要再表达式前预置 try 关键字。 Swift 会自动将错误传递到他们的生效范围之内，直到他们被 catch 分局处理。123456do &#123; try canThrowAnError() // 无错误抛出&#125; catch &#123; // 有错误抛出&#125; do 语句创建了一个新的容器范围，可以让错误被传递到不止一个的 catch 分句处理。 下面的例子演示了如何利用错误处理机制处理不同的错误情况：123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 本例中，如果没有干净的盘子或某个原料缺失的话，makeASandwich() 函数会抛出一个错误。因为 makeASandwich() 函数抛出了错误，所以对它的调用被包裹在一个 try 表达式里。将函数调用包裹进一个 do 的语句里，任何抛出的错误都会被传播到提供的 catch 从句里。 如果没有抛出错误，eatASandwich() 方法将会被调用。如果抛出了错误，并且匹配到了 outOfCleanDishes 条件的话，washDishes() 函数就会被调用。如果匹配到了 SandwichError.missingIngredients 条件，buyGroceries(_:) 函数就会被调用，并且使用 catch 捕获的关联 String 值作为参数。 断言与先决条件断言 和 先决条件 是程序运行时发生的检查动作。你可以使用它们来检查代码被执行之前的一些必要条件是否被满足。如果断言或先决条件中布尔值的条件等于 true，代码将会像平常一样继续执行下去。如果条件等于 false，当前程序的状态将会是无效的，并且会导致代码执行停止，程序被终止。 断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。 调试断言使用 Swift 标准库中的 assert(_:_:file:line:) 函数来声明一个断言语句。可以向这个函数传入一个值为 true 或 false 的表达式以及如果条件为 false 的情况下的提示性信息。如下所示：123let age = -3assert(age &gt;= 0, "A person's age can't be less than zero.")// 因为 -3 小于 0，所以这个断言失败了 上面的例子中，如果 age &gt;= 0 语句结果为 true，代码将继续执行下去，也就是说 age 的值是非负的。如果 age 的值是负数，那么上面的代码中的 age &gt;= 0 语句将返回 false，这将导致断言失败，程序终止。 你可以省略断言提示信息 — 比如下面的代码，仅仅是单调地重复一下条件语句。1assert(age &gt;= 0) 如果代码中已经检查了条件的话，可以使用 assertionFailure(_:file:line:) 函数来表明断言已经失败。如下所示：1234567if age &gt; 10 &#123; print("You can ride the roller-coaster or the ferris wheel.")&#125; else if age &gt; 0 &#123; print("You can ride the ferris wheel.")&#125; else &#123; assertionFailure("A person's age can't be less than zero.")&#125; 强制执行先决条件只要条件可能会为 false 的时候，就使用先决条件。但代码必须 肯定 为 true 才能继续执行下去。例如，使用先决条件去检查下标是否越界或检查函数是否传入了合法的参数值。 通过调用 precondition(_:_:file:line:) 函数来声明一个先决条件。你可以向一个先决条件传入结果为 true 或 false 的表达式和当结果为 false 时的提示信息。例如：12// 判断下标...precondition(index &gt; 0, "Index must be greater than zero.") 你也可以使用 preconditionFailure(_:file:line:) 函数来表明执行的失败 — 例如，如果一个 switch 语句的默认条件命中了，但是所有有效的输入数据只会被其他条件处理。 注意如果你以不检查的编译模式( Ounchecked )模式进行编译，先决条件将不会起作用。编译器会假设先决条件总是为真，并会根据你的代码做相应的优化。然而，无论优化设置如何，fatalError(_:file:line:) 函数总会停止程序的执行。你可以在原型设计和开发的早期过程中使用 fatalError(_:file:line:) 函数来创建尚未实现的功能的存根，编写 fatalError(&quot;Unimplemented&quot;) 作为存根的实现。因为 fatal error 永远不会被优化，与断言和先决条件不同的是，你可以确保程序总是在遇到存根实现时停止。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4.2光速入门٩(๑>◡]]></title>
    <url>%2F2018%2F10%2F03%2FSwift%2F</url>
    <content type="text"><![CDATA[9月25日，Xcode10发布了！支持swift3和swift4，而如今swift也日趋成熟，使用swift开发的项目也越来越多。ʕ•̀ω•́ʔ✧是时候学swift了，一起来光速入门吧~ 版本兼容性swift采用了现代编程模式，以避免大量常见的低级编程错误： 变量永远会在被使用前完成初始化 对数组的索引操作会自动检查是否出现越界错误 整型数值会自动检查是否溢出 可选值确保nil值被正确处理 内存被自动管理 错误处理允许从异常故障控制恢复 当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享： 子字符串的操作返回的实例是Substring类型而不是String 在较少的地方会隐性增加@objc属性 同一文件中类型的拓展可以访问该类型中的私有成员 概述首先，从hello world开始用swift实现可太tm简单了用xcode创建一个swift blank项目，在playground中输入一句话1print("hello world!") 全局作用域中的代码会自动作为程序的入口，因此；不需要main()函数，同样的，你也不需要写;了。 简单值 lei声明常量var声明变量 123var num = 1num = 2let number = 3 swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，num是个整数，因为它的初始值是一个整数。 如果没有初始值，你又想声明类型，你只要在变量后声明类型，用:分割。 1let num3:Double = 1 swift有一种更简单的方式让值转为字符串：把值写在()内，在括号之前再加一个\1234567let str = "girlfriend"let sum1 = 1let sum2 = 0print("I used to have \(sum1) \(str)")print("and now I have \(sum1*sum2) \(str)")print("pretty girl check your wechat number and send it to me pls:)") 对于占用多行的字符串可以使用三个引号&quot;&quot;&quot;每行的来头缩进要和右引号的缩进相同12345let string = """hello~this my wechat number"""print(string) 使用[]来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号12345678var arr = ["my","name","is","hades"]arr[3] = "whz"var dic = [ "key1":"value1", "key2":"valeu2"]dic["key2"] = "value change" 使用初始化语法来创建一个空数组或者字典12let emptyArr = [String]()let emptyDic = [String:String]() 如果类型能被推断，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）12arr = []dic = [:] 控制流 使用if和switch来创建条件语句，使用for-in,while，以及repeat-while来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。123456789101112let numArr = [123,13,4,13,43,65]var totalNum = 0for tempNum in numArr &#123; if tempNum &lt; 50 &#123; totalNum -= 1 &#125; else&#123; totalNum += 1 &#125; print(totalNum)&#125;print("end of totalnum = \(totalNum)") 在if语句中，条件语句必须是布尔表达式，可以使用if和let来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为nil表示值缺失。在值得类型后面跟随一个?则表示这个值是可选的。12345678910111213141516var exampleStr:String? = "hello"print(exampleStr == nil)var name:String? = "hades"var greeting = "hello~"//name = "xiye"//name = nilif let nameTemp = name &#123; //如果类型转换成功，则将值赋值给nameTemp直接使用 greeting = "hello~ \(nameTemp)" print("nameTemp = \(nameTemp) name = \(name!)") print("( let nameTemp = name ) = true");&#125;else&#123; print("name = nil ") //强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有 print("( let nameTemp = name ) = false");&#125; 如果可选值为nil，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给let后的常量，这样代码中就可以使用这个值。 处理可选值得另一种方法是使用??操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。 1234567var nickName: String? = nil //"whz"let fullName: String = "hades"//nickName = "whz"//nickName = nillet informalGreeting = "hi~ \(nickName ?? fullName)"print(informalGreeting) oc中的nil和swift中的nilObjective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) ‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。1234567891011var people = "ex"switch people &#123;case "girl": print("hey~ could you give me your wechat number?")case "man","boy": print("oh...next pls")case let x where x.hasSuffix("x")://hasSuffix以指定后缀结束，hasPrefix以指定前缀开始 print("if time can come back...")default: print("hello stranger.")&#125; 在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。你可以为字典中的键值对起一组名字，并用for in语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。1234567891011121314151617let someNumbers = [ "key1":[2,4,1,5,31], "key2":[2,43,2,5,1,53], "key3":[2345,13,1,3,13,65]]var maxNum = 0;var maxName:String = ""for (keyInSomeNumbers,valueInSomeNumbers) in someNumbers &#123; for values in valueInSomeNumbers &#123; if values &gt; maxNum &#123; maxNum = values maxName = "\(keyInSomeNumbers)" &#125; &#125;&#125;print("\(maxName) \(maxNum)") 使用while来循环执行代码12345678910111213var n = 0while n &lt; 100 &#123; n = n*n + 1&#125;print(n)var m = 0repeat&#123; m = m + 1 print("m = \(m)")&#125;while m &lt; 10print(m) 可以使用..&lt;来限定索引范围，并在循环中遍历该索引范围12345var total = 0for i in 1..&lt;4 &#123; total += i&#125;print(total) 函数和闭包使用func来声明一个函数。使用函数名和参数名来调用函数。使用-&gt;来指定函数返回值类型。1234func greet (person:String,day:String)-&gt; String&#123; return "Hello \(person),today is \(day)"&#125;print(greet(person: "whz", day: "thuesday")) 默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用_来表示来不使用参数标签。1234func greet(_ preson:String,on day:String)-&gt; String&#123; return "hello \(preson),today is \(day)"&#125;print(greet("hades", on: "friday")) 使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。1234567891011121314151617181920func function(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else&#123; min = score &#125; sum = sum + score &#125; return (min,max,sum)&#125;let result = function(scores: [1,31,413,356,1,376,463])print(result.max)print(result)print(result.2) 函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。123456789func returnFifteen()-&gt; Int &#123; var x = 10 func add()&#123; x += 5 &#125; add() return x&#125;print(returnFifteen()) 函数是一个类型。意味着函数可以作为其他函数的返回值。12345678func returnOneFunction() -&gt; ((Int) -&gt; Int)&#123; func returnOneInt(number:Int) -&gt; Int&#123; return number + 1 &#125; return returnOneInt&#125;var anotherFunction = returnOneFunction()print(anotherFunction(3)) 一个函数也可以作为参数传入另一个函数1234567891011121314func hasAnyMatches(list:[Int],condition:(Int)-&gt;Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; print(item) return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型与闭包函数体分离。12345678var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen)numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number print(111) return result&#125;) 写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。12345var temp = [3,41,5,1,51]let temp1 = temp.map&#123; num in num + 1&#125; swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写1234print(temp1)let temp2 = temp.map&#123; $0 + 1&#125; 对象和类通过在类名前加class关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 通过在类名称后面插入括号来创建类的实例。使用.语法的方式来访问实例中的属性和方法。1234var shape = Shape()shape.numberOfSides = 9var shapeDescription = shape.simpleDescription()print(shapeDescription) 当一个类的属性没有初始值，你就需要使用init来创建一个构造器。1234567891011class NamedShape &#123; var numberOfSides:Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func description() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 这里的self被用来区分name属性和构造器的name参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。如果你需要在对象被释放前执行一些清理的行为，可以使用deinit来创建一个折构器。 子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。 子类如果需要重写父类的方法，则需要使用override来标记—不使用override关键字来标记会导致编译器报错。编译器同样也会检查override标记的方法是否存在父类当中。1234567891011121314151617181920class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 5 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func description() -&gt; String &#123; return "A square with sides of length \(sideLength)" &#125;&#125;let test = Square(sideLength: 4.1, name: "test square")print(test.area())print(test.description()) 除了存储简单的属性，属性还可以拥有getter和setter123456789101112131415161718192021222324252627class EquilaterTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength = newValue / 3.0 &#125; &#125; override func description() -&gt; String &#123; return "this is a triangle with sides of length \(sideLength)" &#125;&#125;var triangle = EquilaterTriangle(sideLength: 4.3, name: "a triangle")print(triangle.perimeter)triangle.perimeter = 9print(triangle.sideLength) 在perimeter的setter中，新值被隐式的命名为newValue。你可以在set的括号后面，显式的提供一个名字。 注意EquilateralTriangle类的初始化有三个不同的步骤：- 1 设定子类的声明的属性值- 2 调用父类的构造器- 3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。 如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用willSet和didSet。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。123456789101112131415161718192021class TriangleAndSquare &#123; var triangle: EquilaterTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square:Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square = Square(sideLength: size, name: name) triangle = EquilaterTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: "test")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 40, name: "larger square")print(triangleAndSquare.triangle.sideLength) 在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用?。如果?前的值是nil,则?后面的所有内容都会被忽略，且整个表达式为nil。否则，可选项的值将被展开，然后?后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。12let optionalSquare: Square? = Square(sideLength: 2.3, name: "optional square")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。123456789101112131415161718192021enum Rank: Int &#123; case ace = 1 case two,three,four,five,six,seven,eight,nine,ten case jack,queen,king func simpleDescription() -&gt; String &#123; switch self &#123; case .ace: return "ace" case .jack: return "jack" case .queen: return "queen" case .king: return "king" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue 默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，Ace的原始值被显示赋值为1，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器来创建一个拥有原始值得枚举实例。如果在Rank中有与该原始值相匹配的枚举实例则返回该实例，没有则返回nil。123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。1234567891011121314151617enum Suit &#123; case spades,hearts,diamonds,clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .spades: return "spades" case .hearts: return "hearts" case .diamonds: return "diamonds" case .clubs: return "clubs" &#125; &#125;&#125;let hearts = Suit.heartslet haartsDescriotion = hearts.simpleDescription() 注意在上面例子中用了两种方法来调用hearts成员：给hearts指定一个常量时，枚举成员Suit.hearts需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式.hearts被调用，因为self的值已经确定是Suit类型。在值得类型已经被明确的情况下可以使用缩写。 如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。12345678910111213enum ServerResponse &#123; case result(String,String) case failure(String)&#125;let success = ServerResponse.result("6:00 am","8:00 pm")let failure = ServerResponse.failure("fail")switch success &#123;case let .result(sunrise,sunset): print(" sunrise is at \(sunrise) and sunset is at\(sunset)")case let .failure(message): print("fail - \(message)")&#125; 注意日出日落时间是如何从ServerResponse值中进行提取，并与 switch cases 相匹配的。 使用struct来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" &#125;&#125;let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用protocol来声明一个协议。mutating关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量1234protocol ExampleProtocol &#123; var simpleDescription: String&#123; get &#125; mutating func adjust()&#125; 类、枚举和结构都可以遵循协议12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = "a simple class" var anotherPriperty: Int = 69105 func adjust() &#123; simpleDescription += "now 100% adjusted" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct simpleStructure: ExampleProtocol &#123; var simpleDescription: String = "a simple sturcture" mutating func adjust() &#123; simpleDescription += "(adjusted)" &#125;&#125;var b = simpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明SimpleStructure时使用了关键字mutating来标记一个可以修改结构体的方法。而声明SimpleClass时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。 使用extension可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。 123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return "the number \(self)" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) 你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。 1234let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)//下面这句会报错print(protocolValue.anotherProperty) 尽管变量protocolValue在运行时类型为SimpleClass，但编译器依旧会把它的类型当做ExampleProtocol。这也就意味着，你不能随意访问在协议外的方法或属性。 错误处理你可以使用任何遵循Error协议的类型来表示错误。12345enum PrintError: Error &#123; case outOfPaper case noToner case onFire&#125; 使用throw跑出异常并且用throws来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。123456func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == "Never Has Toner" &#123; throw PrintError.noToner &#125; return "Job sent"&#125; 这里有几种方法可以处理异常。一种是使用do-catch。在do代码块里，你可以是用try在抛出的异常的函数前标记。在catch代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为error。123456do &#123; let printerResponse = try send(job: 1040, toPrinter: "Never Has Toner") print(printerResponse)&#125; catch&#123; print(error)&#125; 你可以提供多个catch代码块来处理特定的错误。你可以在catch后面一个一个模式，就像switch语句里面的case一样。12345678910 do &#123; let printerResponse = try send(job: 1440, toPrinter: "Gutenberg") print(printerResponse)&#125; catch PrintError.onFire &#123; print("I'll just put this over here, with the rest of the fire.")&#125; catch let printerError as PrintError &#123; print("Printer error: \(printerError)")&#125; catch &#123; print(error)&#125; 另外一种处理错误的方法是用try?去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为nil。否则，结果是一个包含了函数返回值的和选项。12let printerSuccess = try? send(job: 1883, toPrinter: "Mergenthaler")let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner") 使用defer来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用defer来简化代码。1234567891011121314var fridgeIsOpen = falselet fridgeContent = ["milk","eggs","leftovers"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result&#125;fridgeContains("milk")print(fridgeIsOpen) defer常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候defer会在该当前声明的作用域结束的时候执行优先级： 局部优先、同级自下而上12345678910111213141516171819func firstProcesses(_ isOpen: Bool) &#123; //作用域1 整个函数作用域 defer&#123; print("推迟操作🐢") &#125; print("😳") if isOpen == true &#123; //作用域2 if的作用域 defer&#123; print("推迟操作🐌") &#125; print("😁") &#125; print(111)&#125;firstProcesses(true) 泛型把名字写在尖括号里来创建一个泛型方法或者类型。12345678func makeArray&lt;Item&gt;(repeating item: Item,numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;makeArray(repeating: "knock", numberOfTimes: 4) 你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。123456enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100) 在类型名称后紧接where来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。1234567891011func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T,_ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1,2,3], [3]) 以上就是Swift4.2的概述，看完这些写一个简单的app已经不是难事了~但简单的app可不是我们的目标，还有很多语法上的细节需要深入研究学习，在后面的文章我会逐步更新语法上的细节ʕु•̫͡•ʔु ✧]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM是什么( ´ﾟωﾟ)？]]></title>
    <url>%2F2018%2F08%2F23%2FLLVM%2F</url>
    <content type="text"><![CDATA[LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙 简述LLVM 一个开源编译器架构，目前Xcode采用的就是LLVM架构。 Clang 由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。 GCC GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GNU GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。 在Xcode上使用GCC Xcode在C和C++上是支持使用GCC的，如下：具体参数的使用请参考：stackoverflow:Xcode上的GNU GCC 更多概念LLVM全名：Low Level Virtual Machine 直译：底层虚拟机/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.- 来自LLVM官网的介绍 LLVM官网 LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。 LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。 - 来自维基百科 LLVM on wiki 简单来说 LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。编译器是Clang，GCC，ICC，VC++等。 Xcode和LLVM Xcode3之前，用的是GCCXcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能Xcode4.6,LLVM升级到4.2版本Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成 ClangClang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang项目包括Clang前端和Clang静态分析器等。- 来自维基百科 Clang on wiki GCCGCC官网GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。 原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。 许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。- 来自维基百科 GCC on wiki GNUGNU官网GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。 作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。- 来自维基百科 GNU on wiki LLDBLLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。 GDBGNU Debugger 顾名思义支持编程语言有C、C++、Pascal以及FORTRAN在许多的类UNIX操作系统上都可以使用 词法分析lexical analysis /ˈlɛksɪkəl/词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。 语法分析syntactic analysis，也叫 parsing/sɪnˈtæktɪk əˈnæləsəs/ /ˈpɑːzɪŋ/语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述. 语法分析器parser通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。 源语言&amp;源程序Source language&amp;Source program被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。 目标语言&amp;目标程序Object language or Target language &amp; Object program or Target program编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。 中间语言（中间表示）Intermediate language（representation）在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。 文法Grammars/ˈgræməz/文法是用于描述语言的语法结构的形式规则。 token是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。 抽象语法树abstract syntax tree或者缩写为AST/ˈæbstrækt ˈsɪnˌtæks tri/抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。 具体CMD+BObjective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。 在使用Xcode按下cmd+B后，会经过以下流程：预处理（Pre-process）：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。 词法分析 （Lexical Analysis）：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 语法分析（Semantic Analysis）：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。 静态分析（Static Analysis）：使用它来表示用于分析源代码以便自动发现错误。 中间代码生成（Code Generation）：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。 优化（Optimize）：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。 生成目标文件（Assemble）：生成Target相关Object(Mach-o) 。 链接（Link）：生成 Executable 可执行文件。 关于此过程的详细测试，参考掘金 LLVM的具体操作请参考关于LLVM，这些东西你必须知道！ 基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 a+b 改为 a-(-b)将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。 所以基于LLVM可以完成： 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。 编写ClangPlugin，命名规范，代码规范，扩展功能。 编写Pass，代码混淆优化。 使用Clang进行开发详细参考IBM developerWorks Clang的特性相比于 GCC，Clang 具有如下优点： 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强： 支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。 支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。 以下是目前GCC和Clang对C++支持的情况： 更多参考C++ 编译器支持情况表 使用LLVM创建一个编译器首先参考这篇文章来写一个helloworldIBM developerWorks 关于LLVM IR的生成与创建IBM developerWorks]]></content>
      <categories>
        <category>编译相关</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
        <tag>GNU</tag>
        <tag>GCC</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本的入门（一）]]></title>
    <url>%2F2018%2F08%2F15%2FShell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。 Simple BB 为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。获取目标资源的路径，根据A中的行数进行循环find查找，找到就用cp命令替换，未找到的重定向输出到临时文件B最后打印B的内容，remove临时文件。其中对文本的处理使用了awk命令 脚本下载地址在我的github上 资源替换脚本 Shell介绍 Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。而我使用shell只是因为我用的mac - - Shell的工作原理 Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。 Shell的创建 1.打开文本编辑工具，输入一下内容#!/bin/bash echo &quot;Hello World&quot;2.保存为 hello world.sh在目录 A3.在终端cd到目录 A4.终端输入chmod +x ./hello world.sh （这一步是给脚本添加权限）5.执行脚本 ./hello world.sh 或者 直接把 hello world.sh拖入终端 这很简单，无图。 Shell中的变量变量的定义1example="a1" 或者 1example=a1 但是example=a 1 并不等同于 example=&quot;a 1&quot;因为&quot; &quot;（空格）在shell中用作指令的间隔example=a 1 其实只是将a负责给example 然后在输入了个1 这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！ 变量的访问在变量前加上$ 1echo $example Shell中的四则运算1234$a + $b$a - $b$a \* $b$a / $b 注意 乘法的时候需要进行转义= 赋值时，前后无空格而运算符号前后必须有空格 Shell中的其他运算符 =、==、!=、！、-o、-a 12-o 或-a 与 关系运算符 -eq 两个数相等返回true-ne 两个数不相等返回true-gt 左侧数大于右侧数返回true-It 左侧数小于右侧数返回true-ge 左侧数大于等于右侧数返回true-le 左侧数小于等于右侧数返回true 字符串运算符 = 两个字符串相等返回true!= 两个字符串不相等返回true-z 字符串长度为0返回true-n 字符串长度不为0返回true-d file 检测文件是否是目录，如果是，则返回 true-r file 检测文件是否可读，如果是，则返回 true-w file 检测文件是否可写，如果是，则返回 true-x file 检测文件是否可执行，如果是，则返回 true-s file 检测文件是否为空（文件大小是否大于0，不为空返回 true-e file 检测文件（包括目录）是否存在，如果是，则返回 true Shell字符串操作123456mtext="hello" #定义字符串mtext2="world"mtext3=$mtext" "$mtext2 #字符串的拼接echo $mtext3 #输出字符串echo $&#123;#mtext3&#125; #输出字符串长度echo $&#123;mtext3:1:4&#125; #截取字符串 Shell数组12345678array=(1 2 3 4 5) #定义数组array2=(aa bb cc dd ee) #定义数组value=$&#123;array[3]&#125; #找到某一个下标的数，然后赋值echo $value #打印value2=$&#123;array2[3]&#125; #找到某一个下标的数，然后赋值echo $value2 #打印length=$&#123;#array[* ]&#125; #获取数组长度echo $length Shell输出1echo Shell的判断12345678910111213141516171819202122232425262728a=10b=20if [ $a == $b ]thenecho "true"fiif [ $a == $b ]thenecho "true"elseecho "false"fiif [ $a == $b ]thenecho "a is equal to b"elif [ $a -gt $b ]thenecho "a is greater than b"elif [ $a -lt $b ]thenecho "a is less than b"elseecho "None of the condition met"fi Shell中的test命令12345678910 test $[num1] -eq $[num2] #判断两个变量是否相等 test num1=num2 #判断两个数字是否相等-e file 文件存在则返回真-r file 文件存在并且可读则返回真-w file 文件存在并且可写则返回真-x file 文件存在并且可执行则返回真-s file 文件存在并且内容不为空则返回真-d file 文件目录存在则返回真 Shell中的循环for循环123456789101112131415161718192021for ((i=1;i&lt;=10;i++))doecho $idonefor i in &#123;1..5&#125;doecho $idonefor i in 5 6 7 8 9doecho $idonefor FILE in $HOME/.bash*doecho $FILEdone while循环123456789101112while [ $COUNTER -lt 5 ]doCOUNTER=`expr $COUNTER + 1`echo $COUNTERdoneecho '请输入。。。'echo 'ctrl + d 即可停止该程序'while read FILMdoecho "Yeah! great film the $FILM"done 跳出循环123break #跳出所有循环break n #跳出第n层f循环continue #跳出当前循环 Shell中的函数 无参数无返回值 12345678910111213141516171819202122232425262728293031 sysout()&#123; echo "hello world" &#125; sysout &lt;/code&gt;&lt;/pre&gt;&gt; 无参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; aNum=3 anotherNum=5 return $(($aNum+$anotherNum)) &#125; test result=$? echo $result&lt;/code&gt;&lt;/pre&gt;&gt; 有参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; echo $1 #接收第一个参数 echo $2 #接收第二个参数 echo $3 #接收第三个参数 echo $# #接收到参数的个数 echo $* #接收到的所有参数 &#125; test aa bb cc Shell中的重定向123$echo result &gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写$echo result &gt;&gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写echo input &lt; file #获取输入流 Shell中的变量操作 awk 指令获取指定行数的资源名字1sourceNameTemp=$(awk 'NR=="'$i'" &#123;print;exit&#125;' $OutputFile) 获取对应文件名1temp=$&#123;temp##*/&#125; 清空文件1: &gt; "$OutputFile" 常用的Linux命令awk命令 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 基本结构1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中 工作原理 第一步：执行BEGIN{ commands }语句块中的语句；第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。第三步：当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 获取指定行数的文本1awk 'NR=="'$i'" &#123;print;exit&#125;' file 获取文件的行数1awk '&#123;print NR&#125;' "file"|tail -n1 关于awk的详细用法请参考 awk命令]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
