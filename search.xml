<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift4.2光速入门٩(๑>◡]]></title>
    <url>%2F2018%2F11%2F26%2FSwift%2F</url>
    <content type="text"><![CDATA[Xcode10发布了，支持swift3和swift4，使用swift开发的项目也越来越多。是时候学swift了，一起来光速入门吧~ 版本兼容性swift采用了现代编程模式，以避免大量常见的低级编程错误： 变量永远会在被使用前完成初始化 对数组的索引操作会自动检查是否出现越界错误 整型数值会自动检查是否溢出 可选值确保nil值被正确处理 内存被自动管理 错误处理允许从异常故障控制恢复 当swift4.2编译器编译swift3的代码时，swift 4 大部分新功能是可用的，只有如下功能swift 4 独享： 子字符串的操作返回的实例是Substring类型而不是String 在较少的地方会隐性增加@objc属性 同一文件中类型的拓展可以访问该类型中的私有成员 概述首先，从hello world开始用swift实现可太tm简单了用xcode创建一个swift blank项目，在playground中输入一句话1print("hello world!") 全局作用域中的代码会自动作为程序的入口，因此；不需要main()函数，同样的，你也不需要写;了。 简单值 lei声明常量var声明变量 123var num = 1num = 2let number = 3 swift不需要在声明时声明类型，编译器会根据你创建的变量或者常量的初始值进行类型推断。上面的例子中，num是个整数，因为它的初始值是一个整数。 如果没有初始值，你又想声明类型，你只要在变量后声明类型，用:分割。 1let num3:Double = 1 swift有一种更简单的方式让值转为字符串：把值写在()内，在括号之前再加一个\1234567let str = "girlfriend"let sum1 = 1let sum2 = 0print("I used to have \(sum1) \(str)")print("and now I have \(sum1*sum2) \(str)")print("pretty girl check your wechat number and send it to me pls:)") 对于占用多行的字符串可以使用三个引号&quot;&quot;&quot;每行的来头缩进要和右引号的缩进相同12345let string = """hello~this my wechat number"""print(string) 使用[]来创建数组和字典，并且使用下标或者键来访问它们的元素。其中最后一个元素后面允许有逗号12345678var arr = ["my","name","is","hades"]arr[3] = "whz"var dic = [ "key1":"value1", "key2":"valeu2"]dic["key2"] = "value change" 使用初始化语法来创建一个空数组或者字典12let emptyArr = [String]()let emptyDic = [String:String]() 如果类型能被推断，则可以更简单，就像你给一个变量赋值一样（但注意，不能推断类型的时候不能这么使用，即不能用这种方式声明一个空数组或者字典以供后面使用）12arr = []dic = [:] 控制流 使用if和switch来创建条件语句，使用for-in,while，以及repeat-while来创建循环语句。包裹条件或者循环变量的括号是可选的。但语句体的大括号是必不可缺的。123456789101112let numArr = [123,13,4,13,43,65]var totalNum = 0for tempNum in numArr &#123; if tempNum &lt; 50 &#123; totalNum -= 1 &#125; else&#123; totalNum += 1 &#125; print(totalNum)&#125;print("end of totalnum = \(totalNum)") 在if语句中，条件语句必须是布尔表达式，可以使用if和let来处理值缺失的情况。这些值由可选值来代表。可选值要么包含一个值，要么为nil表示值缺失。在值得类型后面跟随一个?则表示这个值是可选的。12345678910111213141516var exampleStr:String? = "hello"print(exampleStr == nil)var name:String? = "hades"var greeting = "hello~"//name = "xiye"//name = nilif let nameTemp = name &#123; //如果类型转换成功，则将值赋值给nameTemp直接使用 greeting = "hello~ \(nameTemp)" print("nameTemp = \(nameTemp) name = \(name!)") print("( let nameTemp = name ) = true");&#125;else&#123; print("name = nil ") //强制解析name 会报错 nameTemp 在这里是没法使用的 因为逻辑上只有是nil时才会走这部分代码，在swift中是什么值都没有 print("( let nameTemp = name ) = false");&#125; 如果可选值为nil，条件语句就为false，则大括号中的代码会被跳过，否则可选值将被解包，并赋值给let后的常量，这样代码中就可以使用这个值。 处理可选值得另一种方法是使用??操作符来提供默认值。如果缺少可选值，则使用默认值（如果有赋值，也不会使用提供的默认值，如果设置了可选类型，但后面被设置成nil，就会使用默认值）。 1234567var nickName: String? = nil //"whz"let fullName: String = "hades"//nickName = "whz"//nickName = nillet informalGreeting = "hi~ \(nickName ?? fullName)"print(informalGreeting) oc中的nil和swift中的nilObjective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound)Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) ‘Switch’语句支持任何类型的数据以及各种各样的比较操作——不仅仅局限于整数和测试相等。1234567891011var people = "ex"switch people &#123;case "girl": print("hey~ could you give me your wechat number?")case "man","boy": print("oh...next pls")case let x where x.hasSuffix("x")://hasSuffix以指定后缀结束，hasPrefix以指定前缀开始 print("if time can come back...")default: print("hello stranger.")&#125; 在swift中，使用switch语句，在执行完case后不需要显示的添加break，程序会自动执行完一个case跳出。你可以为字典中的键值对起一组名字，并用for in语句来遍历字典。由于字典是无序的，所以它的遍历也是无序的。1234567891011121314151617let someNumbers = [ "key1":[2,4,1,5,31], "key2":[2,43,2,5,1,53], "key3":[2345,13,1,3,13,65]]var maxNum = 0;var maxName:String = ""for (keyInSomeNumbers,valueInSomeNumbers) in someNumbers &#123; for values in valueInSomeNumbers &#123; if values &gt; maxNum &#123; maxNum = values maxName = "\(keyInSomeNumbers)" &#125; &#125;&#125;print("\(maxName) \(maxNum)") 使用while来循环执行代码12345678910111213var n = 0while n &lt; 100 &#123; n = n*n + 1&#125;print(n)var m = 0repeat&#123; m = m + 1 print("m = \(m)")&#125;while m &lt; 10print(m) 可以使用..&lt;来限定索引范围，并在循环中遍历该索引范围12345var total = 0for i in 1..&lt;4 &#123; total += i&#125;print(total) 函数和闭包使用func来声明一个函数。使用函数名和参数名来调用函数。使用-&gt;来指定函数返回值类型。1234func greet (person:String,day:String)-&gt; String&#123; return "Hello \(person),today is \(day)"&#125;print(greet(person: "whz", day: "thuesday")) 默认情况下，函数会使用它们的参数名称作为参数标签，在参数名称前可以自定义参数标签，或使用_来表示来不使用参数标签。1234func greet(_ preson:String,on day:String)-&gt; String&#123; return "hello \(preson),today is \(day)"&#125;print(greet("hades", on: "friday")) 使用元组来生成复合值，例如使用元组来让一个函数返回多个值。该元组的元素可以通过名称或者数字来获取。1234567891011121314151617181920func function(scores:[Int]) -&gt; (min:Int,max:Int,sum:Int)&#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else&#123; min = score &#125; sum = sum + score &#125; return (min,max,sum)&#125;let result = function(scores: [1,31,413,356,1,376,463])print(result.max)print(result)print(result.2) 函数间可相互嵌套。被嵌套的函数可以访问外部函数中声明的变量，你可以使用嵌套函数来重构一个过于冗长或者复杂的函数。123456789func returnFifteen()-&gt; Int &#123; var x = 10 func add()&#123; x += 5 &#125; add() return x&#125;print(returnFifteen()) 函数是一个类型。意味着函数可以作为其他函数的返回值。12345678func returnOneFunction() -&gt; ((Int) -&gt; Int)&#123; func returnOneInt(number:Int) -&gt; Int&#123; return number + 1 &#125; return returnOneInt&#125;var anotherFunction = returnOneFunction()print(anotherFunction(3)) 一个函数也可以作为参数传入另一个函数1234567891011121314func hasAnyMatches(list:[Int],condition:(Int)-&gt;Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; print(item) return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数是一种特殊的闭包：它是可以在之后被调用的一段代码。在闭包里的代码可以访问到闭包作用域范围内的变量和函数，即使闭包是在不同的作用域被执行你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型与闭包函数体分离。12345678var numbers = [20,19,7,12]hasAnyMatches(list: numbers, condition: lessThanTen)numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number print(111) return result&#125;) 写出更简洁的闭包有很多种方法。当我们已知一个闭包的类型，比如作为一个代理的回调，你可以忽略参数、返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。12345var temp = [3,41,5,1,51]let temp1 = temp.map&#123; num in num + 1&#125; swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断，再次简写1234print(temp1)let temp2 = temp.map&#123; $0 + 1&#125; 对象和类通过在类名前加class关键字的方法来创建一个类。类中的属性声明和变量的属性声明相同，唯一不同的是，类的属性声明上下文是类。类似的，方法和函数也是同样方式来声明。123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 通过在类名称后面插入括号来创建类的实例。使用.语法的方式来访问实例中的属性和方法。1234var shape = Shape()shape.numberOfSides = 9var shapeDescription = shape.simpleDescription()print(shapeDescription) 当一个类的属性没有初始值，你就需要使用init来创建一个构造器。1234567891011class NamedShape &#123; var numberOfSides:Int = 0 var name: String init(name: String) &#123; self.name = name &#125; func description() -&gt; String &#123; return "A shape with \(numberOfSides) sides" &#125;&#125; 这里的self被用来区分name属性和构造器的name参数。当你创建类实例时，会像传入参数一样，给类传入构造器的参数。每个属性都要指定一个值— 无论在声明中还是在构造器里。如果你需要在对象被释放前执行一些清理的行为，可以使用deinit来创建一个折构器。 子类会在其类名后面加上父类的名字，并用冒号分割。创建类的时候，并不需要一个标准根类，因此你可以根据自己的需求，添加或省略父类的声明。 子类如果需要重写父类的方法，则需要使用override来标记—不使用override关键字来标记会导致编译器报错。编译器同样也会检查override标记的方法是否存在父类当中。1234567891011121314151617181920class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 5 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func description() -&gt; String &#123; return "A square with sides of length \(sideLength)" &#125;&#125;let test = Square(sideLength: 4.1, name: "test square")print(test.area())print(test.description()) 除了存储简单的属性，属性还可以拥有getter和setter123456789101112131415161718192021222324252627class EquilaterTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double,name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength = newValue / 3.0 &#125; &#125; override func description() -&gt; String &#123; return "this is a triangle with sides of length \(sideLength)" &#125;&#125;var triangle = EquilaterTriangle(sideLength: 4.3, name: "a triangle")print(triangle.perimeter)triangle.perimeter = 9print(triangle.sideLength) 在perimeter的setter中，新值被隐式的命名为newValue。你可以在set的括号后面，显式的提供一个名字。 注意EquilateralTriangle类的初始化有三个不同的步骤： 1 设定子类的声明的属性值 2 调用父类的构造器 3 改变父类定义的属性值。其他的工作如调用方法，getter或者setter都可以在这个时候完成。 如果你不需要计算属性，但是仍需要在设置一个新值之前或之后来执行代码，则可以使用willSet和didSet。代码会在属性值发生改变时被执行，在构造器中属性值发生改变的情况除外。例如，下面的类确保三角形的边长始终和正方形的边长相同。123456789101112131415161718192021class TriangleAndSquare &#123; var triangle: EquilaterTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square:Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square = Square(sideLength: size, name: name) triangle = EquilaterTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: "test")print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 40, name: "larger square")print(triangleAndSquare.triangle.sideLength) 在处理可选值时，你可以在如方法、属性和下标脚本等操作之前使用?。如果?前的值是nil,则?后面的所有内容都会被忽略，且整个表达式为nil。否则，可选项的值将被展开，然后?后面的代码会根据展开的值来执行。在这两种情况下，整个表达式的值是一个可选值。12let optionalSquare: Square? = Square(sideLength: 2.3, name: "optional square")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建枚举。像类和其他所有命名类型一样，枚举也包含方法。123456789101112131415161718192021enum Rank: Int &#123; case ace = 1 case two,three,four,five,six,seven,eight,nine,ten case jack,queen,king func simpleDescription() -&gt; String &#123; switch self &#123; case .ace: return "ace" case .jack: return "jack" case .queen: return "queen" case .king: return "king" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue 默认情况下，swift 从 0 开始给原始值赋值，而后依次递增 1，你也可以通过指定一个特定值来改变这一行行为。在上边的例子中，Ace的原始值被显示赋值为1，其余的原始值会按照顺序来赋值。同样的，你也可以使用字符串或者浮点数来作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。使用init?(rawValue:)初始化构造器来创建一个拥有原始值得枚举实例。如果在Rank中有与该原始值相匹配的枚举实例则返回该实例，没有则返回nil。123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举成员的值是实际值，而不是原始值的另外一种写法。事实上，如果没有一个有意义的原始值，你也没必要再提供一个。1234567891011121314151617enum Suit &#123; case spades,hearts,diamonds,clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .spades: return "spades" case .hearts: return "hearts" case .diamonds: return "diamonds" case .clubs: return "clubs" &#125; &#125;&#125;let hearts = Suit.heartslet haartsDescriotion = hearts.simpleDescription() 注意在上面例子中用了两种方法来调用hearts成员：给hearts指定一个常量时，枚举成员Suit.hearts需要全名调用，因为常量没有显示指定类型。在switch语句中，枚举成员可以通过缩写的方式.hearts被调用，因为self的值已经确定是Suit类型。在值得类型已经被明确的情况下可以使用缩写。 如果一个枚举成员拥有原始值，那么这些值在声明时就会被确定，也就是说，每一个不同枚举实例的枚举成员总有一个相同的原始值。另外一种选择是为枚举成员设定关联值—这些值会在实例被创建时确定，这样它们在每一个实例中的原始值就不一样了。你可以将关联值想象成与枚举实例存储属性一样。例如，考虑在服务器上请求日出和日落的情况。服务器要么返回请求信息，要么返回错误信息。12345678910111213enum ServerResponse &#123; case result(String,String) case failure(String)&#125;let success = ServerResponse.result("6:00 am","8:00 pm")let failure = ServerResponse.failure("fail")switch success &#123;case let .result(sunrise,sunset): print(" sunrise is at \(sunrise) and sunset is at\(sunset)")case let .failure(message): print("fail - \(message)")&#125; 注意日出日落时间是如何从ServerResponse值中进行提取，并与 switch cases 相匹配的。 使用struct来创建一个结构体。结构体提供了很多和类相似的行为，包括方法和构造器。类和结构体最重要的区别就是结构体在传递的时候会拷贝自身，而类则会传递引用。123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription()) of \(suit.simpleDescription())" &#125;&#125;let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 协议和扩展使用protocol来声明一个协议。mutating关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量1234protocol ExampleProtocol &#123; var simpleDescription: String&#123; get &#125; mutating func adjust()&#125; 类、枚举和结构都可以遵循协议12345678910111213141516171819202122class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = "a simple class" var anotherPriperty: Int = 69105 func adjust() &#123; simpleDescription += "now 100% adjusted" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct simpleStructure: ExampleProtocol &#123; var simpleDescription: String = "a simple sturcture" mutating func adjust() &#123; simpleDescription += "(adjusted)" &#125;&#125;var b = simpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明SimpleStructure时使用了关键字mutating来标记一个可以修改结构体的方法。而声明SimpleClass时，则不需要标记任何方法，因为一个类中的方法总是可以修改类属性的。 使用extension可以为现有的类型添加功能，例如新方法和计算属性。你可以使用拓展将协议一致性添加到其他地方声明的类型，甚至是你从其他库或框架导入的类型。123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return "the number \(self)" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) 你可以像使用其他命名类型一样来使用协议—例如，创建一个具有不同类型但是都遵守某一个协议对的对象集合。当你处理的类型为协议的值时，协议外定义的方法是不可用的。1234let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)//下面这句会报错print(protocolValue.anotherProperty) 尽管变量protocolValue在运行时类型为SimpleClass，但编译器依旧会把它的类型当做ExampleProtocol。这也就意味着，你不能随意访问在协议外的方法或属性。 错误处理你可以使用任何遵循Error协议的类型来表示错误。12345enum PrintError: Error &#123; case outOfPaper case noToner case onFire&#125; 使用throw跑出异常并且用throws来标记一个可以抛出异常的函数。如果你在一个函数中抛出异常，这个函数会立即返回并且调用处理函数错误的代码。123456func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == "Never Has Toner" &#123; throw PrintError.noToner &#125; return "Job sent"&#125; 这里有几种方法可以处理异常。一种是使用do-catch。在do代码块里，你可以是用try在抛出的异常的函数前标记。在catch代码块里边，如果你不给定其他名字的话，错误会自动赋予名字为error。123456do &#123; let printerResponse = try send(job: 1040, toPrinter: "Never Has Toner") print(printerResponse)&#125; catch&#123; print(error)&#125; 你可以提供多个catch代码块来处理特定的错误。你可以在catch后面一个一个模式，就像switch语句里面的case一样。12345678910 do &#123; let printerResponse = try send(job: 1440, toPrinter: "Gutenberg") print(printerResponse)&#125; catch PrintError.onFire &#123; print("I'll just put this over here, with the rest of the fire.")&#125; catch let printerError as PrintError &#123; print("Printer error: \(printerError)")&#125; catch &#123; print(error)&#125; 另外一种处理错误的方法是用try?去转换结果为可选项。如果这个函数抛出了异常，那么这个错误会被忽略并且结果为nil。否则，结果是一个包含了函数返回值的和选项。12let printerSuccess = try? send(job: 1883, toPrinter: "Mergenthaler")let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner") 使用defer来写在函数返回后也会被执行的代码块。无论这个函数是否抛出异常，这个代码都会被执行。即使他们需要在不同的时间段执行，你仍可以使用defer来简化代码。1234567891011121314var fridgeIsOpen = falselet fridgeContent = ["milk","eggs","leftovers"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result&#125;fridgeContains("milk")print(fridgeIsOpen) defer常用于数据库操作中的打开关闭或者我们要执行某些必要操作流程时候defer会在该当前声明的作用域结束的时候执行优先级： 局部优先、同级自下而上12345678910111213141516171819func firstProcesses(_ isOpen: Bool) &#123; //作用域1 整个函数作用域 defer&#123; print("推迟操作🐢") &#125; print("😳") if isOpen == true &#123; //作用域2 if的作用域 defer&#123; print("推迟操作🐌") &#125; print("😁") &#125; print(111)&#125;firstProcesses(true) 泛型把名字写在尖括号里来创建一个泛型方法或者类型。12345678func makeArray&lt;Item&gt;(repeating item: Item,numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;makeArray(repeating: "knock", numberOfTimes: 4) 你可以从函数的方法中，同时还有类，枚举以及结构体中创建泛型。123456enum OptionalValue&lt;Wrapped&gt; &#123; case none case some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100) 在类型名称后紧接where来明确一系列需求—例如，需求类型实现一个协议，要求两个类型必须相同，或者要求类必须继承来自特定的父亲。1234567891011func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T,_ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1,2,3], [3])]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift4.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM是什么( ´ﾟωﾟ)？]]></title>
    <url>%2F2018%2F08%2F23%2FLLVM%2F</url>
    <content type="text"><![CDATA[LLVM的logo用的是dragon，为啥？因为dragon象征力量，速度和智慧，同时又带着时尚，优雅和modular（官方error），并且从1977年起，诸多颇具影响力的编译器书籍封面上都有龙 简述LLVM 一个开源编译器架构，目前Xcode采用的就是LLVM架构。 Clang 由苹果赞助支持开发的LLVM的编译器前端，目前支持C,C++,Object-C和Object-C++.相对于GCC，Clang快，占用内存小，易于IDE集成，与GCC兼容，诊断可读性强和易拓展等。 GCC GNU的编译器套装，原本只处理C语言，后来拓展可处理Fortran、Pascal、Objective-C、Java、Ada，Go等。许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GNU GNU是一个自由的操作系统，但其具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。 在Xcode上使用GCC Xcode在C和C++上是支持使用GCC的，如下：具体参数的使用请参考：stackoverflow:Xcode上的GNU GCC 更多概念LLVM全名：Low Level Virtual Machine 直译：底层虚拟机/loʊ ˈlɛvəl ˈvɜrʧuəl məˈʃin/ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.- 来自LLVM官网的介绍 LLVM官网 LLVM项目是模块化和可重用的编译器和工具链技术的集合。尽管名称如此，但LLVM与传统虚拟机几乎没有关系。“LLVM”不是首字母缩略词而是项目的全名。 LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。它最早以C/C++为实现对象，而目前它已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala以及C#等语言。 - 来自维基百科 LLVM on wiki 简单来说 LLVM是一个开源的编译器架构而不是编译器。是一套用于开发编译器、解释器等程序语言相关工具的库，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT等。编译器是Clang，GCC，ICC，VC++等。 Xcode和LLVM Xcode3之前，用的是GCCXcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能Xcode4.6,LLVM升级到4.2版本Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成 ClangClang /ˈklæŋ/ 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端，而且由LLVM2.6开始，一起发布新版本。它的目标是提供一个GNU编译器套装（GCC）的替代品，支持了GNU编译器大多数的编译设置以及非官方语言的扩展。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发，而源代码许可是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang项目包括Clang前端和Clang静态分析器等。- 来自维基百科 Clang on wiki GCCGCC官网GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。 原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。 许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果计算机预装的Mac OS X操作系统也采用这个编译器。 GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。- 来自维基百科 GCC on wiki GNUGNU官网GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。 作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。- 来自维基百科 GNU on wiki LLDBLLDB是一种软件调试器。它构建为一组可重用的组件，被LLVM项目的现有库广泛使用，例如Clang表达式解析器和LLVM 反汇编程序。尽管LLDB处于早期开发阶段，但它已经足够成熟，可以支持用C，Objective-C，C ++和Swift编写的程序的基本调试。LLDB可以在macOS，Linux，FreeBSD和Windows上运行，并支持i386，x86-64和ARM 指令集。它用作Xcode 5及更高版本的默认调试器。 GDBGNU Debugger 顾名思义支持编程语言有C、C++、Pascal以及FORTRAN在许多的类UNIX操作系统上都可以使用 词法分析lexical analysis /ˈlɛksɪkəl/词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。 语法分析syntactic analysis，也叫 parsing/sɪnˈtæktɪk əˈnæləsəs/ /ˈpɑːzɪŋ/语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述. 语法分析器parser通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。 源语言&amp;源程序Source language&amp;Source program被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言。 目标语言&amp;目标程序Object language or Target language &amp; Object program or Target program编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言。 中间语言（中间表示）Intermediate language（representation）在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。另外，还可以在中间代码一级进行与机器无关的优化。 文法Grammars/ˈgræməz/文法是用于描述语言的语法结构的形式规则。 token是一个字符串，是构成源代码的最小单位。从输入字符流中生成标记的过程叫作标记化（tokenization），在这个过程中，词法分析器还会对标记进行分类。词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。 抽象语法树abstract syntax tree或者缩写为AST/ˈæbstrækt ˈsɪnˌtæks tri/抽象语法树，或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。 具体CMD+BObjective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。 在使用Xcode按下cmd+B后，会经过以下流程：预处理（Pre-process）：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。 词法分析 （Lexical Analysis）：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 语法分析（Semantic Analysis）：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成。 静态分析（Static Analysis）：使用它来表示用于分析源代码以便自动发现错误。 中间代码生成（Code Generation）：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。 优化（Optimize）：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。 生成目标文件（Assemble）：生成Target相关Object(Mach-o) 。 链接（Link）：生成 Executable 可执行文件。 关于此过程的详细测试，参考掘金 LLVM的具体操作请参考关于LLVM，这些东西你必须知道！ 基于ClangPlugin 可以用来定义一些编码规范，比如代码风格检查，命名检查等等Pass就是LLVM系统转化和优化的工作的一个节点，可以写一个这样的节点去做一些自己的优化工作或者其它的操作，比如 a+b 改为 a-(-b)将Pass加入PassManager管理,这样我们就可以直接通过clang的参数去加载我们的Pass了基于Pass，我们可以编写自己的Pass去混淆代码，以增加他人反编译的难度。 所以基于LLVM可以完成： 做语法树分析，实现语言转换OC转Swift、JS or 其它语言，字符串加密。 编写ClangPlugin，命名规范，代码规范，扩展功能。 编写Pass，代码混淆优化。 使用Clang进行开发详细参考IBM developerWorks Clang的特性相比于 GCC，Clang 具有如下优点： 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强： 支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。 支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。 以下是目前GCC和Clang对C++支持的情况： 更多参考C++ 编译器支持情况表 使用LLVM创建一个编译器首先参考这篇文章来写一个helloworldIBM developerWorks 关于LLVM IR的生成与创建IBM developerWorks]]></content>
      <categories>
        <category>编译相关</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
        <tag>GNU</tag>
        <tag>GCC</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本的入门（一）]]></title>
    <url>%2F2018%2F08%2F15%2FShell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Shell脚本能极大简化那些简答而重复的工作，学会写Shell，我觉得可以。 Simple BB 为了简化工作量，我需要写个替换同名资源的脚本，看了一天的shell简单的写下我的思路首先获取用于替换的资源的路径,然后生成一个临时文件A,遍历获取对应的文件名，重定向输出到A。获取目标资源的路径，根据A中的行数进行循环find查找，找到就用cp命令替换，未找到的重定向输出到临时文件B最后打印B的内容，remove临时文件。其中对文本的处理使用了awk命令 脚本下载地址在我的github上 资源替换脚本 Shell介绍 Shell Script ，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，它使用了Linux/Unix下的命令。而我使用shell只是因为我用的mac - - Shell的工作原理 Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。 Shell的创建 1.打开文本编辑工具，输入一下内容#!/bin/bash echo &quot;Hello World&quot;2.保存为 hello world.sh在目录 A3.在终端cd到目录 A4.终端输入chmod +x ./hello world.sh （这一步是给脚本添加权限）5.执行脚本 ./hello world.sh 或者 直接把 hello world.sh拖入终端 这很简单，无图。 Shell中的变量变量的定义1example="a1" 或者 1example=a1 但是example=a 1 并不等同于 example=&quot;a 1&quot;因为&quot; &quot;（空格）在shell中用作指令的间隔example=a 1 其实只是将a负责给example 然后在输入了个1 这很重要，在很多赋值的时候不注意会导致获取到的变量并不是你期望的那样，别问我怎么知道的！ 变量的访问在变量前加上$ 1echo $example Shell中的四则运算1234$a + $b$a - $b$a \* $b$a / $b 注意 乘法的时候需要进行转义= 赋值时，前后无空格而运算符号前后必须有空格 Shell中的其他运算符 =、==、!=、！、-o、-a 12-o 或-a 与 关系运算符 -eq 两个数相等返回true-ne 两个数不相等返回true-gt 左侧数大于右侧数返回true-It 左侧数小于右侧数返回true-ge 左侧数大于等于右侧数返回true-le 左侧数小于等于右侧数返回true 字符串运算符 = 两个字符串相等返回true!= 两个字符串不相等返回true-z 字符串长度为0返回true-n 字符串长度不为0返回true-d file 检测文件是否是目录，如果是，则返回 true-r file 检测文件是否可读，如果是，则返回 true-w file 检测文件是否可写，如果是，则返回 true-x file 检测文件是否可执行，如果是，则返回 true-s file 检测文件是否为空（文件大小是否大于0，不为空返回 true-e file 检测文件（包括目录）是否存在，如果是，则返回 true Shell字符串操作123456mtext="hello" #定义字符串mtext2="world"mtext3=$mtext" "$mtext2 #字符串的拼接echo $mtext3 #输出字符串echo $&#123;#mtext3&#125; #输出字符串长度echo $&#123;mtext3:1:4&#125; #截取字符串 Shell数组12345678array=(1 2 3 4 5) #定义数组array2=(aa bb cc dd ee) #定义数组value=$&#123;array[3]&#125; #找到某一个下标的数，然后赋值echo $value #打印value2=$&#123;array2[3]&#125; #找到某一个下标的数，然后赋值echo $value2 #打印length=$&#123;#array[* ]&#125; #获取数组长度echo $length Shell输出1echo Shell的判断12345678910111213141516171819202122232425262728a=10b=20if [ $a == $b ]thenecho "true"fiif [ $a == $b ]thenecho "true"elseecho "false"fiif [ $a == $b ]thenecho "a is equal to b"elif [ $a -gt $b ]thenecho "a is greater than b"elif [ $a -lt $b ]thenecho "a is less than b"elseecho "None of the condition met"fi Shell中的test命令12345678910 test $[num1] -eq $[num2] #判断两个变量是否相等 test num1=num2 #判断两个数字是否相等-e file 文件存在则返回真-r file 文件存在并且可读则返回真-w file 文件存在并且可写则返回真-x file 文件存在并且可执行则返回真-s file 文件存在并且内容不为空则返回真-d file 文件目录存在则返回真 Shell中的循环for循环123456789101112131415161718192021for ((i=1;i&lt;=10;i++))doecho $idonefor i in &#123;1..5&#125;doecho $idonefor i in 5 6 7 8 9doecho $idonefor FILE in $HOME/.bash*doecho $FILEdone while循环123456789101112while [ $COUNTER -lt 5 ]doCOUNTER=`expr $COUNTER + 1`echo $COUNTERdoneecho '请输入。。。'echo 'ctrl + d 即可停止该程序'while read FILMdoecho "Yeah! great film the $FILM"done 跳出循环123break #跳出所有循环break n #跳出第n层f循环continue #跳出当前循环 Shell中的函数 无参数无返回值 12345678910111213141516171819202122232425262728293031 sysout()&#123; echo "hello world" &#125; sysout &lt;/code&gt;&lt;/pre&gt;&gt; 无参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; aNum=3 anotherNum=5 return $(($aNum+$anotherNum)) &#125; test result=$? echo $result&lt;/code&gt;&lt;/pre&gt;&gt; 有参数有返回值&lt;pre&gt;&lt;code&gt; test()&#123; echo $1 #接收第一个参数 echo $2 #接收第二个参数 echo $3 #接收第三个参数 echo $# #接收到参数的个数 echo $* #接收到的所有参数 &#125; test aa bb cc Shell中的重定向123$echo result &gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写$echo result &gt;&gt; file #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写echo input &lt; file #获取输入流 Shell中的变量操作 awk 指令获取指定行数的资源名字1sourceNameTemp=$(awk 'NR=="'$i'" &#123;print;exit&#125;' $OutputFile) 获取对应文件名1temp=$&#123;temp##*/&#125; 清空文件1: &gt; "$OutputFile" 常用的Linux命令awk命令 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 基本结构1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中 工作原理 第一步：执行BEGIN{ commands }语句块中的语句；第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。第三步：当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 获取指定行数的文本1awk 'NR=="'$i'" &#123;print;exit&#125;' file 获取文件的行数1awk '&#123;print NR&#125;' "file"|tail -n1 关于awk的详细用法请参考 awk命令]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
